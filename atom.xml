<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Andy.Lee's  Blog]]></title>
  <subtitle><![CDATA[Good good study, day day up !]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://huaqianlee.me/"/>
  <updated>2016-05-06T16:27:11.068Z</updated>
  <id>http://huaqianlee.me/</id>
  
  <author>
    <name><![CDATA[Andy.Lee]]></name>
    <email><![CDATA[huaqianlee@gmail.com]]></email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[手机无人机常用sensor介绍]]></title>
    <link href="http://huaqianlee.me/2016/05/07/Uav/mobile-and-uav-sensors/"/>
    <id>http://huaqianlee.me/2016/05/07/Uav/mobile-and-uav-sensors/</id>
    <published>2016-05-06T16:12:14.000Z</published>
    <updated>2016-05-06T16:27:11.068Z</updated>
    <content type="html"><![CDATA[<p>一直以来对这些常用的传感器不是很清楚, 有时听到名字或者简称,不知道有什么具体的用途,特地简单总结一下.</p>
<blockquote>
<p>资料皆是网上获取,不能完全保证准确性.</p>
</blockquote>
<h2 id="重力传感器(gravity/g-sensor)">重力传感器(gravity/g-sensor)</h2><p>重力传感器是根据压电效应的原理来工作的, 将加速度转化成电压输出。简单来说是测量内部一片重物(重物和压电片做成一体)重力正交两个方向的分力大小，来判定水平方向。<br>应用场景：手机横竖屏幕切换、翻转静音、平衡球、各种射击、赛车游戏等。</p>
<a id="more"></a>
<h2 id="加速度传感器(Accelerometer)">加速度传感器(Accelerometer)</h2><p>加速度传感器是一种能够测量加速力的电子设备。加速力就是当物体在加速过程中作用在物体上的力，就好比地球引力，也就是重力。一般在手机被提到加速度感应器时，就是指重力感应器。<br>应用场景：微信摇一摇、甩动切歌等</p>
<h2 id="距离传感器(Proximity/p-sensor)">距离传感器(Proximity/p-sensor)</h2><p>通过发射特别短的光脉冲，并测量此光脉冲从发射到被物体反射回来的时间，通过测时间来计算与物体之间的距离。<br>应用场景：通话时手机靠近脸部，屏幕背景灯熄灭，离开时背景灯点亮并解锁屏幕。</p>
<h2 id="光线感应器(Light)">光线感应器(Light)</h2><p>对投光器受光器间之光线做遮蔽动作所获得的信号加以运用以完成各种自动化控制。<br>应用场景：自动调整屏幕亮度功能等</p>
<h2 id="三轴陀螺仪(Gyroscope)">三轴陀螺仪(Gyroscope)</h2><p>同时测定6个方向的位置，移动轨迹，加速。单轴的只能测量一个方向的量，也就是一个系统需要三个陀螺仪，而3轴的一个就能替代三个单轴的。测量角速度，以判别物体的运动状态，也称为运动传感器。判断在哪去哪。<br>应用场景：目前主要应用在一些大型手机射击游戏中，如狂野飙车等,用于辅助GPS定位。<br>如下是网上看到的两幅很形象图片：<br>单轴陀螺仪:<br><img src="http://7xjdax.com1.z0.glb.clouddn.com/a_tuoluoyi.gif" alt="single-Gyroscope"><br>三轴陀螺仪:<br><img src="http://7xjdax.com1.z0.glb.clouddn.com/tuoluoyi.gif" alt="three-Gyroscope"></p>
<h2 id="地磁/磁力计/电子罗盘(Magnetic/compass)">地磁/磁力计/电子罗盘(Magnetic/compass)</h2><p>工作原理：电子罗盘，也叫数字指南针，是利用地磁场来定北极的一种方法。。<br>应用场景：各种指南针以及导航软件、地图等</p>
<h2 id="气压计_(Barometer)">气压计 (Barometer)</h2><p>气压传感器用于检测大气压强的仪器,实际应用当中气压传感器可作高度计，提示海拔高度，尤其适合登山、户外单车、滑雪以及其他户外运动中，您可以据此在地图上分析高度、寻找正确路径等。同时也用于GPS精确导航（航位推算，上下桥检测等），手机GPS海拔测量，室内室外导航，休闲、体育和医疗健康等监测，天气预报、垂直速度指示（上升/下沉速度），风扇功率控制、温度显示等。 </p>
<h2 id="超声波/声呐(sonar)">超声波/声呐(sonar)</h2><p>应用场景：超声波测距,避障.</p>
<h2 id="光流（camera）">光流（camera）</h2><p>光流法是运动图像分析的重要方法,因为当物体在运动时，它在图像上对应点的亮度模式也在运动。这种图像亮度模式的表观运动（apparent motion）就是光流。光流表达了图像的变化，由于它包含了目标运动的信息，因此可被观察者用来确定目标的运动情况。从本质上说，光流就是你在这个运动着的世界里感觉到的明显的视觉运动。通过光流camera看到物体的相对运动速度是不一样的,通过不同目标的运动速度判断它们与我们的距离。</p>
<h2 id="IMU">IMU</h2><p>同时包含陀螺仪、地磁、加速度计的传感器芯片，如mpu9x50。</p>
<p>还有如热传感器、温度传感器、湿度传感器、紫外线传感器、压力传感器等</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>一直以来对这些常用的传感器不是很清楚, 有时听到名字或者简称,不知道有什么具体的用途,特地简单总结一下.</p>
<blockquote>
<p>资料皆是网上获取,不能完全保证准确性.</p>
</blockquote>
<h2 id="重力传感器(gravity/g-sensor)">重力传感器(gravity/g-sensor)</h2><p>重力传感器是根据压电效应的原理来工作的, 将加速度转化成电压输出。简单来说是测量内部一片重物(重物和压电片做成一体)重力正交两个方向的分力大小，来判定水平方向。<br>应用场景：手机横竖屏幕切换、翻转静音、平衡球、各种射击、赛车游戏等。</p>]]>
    
    </summary>
    
      <category term="Uav" scheme="http://huaqianlee.me/categories/Uav/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[高通无人机8074 BLSP接口说明]]></title>
    <link href="http://huaqianlee.me/2016/05/07/Uav/Qualcomm-uav-blsp-port/"/>
    <id>http://huaqianlee.me/2016/05/07/Uav/Qualcomm-uav-blsp-port/</id>
    <published>2016-05-06T16:11:58.000Z</published>
    <updated>2016-05-06T16:19:42.816Z</updated>
    <content type="html"><![CDATA[<h2 id="概述">概述</h2><p>BLSP是高通对于低速接口的一种管理方式，8074 平台含有两个BLSP(BAM Low-Speed Peripheral) 块，对应于12个BLSP端口。 每一个BLSP块含有最多六个Qualcomm Universal Peripheral (QUP)或六个Uart cores，通过相关手册查询到每个外设属于BLSP多少。结构框图如下：<br><img src="http://7xjdax.com1.z0.glb.clouddn.com/BLSP.png" alt="BLSP"></p>
<blockquote>
<ol>
<li>BAM（Bus Access Manager）is used to move data to/from the peripheral buffers;  2.每个BLSP外设静态连接到一对BAM管道，BLSP支持BAM 和non-BAM-based 数据传输。</li>
</ol>
</blockquote>
<a id="more"></a>
<p>每一个QUP可以被配置为I2C， SPI, UART, UIM接口等，如下：<br><img src="http://7xjdax.com1.z0.glb.clouddn.com/blsp_pin.jpg" alt="blsp_pin"></p>
<h2 id="自定义BLSP口，配置TZ">自定义BLSP口，配置TZ</h2><p>这些端口在aDSP和应用处理器之间共享。为了让BLSP端口独立使用，我们可以在TrustZone（TZ）中定义BLSP 端口的分配，没有权限的子系统访问BLSP 端口将导致系统崩溃。 高通默认已经做好了配置。在DspAL中， 提供了一组设备文件路径映射到硬件，无人机用到的相关口已经在TZ中配置好了，如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SPI:  /dev/spi-[<span class="number">1</span>~<span class="number">12</span>]  对应于   BLSP[<span class="number">1</span>~<span class="number">12</span>]上的SPI设备</span><br><span class="line">I2C: /dev/iic-[<span class="number">1</span>-<span class="number">12</span>]      对应于   BLSP[<span class="number">1</span>~<span class="number">12</span>]上的I2C设备</span><br><span class="line">UART: /dev/tty-[<span class="number">1</span>-<span class="number">4</span>]</span><br><span class="line"><span class="comment"># UAV 8074 最多支持4个串口设备，每一个串口设备对应一个BAM设备，</span></span><br></pre></td></tr></table></figure></p>
<p>如果要自定义新的端口，需按于如下方式配置：</p>
<h3 id="计算APPS_BLSP值">计算APPS BLSP值</h3><p><img src="http://7xjdax.com1.z0.glb.clouddn.com/apps_blsp.jpg" alt="apps-BLSP"><br>根据倒数第二列（对应于BAM pipe）计算出结果如下：<br>APPS BLSP1 : 0x00C3000C   [ Format : 0x00 (Apps BLSP1 QUP) ( Apps BLSP1 UART) ]<br>APPS BLSP2 : 0x00F30F33   [ Format : 0x00 (Apps BLSP2 QUP) ( Apps BLSP2 UART) ]</p>
<blockquote>
<p>Apps列对应Y，则表明BLSPx配为Uart或QUP，下同。</p>
</blockquote>
<h3 id="计算ADSP_BLSP值">计算ADSP BLSP值</h3><p><img src="http://7xjdax.com1.z0.glb.clouddn.com/adsp_blsp.jpg" alt="adsp-BLSP"><br>ADSP BLSP1 = 0x0003FF00   [ Format : 0x00 (Adsp BLSP1 QUP) ( Adsp BLSP1 UART) ]<br>ADSP BLSP2 = 0x00FC00CC  [ Format : 0x00 (Adsp BLSP2 QUP) ( Adsp BLSP2 UART) ]</p>
<h3 id="通过计算的值在TZ中配置">通过计算的值在TZ中配置</h3><p>路径：trustzone_images\core\hwengines\bam\8974\bamtgtcfgdata_tz.h</p>
<p>BLSP1:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Replace the highlighted values with ADSP BLSP1 and APPS BLSP1</span><br><span class="line"> </span><br><span class="line">bam_sec_config_<span class="built_in">type</span> bam_tgt_blsp1_secconfig =</span><br><span class="line">&#123;</span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">#ifdef FEATURE_DRONE_CUSTOMIZATION_1 </span></span><br><span class="line"><span class="comment">#ifdef BAM_TZ_DISABLE_SPI</span></span><br><span class="line">        &#123;<span class="number">0</span>x00C3000C   , TZBSP_VMID_AP, <span class="number">0</span>x0, TZBSP_VMID_AP_BIT&#125;,       // APPS BLSP1</span><br><span class="line">        &#123;<span class="number">0</span>x0003FF00   , TZBSP_VMID_LPASS, <span class="number">0</span>x0, TZBSP_VMID_LPASS_BIT&#125;, // ADSP BLSP1</span><br><span class="line">        &#123;<span class="number">0</span>x00000000, TZBSP_VMID_MSS, <span class="number">0</span>x0, TZBSP_VMID_MSS_BIT&#125;,</span><br><span class="line"><span class="comment">#else</span></span><br><span class="line">        &#123;<span class="number">0</span>x00C3000C   , TZBSP_VMID_AP, <span class="number">0</span>x0, TZBSP_VMID_AP_BIT&#125;,       // APPS BLSP1</span><br><span class="line">        &#123;<span class="number">0</span>x0003FF00   , TZBSP_VMID_LPASS, <span class="number">0</span>x0, TZBSP_VMID_LPASS_BIT&#125;, // ADSP BLSP1</span><br><span class="line">        &#123;<span class="number">0</span>x00000000, TZBSP_VMID_MSS, <span class="number">0</span>x0, TZBSP_VMID_MSS_BIT&#125;,</span><br><span class="line">        &#123;<span class="number">0</span>x00300000, TZBSP_VMID_TZ, <span class="number">0</span>x0, TZBSP_VMID_TZ_BIT&#125;</span><br><span class="line">      </span><br><span class="line"><span class="comment">#endif /*BAM_TZ_DISABLE_SPI*/</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>BLSP2:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">bam_sec_config_<span class="built_in">type</span> bam_tgt_blsp2_secconfig =</span><br><span class="line">&#123;</span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">#ifdef FEATURE_DRONE_CUSTOMIZATION_1 </span></span><br><span class="line">        &#123;<span class="number">0</span>x00F30F33   , TZBSP_VMID_AP, <span class="number">0</span>x0, TZBSP_VMID_AP_BIT&#125;,       // APPS BLSP2</span><br><span class="line">        &#123;<span class="number">0</span>x00FC00CC  , TZBSP_VMID_LPASS, <span class="number">0</span>x0, TZBSP_VMID_LPASS_BIT&#125;   // ADSP BLSP2</span><br><span class="line"><span class="comment">#else</span></span><br><span class="line">        &#123;<span class="number">0</span>x003C0FFF, TZBSP_VMID_AP, <span class="number">0</span>x0, TZBSP_VMID_AP_BIT&#125;,</span><br><span class="line">        &#123;<span class="number">0</span>x00C3F000, TZBSP_VMID_LPASS, <span class="number">0</span>x0, TZBSP_VMID_LPASS_BIT&#125;</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="怎么工作">怎么工作</h2><p>在启动期间，aDSP将加载BLSP配置文件初始化串口设备。为了是能运行时配置，可在/usr/share/data/adsp/blsp.config中定义串口设备和BAM端口的映射，bam<em>对应于BLSP</em>。如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tty-<span class="number">1</span> bam-<span class="number">9</span></span><br><span class="line">tty-<span class="number">2</span> bam-<span class="number">6</span></span><br><span class="line">tty-<span class="number">3</span> bam-<span class="number">8</span></span><br><span class="line">tty-<span class="number">4</span> bam-<span class="number">2</span></span><br></pre></td></tr></table></figure></p>
<p>如果串口设备只用TX和RX，需要在最后一行加入 “[2-wire]”作为标示，否则默认为四线：TX，RX，CTS和RTS。</p>
<blockquote>
<ol>
<li>串口根据需要配置，不一定所有都配置；2. 如果运行时指定路径文件不存在或者加载失败，如上所示的默认配置将被使用；3. /usr/share/data/adsp/blsp.config最好设置为只读模式。</li>
</ol>
</blockquote>
<h2 id="Reference">Reference</h2><p>80-NA157-24  Low-Speed Peripherals Overview.pdf<br>80-NB849-1 Rev. J  APQ8074A PQ8074AB Device Specification.pdf<br>80-H9580-1-J_QUALCOMM SNAPDRAGON FLIGHT DEVELOPER GUIDE.pdf<br>80-NU767-1 G Linux BAM Low-Speed Peripherals Configuration and Debug Guide  .pdf</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="概述">概述</h2><p>BLSP是高通对于低速接口的一种管理方式，8074 平台含有两个BLSP(BAM Low-Speed Peripheral) 块，对应于12个BLSP端口。 每一个BLSP块含有最多六个Qualcomm Universal Peripheral (QUP)或六个Uart cores，通过相关手册查询到每个外设属于BLSP多少。结构框图如下：<br><img src="http://7xjdax.com1.z0.glb.clouddn.com/BLSP.png" alt="BLSP"></p>
<blockquote>
<ol>
<li>BAM（Bus Access Manager）is used to move data to/from the peripheral buffers;  2.每个BLSP外设静态连接到一对BAM管道，BLSP支持BAM 和non-BAM-based 数据传输。</li>
</ol>
</blockquote>]]>
    
    </summary>
    
      <category term="Uav" scheme="http://huaqianlee.me/categories/Uav/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[无人机开发主板调试]]></title>
    <link href="http://huaqianlee.me/2016/05/02/Uav/uav-board-debugging/"/>
    <id>http://huaqianlee.me/2016/05/02/Uav/uav-board-debugging/</id>
    <published>2016-05-02T13:01:57.000Z</published>
    <updated>2016-05-02T14:51:36.021Z</updated>
    <content type="html"><![CDATA[<h2 id="问题一_：_新板子不能开机，关键点：板子2+32（ddr+emmc）换为了2+16_-">问题一 ： 新板子不能开机，关键点：板子2+32（ddr+emmc）换为了2+16 .</h2><p>自己的uav主板回来后将软件刷入板子(高通msm8074), 板子不能正常启动.</p>
<p>通过分析log， 发现死在boot_images\core\boot\secboot3\hw\msm8974\sbl1\sbl1_mc.c 中 sbl1_tlmm_init() —-&gt; boot_gpio_init()， 当我屏蔽此函数后， log如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Format: Log Type - Time(microsec) - Message </span><br><span class="line">Log <span class="built_in">type</span>: B - since boot(excluding boot rom). D - delta </span><br><span class="line">B - <span class="number">41663</span> - SBL1, Start </span><br><span class="line">B - <span class="number">46909</span> - scatterload_region &amp;&amp; ram_init, Start </span><br><span class="line">D - <span class="number">30</span> - scatterload_region &amp;&amp; ram_init, Delta </span><br><span class="line">B - <span class="number">63897</span> - pm_device_init, Start </span><br><span class="line">D - <span class="number">27297</span> - pm_device_init, Delta </span><br><span class="line">B - <span class="number">91317</span> - boot_flash_init, Start </span><br><span class="line">D - <span class="number">10919</span> - boot_flash_init, Delta </span><br><span class="line">B - <span class="number">102632</span> - boot_config_data_table_init, Start </span><br><span class="line">D - <span class="number">134932</span> - boot_config_data_table_init, Delta </span><br><span class="line">B - <span class="number">239150</span> - sbl1_ddr_<span class="built_in">set</span>_params, Start </span><br><span class="line">B - <span class="number">241773</span> - Pre_DDR_clock_init, Start </span><br><span class="line">D - <span class="number">274</span> - Pre_DDR_clock_init, Delta </span><br><span class="line">D - <span class="number">0</span> - sbl1_ddr_<span class="built_in">set</span>_params, Delta </span><br><span class="line">B - <span class="number">255773</span> - pm_driver_init, Start </span><br><span class="line">D - <span class="number">16134</span> - pm_driver_init, Delta </span><br><span class="line">B - <span class="number">271907</span> - clock_init, Start </span><br><span class="line">D - <span class="number">152</span> - clock_init, Delta </span><br><span class="line">B - <span class="number">274988</span> - Image Load, Start </span><br><span class="line">B - <span class="number">295209</span> - Tz Execution, Start </span><br><span class="line">D - <span class="number">193065</span> - Tz Execution, Delta </span><br><span class="line">B - <span class="number">496387</span> - Image Load, Start </span><br><span class="line">B - <span class="number">506361</span> - Signal PBL to Jump to RPM FW </span><br><span class="line">B - <span class="number">506605</span> - sbl1_<span class="built_in">wait</span>_<span class="keyword">for</span>_ddr_training, Start   </span><br><span class="line">B - <span class="number">540399</span> - <span class="number">1</span><span class="comment">######################################################### </span></span><br><span class="line">D - <span class="number">45323</span> - sbl1_<span class="built_in">wait</span>_<span class="keyword">for</span>_ddr_training, Delta </span><br><span class="line"><span class="comment">#不屏蔽boot_gpio_init()函数,则停在此处， boot_gpio_init()中</span></span><br><span class="line">B - <span class="number">558302</span> - <span class="number">11</span><span class="comment">#########################################################   </span></span><br><span class="line">B - <span class="number">685884</span> - Image Load, Start </span><br><span class="line">B - <span class="number">689391</span> - WDT Execution, Start </span><br><span class="line">D - <span class="number">213</span> - WDT Execution, Delta </span><br><span class="line">B - <span class="number">694790</span> - Image Load, Start </span><br><span class="line">B - <span class="number">707905</span> - sbl1_efs_handle_cookies, Start</span><br></pre></td></tr></table></figure></p>
<p>　<br><a id="more"></a><br>继续跟代码一无所获。怀疑ddr配置，但仔细一想，用的相同的ddr，应该没问题，就没深究， 如若要修改对比ddr配置，参考如下方式：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ddr参数：</span><br><span class="line">boot_images\core\boot\secboot3\scripts\<span class="number">8974</span>_cdp_jedec_ddr_4_die_interleave_dal.xml   ---&gt; DDR 参数配置文件（对比ddr数据手册），</span><br><span class="line">编译：</span><br><span class="line">python cdt_generator.py <span class="number">8974</span>_cdp_jedec_ddr_4_die_interleave_dal.xml binfile.bin</span><br><span class="line">将生成boot_cdt_array.c和ddr.bin，boot_cdt_array.c替换boot_images\core\boot\secboot3\hw\msm8974\boot_cdt_array.c,然后重新make boot</span><br></pre></td></tr></table></figure></p>
<p>后怀疑应该是更换emmc后分区导致，给userdata分太多空间，而emmc空间不够。<br>修改相关文件：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">W:\uav\apq8074-le-<span class="number">1</span>-<span class="number">0</span>_ap_standard_oem\boot_images\core\storage\tools\ptool\ptool.py <span class="comment">#  python script to create GPT partition table </span></span><br><span class="line">W:\uav\apq8074-le-<span class="number">1</span>-<span class="number">0</span>_ap_standard_oem\common\build\partition.xml  <span class="comment"># partition table information </span></span><br><span class="line">W:\uav\apq8074-le-<span class="number">1</span>-<span class="number">0</span>_ap_standard_oem\apps_proc\device\qcom\msm8974\BoardConfig.mk <span class="comment">#  file system image size for android </span></span><br><span class="line"></span><br><span class="line">解析partition.xml，生成相关文件：</span><br><span class="line">ptool.py -x partition.xml   <span class="comment"># 解析partition.xml， 生成partition.bin, rawprogram.xml等文件</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">apps_proc/oe-core下执行命令生成相应文件：</span><br><span class="line">./meta-qti/scripts/mkuserimage.sh </span><br><span class="line"></span><br><span class="line">common/build下执行如下打包命令 :</span><br><span class="line">python update_common_info.py</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>如能正常启动：fastboot flash partition gpt_backup0.bin —&gt; You MUST flash the new partition table first so others should be flashed on new layout. 　　</p>
</blockquote>
<p>　</p>
<p>于是，将userdata分区空间改小一半，终于看到了一丝胜利的曙光，不过虽然能进入linaro系统，但是仍然有问题，空间不够，串口log如下：<br><img src="http://7xjdax.com1.z0.glb.clouddn.com/uav_boot_small.png" alt="uav_boot_log_1"></p>
<p>　　</p>
<p>最后，将userdata相应加大，板子成功启动。串口log如下：<br><img src="http://7xjdax.com1.z0.glb.clouddn.com/uav_boot_ok.png" alt="uav_boot_log_2"></p>
<p>　</p>
<h2 id="附_USB调试信息打开">附 USB调试信息打开</h2><ol>
<li><p>Dynamic UDC debug </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Echo ‘file dwc3-msm.c +p’ &gt; /d/dynamic_debug/control </span><br><span class="line">Echo ‘file dwc3_otg.c +p’ &gt; /d/dynamic_debug/control </span><br><span class="line">Echo ‘file phy-msm-qusb.c +p’ &gt; /d/dynamic_debug/control </span><br><span class="line">Echo ‘file phy-msm-qmp.c +p’ &gt; /d/dynamic_debug/control</span><br></pre></td></tr></table></figure>
</li>
<li><p>Kernel UDC debug configurations </p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># W:\uav\apq8074-le-1-0_ap_standard_oem\apps_proc\linux\drivers\usb\dwc3\Makefile</span></span><br><span class="line">CONFIG_USB_DWC3_DEBUG </span><br><span class="line">CONFIG_USB_DWC3_VERBOSE</span><br><span class="line"></span><br><span class="line"><span class="comment"># linux/drivers/usb/dwc3/dwc3_otg.c</span></span><br><span class="line">添加如下：</span><br><span class="line"> <span class="comment">#undef dev_dbg </span></span><br><span class="line"> <span class="comment">#define dev_dbg dev_info</span></span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="问题一_：_新板子不能开机，关键点：板子2+32（ddr+emmc）换为了2+16_-">问题一 ： 新板子不能开机，关键点：板子2+32（ddr+emmc）换为了2+16 .</h2><p>自己的uav主板回来后将软件刷入板子(高通msm8074), 板子不能正常启动.</p>
<p>通过分析log， 发现死在boot_images\core\boot\secboot3\hw\msm8974\sbl1\sbl1_mc.c 中 sbl1_tlmm_init() —-&gt; boot_gpio_init()， 当我屏蔽此函数后， log如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Format: Log Type - Time(microsec) - Message </span><br><span class="line">Log <span class="built_in">type</span>: B - since boot(excluding boot rom). D - delta </span><br><span class="line">B - <span class="number">41663</span> - SBL1, Start </span><br><span class="line">B - <span class="number">46909</span> - scatterload_region &amp;&amp; ram_init, Start </span><br><span class="line">D - <span class="number">30</span> - scatterload_region &amp;&amp; ram_init, Delta </span><br><span class="line">B - <span class="number">63897</span> - pm_device_init, Start </span><br><span class="line">D - <span class="number">27297</span> - pm_device_init, Delta </span><br><span class="line">B - <span class="number">91317</span> - boot_flash_init, Start </span><br><span class="line">D - <span class="number">10919</span> - boot_flash_init, Delta </span><br><span class="line">B - <span class="number">102632</span> - boot_config_data_table_init, Start </span><br><span class="line">D - <span class="number">134932</span> - boot_config_data_table_init, Delta </span><br><span class="line">B - <span class="number">239150</span> - sbl1_ddr_<span class="built_in">set</span>_params, Start </span><br><span class="line">B - <span class="number">241773</span> - Pre_DDR_clock_init, Start </span><br><span class="line">D - <span class="number">274</span> - Pre_DDR_clock_init, Delta </span><br><span class="line">D - <span class="number">0</span> - sbl1_ddr_<span class="built_in">set</span>_params, Delta </span><br><span class="line">B - <span class="number">255773</span> - pm_driver_init, Start </span><br><span class="line">D - <span class="number">16134</span> - pm_driver_init, Delta </span><br><span class="line">B - <span class="number">271907</span> - clock_init, Start </span><br><span class="line">D - <span class="number">152</span> - clock_init, Delta </span><br><span class="line">B - <span class="number">274988</span> - Image Load, Start </span><br><span class="line">B - <span class="number">295209</span> - Tz Execution, Start </span><br><span class="line">D - <span class="number">193065</span> - Tz Execution, Delta </span><br><span class="line">B - <span class="number">496387</span> - Image Load, Start </span><br><span class="line">B - <span class="number">506361</span> - Signal PBL to Jump to RPM FW </span><br><span class="line">B - <span class="number">506605</span> - sbl1_<span class="built_in">wait</span>_<span class="keyword">for</span>_ddr_training, Start   </span><br><span class="line">B - <span class="number">540399</span> - <span class="number">1</span><span class="comment">######################################################### </span></span><br><span class="line">D - <span class="number">45323</span> - sbl1_<span class="built_in">wait</span>_<span class="keyword">for</span>_ddr_training, Delta </span><br><span class="line"><span class="comment">#不屏蔽boot_gpio_init()函数,则停在此处， boot_gpio_init()中</span></span><br><span class="line">B - <span class="number">558302</span> - <span class="number">11</span><span class="comment">#########################################################   </span></span><br><span class="line">B - <span class="number">685884</span> - Image Load, Start </span><br><span class="line">B - <span class="number">689391</span> - WDT Execution, Start </span><br><span class="line">D - <span class="number">213</span> - WDT Execution, Delta </span><br><span class="line">B - <span class="number">694790</span> - Image Load, Start </span><br><span class="line">B - <span class="number">707905</span> - sbl1_efs_handle_cookies, Start</span><br></pre></td></tr></table></figure></p>
<p>　<br>]]>
    
    </summary>
    
      <category term="调试" scheme="http://huaqianlee.me/tags/%E8%B0%83%E8%AF%95/"/>
    
      <category term="Uav" scheme="http://huaqianlee.me/categories/Uav/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Git 常见问题集]]></title>
    <link href="http://huaqianlee.me/2015/10/22/Git/git-experence/"/>
    <id>http://huaqianlee.me/2015/10/22/Git/git-experence/</id>
    <published>2015-10-22T04:49:10.000Z</published>
    <updated>2015-10-22T05:16:20.331Z</updated>
    <content type="html"><![CDATA[<h2 id="问题一_-gitignore无效，不能过滤某些文件或路径。">问题一 .gitignore无效，不能过滤某些文件或路径。</h2><p><strong>现象:</strong><br>在.gitignore中添加了files和directories过滤，但git status仍会显示files和directories。</p>
<p><strong>原因：</strong><br>在git仓库中已经存在此files和directories，其已经被git跟踪。.gitignore只对未加入版本管理的文件生效。</p>
<p><strong>解决：</strong><br>从版本库删除文件和目录，更新。</p>
<pre><code class="bash">git rm (--cached) files directories -r <span class="operator">-f</span>
git commit
</code></pre>
<a id="more"></a>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="问题一_-gitignore无效，不能过滤某些文件或路径。">问题一 .gitignore无效，不能过滤某些文件或路径。</h2><p><strong>现象:</strong><br>在.gitignore中添加了files和directories过滤，但git status仍会显示files和directories。</p>
<p><strong>原因：</strong><br>在git仓库中已经存在此files和directories，其已经被git跟踪。.gitignore只对未加入版本管理的文件生效。</p>
<p><strong>解决：</strong><br>从版本库删除文件和目录，更新。</p>
<pre><code class="bash">git rm (--cached) files directories -r <span class="operator">-f</span>
git commit
</code></pre>]]>
    
    </summary>
    
      <category term="Tools" scheme="http://huaqianlee.me/tags/Tools/"/>
    
      <category term="Git" scheme="http://huaqianlee.me/categories/Git/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[2015年10月7日:小丑]]></title>
    <link href="http://huaqianlee.me/2015/10/08/Life/2015%E5%B9%B410%E6%9C%887%E6%97%A5-%E5%B0%8F%E4%B8%91/"/>
    <id>http://huaqianlee.me/2015/10/08/Life/2015年10月7日-小丑/</id>
    <published>2015-10-07T16:42:16.000Z</published>
    <updated>2016-05-02T13:37:22.633Z</updated>
    <content type="html"><![CDATA[<p><strong>The Only Fair Is  Not Fair.</strong><br><img src="http://7xjdax.com1.z0.glb.clouddn.com/blogemptychair.jpg" alt="em"></p>
<p>前些天去看华仔的《解救吾先生》，当“吾先生”在将死之际清唱《小丑》时，我感动得眼泛泪光。</p>
<a id="more"></a>
<p>在假期的最后一天感冒了，下午吃了感冒药，到晚上就开始梦游； 现在反而不想睡觉了，很多思绪涌入心中。想写篇博文，不知道该拟什么名字时，小丑又在我耳边响起。</p>
<p>前些时间不满现状准备离职，也拿到几个还ok的offer，在老大加薪以及一些承诺下留了下来，以为自己能很轻松地踏入下一段旅途，但不如愿。小丑仍有顽习，仍有彷徨。毕业已经三年有余，工作也已将近四年，也有无数个日夜熬到了凌晨一两点，然而至今还未有成就，还未有几多存款, 斗志也时时低沉。终其原因：自控力较差、涉猎太广、心理素质不够好以及白日梦想家。 </p>
<h3 id="自控力">自控力</h3><p>我一直觉得一个人成功与否，最重要的因素之一就是自控力。我现在还离目标甚远，自控力差是最重要的一个原因。太多的诱惑、太多的借口，总让自己放弃计划、纵容自己，一旦这样，之前培养的好习惯也将轰然坍塌。</p>
<h3 id="见样学样">见样学样</h3><p>一看到cool的东西，就去学。看了很多书，学了很多“无用”知识，直到去年才真正找准自己的方向。</p>
<h3 id="心理状态">心理状态</h3><p>心理素质不够好，挫折、失败会让自己低沉一阵子， 而自己未达到自己心中的完美样子，也会让自己低沉一阵子。也正因为自己总是想要完美，所以很多时候想做而没勇气做，就会总给自己留下遗憾。</p>
<h3 id="白日梦想家">白日梦想家</h3><p>前些天看了一部电影《白日梦想家》，觉得很好，主角开始总会做白日梦，踏出勇敢的一步后，找到了自己。发现自己很多时候正如主角一样活在自己的世界里，而我到现在还没能如主角一样踏出那么勇敢的一步。所以我现在还是会偶尔变成day dreamer，陷入自己的那个小小世界，这个时候可能只有我家那位才会觉得我还是一个帅得美丽的人类。<br><img src="http://7xjdax.com1.z0.glb.clouddn.com/blogdreamer.jpg" alt="dream"></p>
<h3 id="存款">存款</h3><p>存款，这是一个悲伤的故事。刚实习时工资就2k左右，还能存到钱。后面两年被社会坑被社会被宰（当然也是我自己傻），积蓄被挥霍一空。现在的工资已经是之前的六七倍了，却反而存不了钱,没什么积蓄。前几天计算了一下今年过来后的开销,平均每月要花一万左右,也就释然了，这样的开销怎能有多少存款呢。</p>
<h3 id="时间">时间</h3><p>每次想为自己的学习做一个计划时，就觉得时间怎么如此不够呢。就算将所有业余时间都用来学习都不够，其实还是自己学生时代和刚工作那会儿未学到正确的东西，现在想做的事又需要太多知识。</p>
<h3 id="小丑的梦想">小丑的梦想</h3><p>其实我的梦想挺简单的，自己能实现自己的任何想法，能自如的和外国人谈天说地，买自己想买的电子产品或其他东西可以毫不犹豫。</p>
<p>需要克服以前的种种缺点，养成更好的习惯；需要有好的计划，一直呆在学习区而不是舒适区（参照心理学的三个区域：舒适区、学习区、恐慌区）。</p>
<h3 id="小丑的歌词">小丑的歌词</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">小丑</span><br><span class="line">演唱：刘德华</span><br><span class="line"> </span><br><span class="line">掌声在欢呼之中响起</span><br><span class="line">眼泪已涌在笑容里</span><br><span class="line">启幕时欢乐送到你眼前</span><br><span class="line">落幕时孤独留给自己</span><br><span class="line">是多少磨炼 和多少眼泪</span><br><span class="line">才能够站在这里</span><br><span class="line">失败的痛苦 成功的鼓励</span><br><span class="line">有谁知道 这是多少岁月的累积</span><br><span class="line">小丑 小丑</span><br><span class="line">是他的辛酸 化作喜悦 呈献给你</span><br><span class="line"> </span><br><span class="line">掌声在欢呼之中响起</span><br><span class="line">眼泪已涌在笑容里</span><br><span class="line">启幕时欢乐送到你眼前</span><br><span class="line">落幕时孤独留给自己</span><br><span class="line">是多少磨炼 和多少眼泪</span><br><span class="line">才能够站在这里</span><br><span class="line">失败的痛苦 成功的鼓励</span><br><span class="line">有谁知道 这是多少岁月的累积</span><br><span class="line"> </span><br><span class="line">小丑 小丑</span><br><span class="line">是他的辛酸 化作喜悦 呈献给你</span><br><span class="line"> </span><br><span class="line">小丑 小丑</span><br><span class="line">是他的辛酸 化作喜悦 呈献给你</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>The Only Fair Is  Not Fair.</strong><br><img src="http://7xjdax.com1.z0.glb.clouddn.com/blogemptychair.jpg" alt="em"></p>
<p>前些天去看华仔的《解救吾先生》，当“吾先生”在将死之际清唱《小丑》时，我感动得眼泛泪光。</p>]]>
    
    </summary>
    
      <category term="成长" scheme="http://huaqianlee.me/tags/%E6%88%90%E9%95%BF/"/>
    
      <category term="Life" scheme="http://huaqianlee.me/categories/Life/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[高通Android设备启动流程分析(从power-on上电到Home Lanucher启动)]]></title>
    <link href="http://huaqianlee.me/2015/08/23/Android/%E9%AB%98%E9%80%9AAndroid%E8%AE%BE%E5%A4%87%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90-%E4%BB%8Epower-on%E4%B8%8A%E7%94%B5%E5%88%B0Home-Lanucher%E5%90%AF%E5%8A%A8/"/>
    <id>http://huaqianlee.me/2015/08/23/Android/高通Android设备启动流程分析-从power-on上电到Home-Lanucher启动/</id>
    <published>2015-08-23T14:07:48.000Z</published>
    <updated>2015-09-24T17:04:26.055Z</updated>
    <content type="html"><![CDATA[<p><em>Platform Information :<br>　System:    Ａndroid5.1<br>　Platform:  Qualcomm msm8916<br>　Author:     Andy Lee<br>　Email:        huaqianlee@gmail.com</em></p>
<p><strong>如有错误欢迎指出，共同学习，共同进步</strong><br>　<br>在我第一次接触Android得时候，我就很想知道Android设备在按下电源键后是怎么启动到主界面的，但是到现在为止也没有完全理清这个过程，所以就决定从按下power键开始来分析一下这个流程。虽然Android基于Linux内核开发的一个操作系统，但是在init进程后Android附加了很多其他操作，所以其启动流程还是有比较大的差别的，关于Linux系统的启动流程可以参考我的另一篇博文：<a href="http://huaqianlee.me/2015/08/21/Linux/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Linux%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/" target="_blank" rel="external">深入理解linux启动过程</a>。</p>
<p>因为我现在工作中用到的是高通的源码，并且高通也是目前Android手机的主流芯片，所以我就按照高通的msm8916来分析了，不过其他的也应该大同小异。<br>　<br>首先来看一下官方给出的Android系统架构：<br><a id="more"></a>　<br><img src="http://7xjdax.com1.z0.glb.clouddn.com/blogandroidarchitecture.jpg" alt="arch"><br>　<br>当按下电源开关后，主要执行了如下步骤：<br>　<br><img src="http://7xjdax.com1.z0.glb.clouddn.com/blogbootflow.png" alt="boot"><br>　<br>另，在内核启动了第一个进程后，init-&gt;home lanucher的详细流程如下：<br>　<br><img src="http://7xjdax.com1.z0.glb.clouddn.com/blog0_1273850759wbAp.gif" alt="boot"></p>
<blockquote>
<p>注：此图取自网络，觉得描述得很详细，故附上</p>
</blockquote>
<p>接下来就按照引导程序、内核启动、init进程、系统服务、Home Lanucher这样的顺序来分析Android启动的code。</p>
<h2 id="引导程序">引导程序</h2><p>引导程序在Android操作系统开始运行前的一个小程序，其主要为内核启动服务。引导程序执行的第一段代码，因此它是针对特定的主板与芯片的。设备制造商要么使用很受欢迎的引导程序比如redboot、uboot或者开发自己的引导程序，它不是Android操作系统的一部分。引导程序是OEM厂商或者运营商加锁和限制的地方。</p>
<p>引导程序分两个阶段执行。第一个阶段，检测外部的RAM以及加载对第二阶段有用的程序；第二阶段，引导程序设置网络、内存等等。这些对于运行内核是必要的，为了达到特殊的目标，引导程序可以根据配置参数或者输入数据设置内核。</p>
<h3 id="power-on及系统启动">power-on及系统启动</h3><p>当按下电源键或者系统重启之后，引导芯片代码PBL（Primary Boot Loader，类似于x86的BIOS）从预定义的地方（固化在ROM）开始执行，PBL由高通做好了的烧写在芯片中，PBL将启动设备、支持紧急下载等，然后加载引导程序sbl1，然后跳转到sbl1执行。</p>
<h3 id="处理器启动地址">处理器启动地址</h3><p>MSM8916芯片内部有很多不同的处理器，如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">子系统</th>
<th style="text-align:center">处理器</th>
<th style="text-align:center">启动地址</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">APPS</td>
<td style="text-align:center">Cortex-a53</td>
<td style="text-align:center">0xfc010000</td>
</tr>
<tr>
<td style="text-align:center">RPM</td>
<td style="text-align:center">Cortex-m3</td>
<td style="text-align:center">0x00200000/0x0</td>
</tr>
<tr>
<td style="text-align:center">Modem</td>
<td style="text-align:center">MSS_QDSP6</td>
<td style="text-align:center">可配置的</td>
</tr>
<tr>
<td style="text-align:center">Pronto</td>
<td style="text-align:center">ARM9<sup>TM</sup></td>
<td style="text-align:center">0x0/0xffff0000/硬件重映射</td>
</tr>
</tbody>
</table>
<h3 id="启动栈">启动栈</h3><table>
<thead>
<tr>
<th style="text-align:center">组件</th>
<th style="text-align:center">处理器</th>
<th style="text-align:center">加载源地址</th>
<th style="text-align:center">执行地址</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">APPS PBL</td>
<td style="text-align:center">Cortex-A53</td>
<td style="text-align:center">NA</td>
<td style="text-align:center">APPS ROM</td>
<td style="text-align:center">启动设备，检测接口，支持紧急下载，通过L2TCM加载和校验SBL1 ELF段,加载校验RPM code RAM</td>
</tr>
<tr>
<td style="text-align:center">SBL1</td>
<td style="text-align:center">Cortex-A53</td>
<td style="text-align:center">eMMC</td>
<td style="text-align:center">L2 TCM(segment1)/OCIMEM/RPM code RAM(segment2)</td>
<td style="text-align:center">初始化内存子系统（总线，DDR，时钟，CDT），加载校验TZ、Hyperviser、RPM_FW、APPSBL镜像，通过USB2.0和Sahara协议memory dump，看门狗调试retention（如：L2 flush），RAM dump到eMMC/SD卡等的支持，大容量存储支持，USB驱动支持，USB充电，温度检测，PMIC驱动的支持，配置DDR以及crash调试的flush L1/L2/ETB支持等相关配置</td>
</tr>
<tr>
<td style="text-align:center">QSEE/TZ</td>
<td style="text-align:center">Cortex-A53</td>
<td style="text-align:center">eMMC</td>
<td style="text-align:center">LPDDR2/3</td>
<td style="text-align:center">等同于TZBSP，设置运行时安全环境，配置xPU，支持fuse驱动，校验子系统镜像，丢弃RESET调试功能</td>
</tr>
<tr>
<td style="text-align:center">QHEE（Hypervisior）</td>
<td style="text-align:center">Cortex-A53</td>
<td style="text-align:center">eMMC</td>
<td style="text-align:center">LPDDR2/3</td>
<td style="text-align:center">Hypervisor镜像负责设置VMM，配置SMMU以及控制xPU存取</td>
</tr>
<tr>
<td style="text-align:center">RPM_FW</td>
<td style="text-align:center">Cortex-M3</td>
<td style="text-align:center">eMMC</td>
<td style="text-align:center">RPM code RAM</td>
<td style="text-align:center">电源资源管理</td>
</tr>
<tr>
<td style="text-align:center">APPSBL/启动管理器和系统加载器</td>
<td style="text-align:center">Cortex-A53</td>
<td style="text-align:center">eMMC</td>
<td style="text-align:center">LPDDR2/3</td>
<td style="text-align:center">启动画面，加载校验内核</td>
</tr>
<tr>
<td style="text-align:center">HLOS</td>
<td style="text-align:center">Cortex-A53</td>
<td style="text-align:center">eMMC</td>
<td style="text-align:center">LPDDR2/3</td>
<td style="text-align:center">引导HLOS镜像，例如a53 HLOS内核镜像，Pronto镜像等</td>
</tr>
<tr>
<td style="text-align:center">Modem PBL</td>
<td style="text-align:center">MSS_QDSP6</td>
<td style="text-align:center">NA</td>
<td style="text-align:center">Modem ROM Hexagon<sup>TM  TCM</sup></td>
<td style="text-align:center">设置Hexagon  TCM，从LPDDR2/3拷贝MBA到Hexagon  TCM并校验</td>
</tr>
<tr>
<td style="text-align:center">MBA</td>
<td style="text-align:center">MSS_QDSP6</td>
<td style="text-align:center">eMMC</td>
<td style="text-align:center">Hexagon TCM</td>
<td style="text-align:center">校验modem镜像，xPU为modem和memory dump保护DDR</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>eMMC</strong> ：Embeded Multi Media Card，内嵌式记忆体，内部存储<br><strong>APPS PBL</strong>：Application Processor Primary Boot Loader，应用处理器初级引导程序<br><strong>SBL1</strong>：Secondary Boot Loader Stage1，第二引导程序阶段一（此处写阶段一是因为早期高通芯片分为几个阶段，但现在都由sbl1实现）<br><strong>TZ</strong>：TrustZone<br><strong>PRM_FW</strong>：Resource Power Manager Firmware，电源资源管理固件<br><strong>HLOS</strong>：High-Level Operating System，高级操作系统<br><strong>Modem PBL</strong>：Modem Primary Boot Loader，调制解调器侧初级引导程序<br><strong>MBA</strong>：Modem Boot Authenticator，调制解调器侧引导校验程序</p>
</blockquote>
<h3 id="引导代码流程">引导代码流程</h3><p><img src="http://7xjdax.com1.z0.glb.clouddn.com/blogbootcodeflow.png" alt=""></p>
<ol>
<li><p>系统上电或者MSM8916 AP侧CPU重启。</p>
</li>
<li><p>Cortex-A53中APPS PBL执行，从启动设备中加载校验是sbl1镜像，然后跳转到sbl1中执行。</p>
</li>
<li><p>sbl1初始化ddr，从启动设备中加载校验QSEE/TZ、QHEE、RPM_FW、APPSBL镜像到DDR。</p>
</li>
<li><p>sbl1将控制权给QSEE/TZ，QSEE/TZ将设置一个安全环境，配置xPU，并支持fuse驱动。</p>
</li>
<li><p>QSEE传递控制权给QHEE，QHEE负责设置VMM，配置SMMU和xPU存取控制。</p>
</li>
<li><p>QHEE通知RPM开始执行RPM固件。</p>
</li>
<li><p>QHEE将控制器传递给HLOS APPSBL，APPSBL将初始化系统。</p>
</li>
<li><p>HLOS APPSBL加载和校验HLOS内核。</p>
</li>
<li><p>HLOS内核通过PIL.Modem加载MBA和modem镜像到DDR，然后继续启动进程。</p>
</li>
<li><p>HLOS通过PIL加载外围设备镜像Pronto到DDR，在通过TZ校验。</p>
</li>
</ol>
<h3 id="第一阶段引导程序和第二阶段引导程序">第一阶段引导程序和第二阶段引导程序</h3><p>由PBL加载的sbl1是第一阶段引导程序，APP SBL为第二阶段引导程序。这两部分代码的作用在上面<strong>启动栈</strong>和<strong>引导代码流程</strong>中已有一个简单的描述，如果想了解更多请参考我另外两篇博文：</p>
<p><a href="http://huaqianlee.me/2015/07/25/Android/Android%E6%BA%90%E7%A0%81bootable%E8%A7%A3%E6%9E%90%E4%B9%8BLK-bootloader-little-kernel/" target="_blank" rel="external">Android源码bootable解析之bootloader LK(little kernel)</a><br><a href="http://huaqianlee.me/2015/08/15/Android/%E9%AB%98%E9%80%9A%E5%B9%B3%E5%8F%B0Android%E6%BA%90%E7%A0%81bootloader%E5%88%86%E6%9E%90%E4%B9%8Bsbl1-%E4%B8%80/" target="_blank" rel="external">高通平台Android源码bootloader分析之sbl1(一)</a></p>
<h2 id="内核">内核</h2><p>Android的内核就是用的Linux的内核，只是针对移动设备做了一些优化，所有Android内核与linux内核启动的方式差不多。内核主要设置缓存、被保护存储器、计划列表，加载驱动等。当内核完成这些系统设置后，它首先在系统文件中寻找”init”文件，然后启动root进程或者系统的第一个进程。这部分可以参考我的另一篇博文：</p>
<p><a href="http://huaqianlee.me/2015/08/21/Linux/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Linux%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/" target="_blank" rel="external">深入理解linux启动过程</a></p>
<h2 id="init进程">init进程</h2><p>init进程时Android的第一个用户空间进程，是所有进程的父进程。init进程主要有两个任务，一是挂载目录，比如/sys、/dev、/proc，二是读取解析init.rc脚本，将其中的元素整理成自己的数据结构（链表）。</p>
<p>init进程实现路径： system\core\init</p>
<h3 id="init-c">init.c</h3><p>首先来看一下init进程的实现代码init.c， 其关键代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor"># system\core\init\init.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/* Get the basic filesystem setup we need put</span><br><span class="line">      * together in the initramdisk on / and then we'll</span><br><span class="line">      * let the rc file figure out the rest.</span><br><span class="line">      */</span></span><br><span class="line">    mkdir(<span class="string">"/dev"</span>, <span class="number">0755</span>);</span><br><span class="line">    mkdir(<span class="string">"/proc"</span>, <span class="number">0755</span>);</span><br><span class="line">    mkdir(<span class="string">"/sys"</span>, <span class="number">0755</span>);</span><br><span class="line"></span><br><span class="line">    mount(<span class="string">"tmpfs"</span>, <span class="string">"/dev"</span>, <span class="string">"tmpfs"</span>, MS_NOSUID, <span class="string">"mode=0755"</span>);</span><br><span class="line">    mkdir(<span class="string">"/dev/pts"</span>, <span class="number">0755</span>);</span><br><span class="line">    mkdir(<span class="string">"/dev/socket"</span>, <span class="number">0755</span>);</span><br><span class="line">    mount(<span class="string">"devpts"</span>, <span class="string">"/dev/pts"</span>, <span class="string">"devpts"</span>, <span class="number">0</span>, NULL);</span><br><span class="line">    mount(<span class="string">"proc"</span>, <span class="string">"/proc"</span>, <span class="string">"proc"</span>, <span class="number">0</span>, NULL);</span><br><span class="line">    mount(<span class="string">"sysfs"</span>, <span class="string">"/sys"</span>, <span class="string">"sysfs"</span>, <span class="number">0</span>, NULL);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    property_init(); <span class="comment">// 初始化属性服务，主要为属性文件分配存储空间</span></span><br><span class="line"></span><br><span class="line">    get_hardware_name(hardware, &amp;revision); <span class="comment">// 从虚拟文件/proc/cpuinfo中获取hardware及revision，后面init.rc中的hardware变量值从此获取</span></span><br><span class="line"></span><br><span class="line">    process_kernel_cmdline(); <span class="comment">// 导入命令行参数并用属性值设置内核变量， /proc/cmdline</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    selinux_initialize();<span class="comment">// 初始化selinux安全机制</span></span><br><span class="line"></span><br><span class="line">    init_parse_config_file(<span class="string">"/init.rc"</span>); <span class="comment">// 解析init.rc文件，主要生成action和service链表</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 解析完init.rc配置文件后，会得到一系列的Action，action_for_each_trigger函数用来将Action加入action_queue，有关init.rc、action等内容下面再分析*/</span>  </span><br><span class="line">    action_for_each_trigger(<span class="string">"early-init"</span>, action_add_queue_tail);  <span class="comment">// 添加“early-init”action</span></span><br><span class="line"></span><br><span class="line">    queue_builtin_action(wait_for_coldboot_done_action, <span class="string">"wait_for_coldboot_done"</span>);</span><br><span class="line">    queue_builtin_action(mix_hwrng_into_linux_rng_action, <span class="string">"mix_hwrng_into_linux_rng"</span>);</span><br><span class="line">    queue_builtin_action(keychord_init_action, <span class="string">"keychord_init"</span>);</span><br><span class="line">    queue_builtin_action(console_init_action, <span class="string">"console_init"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* execute all the boot actions to get us started */</span></span><br><span class="line">    action_for_each_trigger(<span class="string">"init"</span>, action_add_queue_tail); <span class="comment">// 添加“init”action</span></span><br><span class="line"></span><br><span class="line">    queue_builtin_action(mix_hwrng_into_linux_rng_action, <span class="string">"mix_hwrng_into_linux_rng"</span>);</span><br><span class="line">    queue_builtin_action(property_service_init_action, <span class="string">"property_service_init"</span>);  <span class="comment">// 启动属性服务</span></span><br><span class="line">    queue_builtin_action(signal_init_action, <span class="string">"signal_init"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Don't mount filesystems or start core system services if in charger mode. */</span></span><br><span class="line">    <span class="keyword">if</span> (is_charger) &#123;</span><br><span class="line">        action_for_each_trigger(<span class="string">"charger"</span>, action_add_queue_tail);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (is_ffbm) &#123;</span><br><span class="line">            action_for_each_trigger(<span class="string">"ffbm"</span>, action_add_queue_tail);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            action_for_each_trigger(<span class="string">"late-init"</span>, action_add_queue_tail); <span class="comment">// 添加“late-init”action</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* run all property triggers based on current state of the properties */</span></span><br><span class="line">    queue_builtin_action(queue_property_triggers_action, <span class="string">"queue_property_triggers"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(;;) &#123; <span class="comment">// 无限循环，建立init子进程</span></span><br><span class="line">        ...</span><br><span class="line">        execute_one_command(); <span class="comment">// 执行节点command，zygote service也在此启动，稍后再详细分析</span></span><br><span class="line">        restart_processes(); <span class="comment">// 重启进程</span></span><br><span class="line">        </span><br><span class="line">        <span class="preprocessor"># 监听属性服务事件</span></span><br><span class="line">        ufds[fd_count].fd = get_property_set_fd();</span><br><span class="line">        ufds[fd_count].events = POLLIN; <span class="comment">// 属性事件</span></span><br><span class="line"></span><br><span class="line">        ufds[fd_count].fd = get_signal_fd();</span><br><span class="line">        ufds[fd_count].events = POLLIN;  <span class="comment">// 子进程事件</span></span><br><span class="line"></span><br><span class="line">        ufds[fd_count].fd = get_keychord_fd();</span><br><span class="line">        ufds[fd_count].events = POLLIN; <span class="comment">// keychord热键事件</span></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> BOOTCHART</span></span><br><span class="line">      <span class="comment">// bootchart是一个性能统计工具，用于搜集硬件和系统的信息，并将其写入磁盘，以便其他程序使用</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">        nr = poll(ufds, fd_count, timeout); <span class="comment">// 等待下一个命令提交</span></span><br><span class="line">        <span class="preprocessor"># 处理具体消息</span></span><br><span class="line">        handle_property_set_fd(); <span class="comment">// 处理属性命令</span></span><br><span class="line">        handle_keychord(); <span class="comment">// adb使能时处理keychord</span></span><br><span class="line">        handle_signal(); <span class="comment">// 处理子进程挂掉发来的信号，service重启</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="init-rc">init.rc</h3><h4 id="-rc文件的语法">.rc文件的语法</h4><p>init.rc文件是Android的有特定格式和规则的脚本文件，位于：system\core\rootdir\init.rc，称为Android的初始化语言。当进入adb shell后，我们能在根目录看到一个只读的虚拟内存文件init.rc，源文件init.rc被打包在boot.img中ramdisk.img中。其有四类声明：</p>
<ol>
<li>Action - 动作</li>
<li>Command - 命令</li>
<li>Service - 服务</li>
<li>Option - 选项</li>
</ol>
<p>该语言规定，Action和Service是以一种“小节”（Section）的形式出现的，其中每个Action小节可以含有若干Command，而每个Service小节可以含有若干Option。小节只有起始标记，却没有明确的结束标记，也就是说，是用“后一个小节”的起始来结束“前一个小节”的。</p>
<p>脚本中的Action大体上表示一个“动作”，它用一系列Command共同完成该“动作”。Action需要有一个触发器（trigger）来触发它，一旦满足了触发条件，这个Action就会被加到执行队列的末尾。Action的形式如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">on  &lt;trigger&gt;</span><br><span class="line"> &lt;<span class="built_in">command</span>1&gt;</span><br><span class="line"> &lt;<span class="built_in">command</span>2&gt;</span><br><span class="line"> ......</span><br></pre></td></tr></table></figure></p>
<p>Service表示一个服务程序，会在初始化时启动，当服务退出时init进程会视情况重启服务。因为init.rc脚本中描述的服务往往都是核心服务，所以（基本上所有的）服务会在退出时自动重启。Service的形式如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">service &lt;name&gt; &lt;pathname&gt; [&lt;arguments&gt;]*</span><br><span class="line"> &lt;option&gt;</span><br><span class="line"> &lt;option&gt;</span><br><span class="line">  ......</span><br></pre></td></tr></table></figure></p>
<p>其实，除了Action和Service，init.rc中还有一种小节：import小节。该小节类似java中的import或者c中的头文件，导入其他.rc脚本文件。如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import /init.environ.rc</span><br><span class="line">import /init.usb.rc</span><br><span class="line">import /init.<span class="variable">$&#123;ro.hardware&#125;</span>.rc</span><br><span class="line">import /init.trace.rc</span><br></pre></td></tr></table></figure></p>
<h4 id="init-rc-1">init.rc</h4><p>init.rc脚本的主要内容如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># system\core\rootdir\init.rc</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入相关.rc文件</span></span><br><span class="line">import /init.environ.rc</span><br><span class="line">import /init.usb.rc</span><br><span class="line">import /init.<span class="variable">$&#123;ro.hardware&#125;</span>.rc <span class="comment"># hardware变量的值在上面讲的main函数中获取</span></span><br><span class="line">import /init.<span class="variable">$&#123;ro.zygote&#125;</span>.rc <span class="comment">#导入zygote服务.rc脚本文件</span></span><br><span class="line">import /init.trace.rc</span><br><span class="line">import /init.ideanfc.preinstall.rc</span><br><span class="line"></span><br><span class="line">on early-init <span class="comment"># 设置init进程以及它创建的子进程的优先级，设置init进程的安全环境</span></span><br><span class="line">on init <span class="comment"># 设置全局环境，为cpu accounting创建cgroup(资源控制)挂载点</span></span><br><span class="line">...</span><br><span class="line"><span class="comment"># Load properties from /system/ + /factory after fs mount.</span></span><br><span class="line">on load_all_props_action</span><br><span class="line">    load_all_props</span><br><span class="line"></span><br><span class="line">on late-init</span><br><span class="line">    trigger early-fs <span class="comment"># 触发early-fs动作</span></span><br><span class="line">    trigger fs <span class="comment"># 触发fs动作，挂载mtd分区</span></span><br><span class="line">    trigger post-fs</span><br><span class="line">    trigger post-fs-data</span><br><span class="line">    trigger load_all_props_action</span><br><span class="line">    ...</span><br><span class="line">    trigger early-boot</span><br><span class="line">    trigger boot</span><br><span class="line"></span><br><span class="line">on post-fs <span class="comment"># 改变系统目录的访问权限</span></span><br><span class="line">on post-fs-data <span class="comment"># 改变/data目录以及它的子目录的访问权限</span></span><br><span class="line">on boot <span class="comment"># 初始化基本网络、内存管理等</span></span><br><span class="line">    ...</span><br><span class="line">    chown radio system /sys/power/wake_lock // 修改文件用户组</span><br><span class="line">    chown radio system /sys/power/wake_unlock</span><br><span class="line">    chmod <span class="number">0660</span> /sys/power/wake_lock // 修改文件操作权限</span><br><span class="line">    chmod <span class="number">0660</span> /sys/power/wake_unlock</span><br><span class="line">    ...</span><br><span class="line">    class_start core <span class="comment"># 开启核心服务</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">service healthd /sbin/healthd <span class="comment"># 电源管理服务</span></span><br><span class="line">service servicemanager /system/bin/servicemanager <span class="comment"># 系统服务管理器，管理所有的本地服务，比如位置、音频、Shared preference等等</span></span><br><span class="line">    class core  <span class="comment"># 声明为core核心服务</span></span><br><span class="line">    user system</span><br><span class="line">    group system</span><br><span class="line">    critical</span><br><span class="line">    onrestart restart healthd <span class="comment">#重启电池管理服务</span></span><br><span class="line">    onrestart restart zygote <span class="comment"># 重启zygote服务作为应用进程, 定义在文件头import的zygote.rc脚本中</span></span><br><span class="line">    onrestart restart media <span class="comment"># 重启音频服务</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>servicemanager主要注册获取服务，源码路径：frameworks\base\cmds\servicemanager\Service_manager.c。</p>
</blockquote>
<h4 id="回调函数">回调函数</h4><p>Action包含的不同command对应不同func回调函数，具体对应情况可查看Keywords.h，如下：<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor"># system\core\init\keywords.h</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_chroot</span><span class="params">(<span class="keyword">int</span> nargs, <span class="keyword">char</span> **args)</span></span>; <span class="comment">//对应于KEYWORD最后一个参数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_chdir</span><span class="params">(<span class="keyword">int</span> nargs, <span class="keyword">char</span> **args)</span></span>;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_write</span><span class="params">(<span class="keyword">int</span> nargs, <span class="keyword">char</span> **args)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_copy</span><span class="params">(<span class="keyword">int</span> nargs, <span class="keyword">char</span> **args)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_chown</span><span class="params">(<span class="keyword">int</span> nargs, <span class="keyword">char</span> **args)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_chmod</span><span class="params">(<span class="keyword">int</span> nargs, <span class="keyword">char</span> **args)</span></span>;</span><br><span class="line">...</span><br><span class="line">KEYWORD(capability,  OPTION,  <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">KEYWORD(chdir,       COMMAND, <span class="number">1</span>, do_chdir)</span><br><span class="line">KEYWORD(chroot,      COMMAND, <span class="number">1</span>, do_chroot)</span><br><span class="line">KEYWORD(<span class="keyword">class</span>,       OPTION,  <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">KEYWORD(class_start, COMMAND, <span class="number">1</span>, do_class_start)</span><br><span class="line">KEYWORD(class_stop,  COMMAND, <span class="number">1</span>, do_class_stop)</span><br><span class="line">KEYWORD(class_reset, COMMAND, <span class="number">1</span>, do_class_reset)</span><br><span class="line">KEYWORD(console,     OPTION,  <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">...</span><br><span class="line">KEYWORD(user,        OPTION,  <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">KEYWORD(wait,        COMMAND, <span class="number">1</span>, do_wait)</span><br><span class="line">KEYWORD(write,       COMMAND, <span class="number">2</span>, do_write)</span><br><span class="line">KEYWORD(copy,        COMMAND, <span class="number">2</span>, do_copy)</span><br><span class="line">KEYWORD(chown,       COMMAND, <span class="number">2</span>, do_chown)</span><br><span class="line">KEYWORD(chmod,       COMMAND, <span class="number">2</span>, do_chmod)</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<h4 id="init-rc脚本文件的解析">init.rc脚本文件的解析</h4><p>关于init.rc脚本文件的解析，就不详细描述了，只列出关键文件和关键函数，如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor"># system\core\init\init.c</span></span><br><span class="line">init_parse_config_file(<span class="string">"/init.rc"</span>); <span class="comment">// 解析init.rc文件</span></span><br><span class="line">  data = read_file(fn, <span class="number">0</span>);</span><br><span class="line">  parse_config(fn, data); <span class="comment">// 真正的解析函数</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor"># system\core\init\init_parser.c ，被parse_config调用</span></span><br><span class="line">lookup_keyword() <span class="comment">//查找关键字</span></span><br><span class="line">kw_is() <span class="comment">// 一个宏，查表lookup_keyword返回关键字，对应上keywords.h中的KEYWORD</span></span><br><span class="line">parse_new_section() <span class="comment">// section起始行，解析service、on小节，import小节汇成一个链表</span></span><br><span class="line">state.parse_line() <span class="comment">// 从属于section的子行</span></span><br><span class="line">init_parse_config_file(import-&gt;filename) <span class="comment">//解析import小节</span></span><br></pre></td></tr></table></figure></p>
<h4 id="core服务和main服务">core服务和main服务</h4><p>boot子阶段会通过class_start对应的回调函数do_class_start开启core服务和main服务，这两类服务通过如下两句表明身份：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class core # &#22768;&#26126;section&#20026;core&#26381;&#21153;&#10;class main # &#22768;&#26126;section&#20026;main&#26381;&#21153;</span><br></pre></td></tr></table></figure></p>
<h5 id="core服务">core服务</h5><table>
<thead>
<tr>
<th style="text-align:center">core类型的服务</th>
<th style="text-align:center">对应的可执行文件</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">ueventd</td>
<td style="text-align:center">/sbin/ueventd</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">logd</td>
<td style="text-align:center">/system/bin/logd</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">healthd</td>
<td style="text-align:center">/sbin/healthd</td>
<td style="text-align:center">电源管理服务</td>
</tr>
<tr>
<td style="text-align:center">console</td>
<td style="text-align:center">/system/bin/sh</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">adbd</td>
<td style="text-align:center">/sbin/adbd</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">servicemanager</td>
<td style="text-align:center">/system/bin/servicemanager</td>
<td style="text-align:center">service manager service服务，Android的核心之一，zygote在此服务中加载</td>
</tr>
<tr>
<td style="text-align:center">vold</td>
<td style="text-align:center">/system/bin/vold</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<h5 id="main服务">main服务</h5><table>
<thead>
<tr>
<th style="text-align:center">main类型的服务</th>
<th style="text-align:center">对应的可执行文件</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">netd</td>
<td style="text-align:center">/system/bin/netd</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">debuggerd</td>
<td style="text-align:center">/system/bin/debuggerd</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">ril-daemon</td>
<td style="text-align:center">/system/bin/rild</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">surfaceflinger</td>
<td style="text-align:center">/system/bin/surfaceflinger</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">zygote</td>
<td style="text-align:center">/system/bin/app_process</td>
<td style="text-align:center">Android创建内部创建新进程的核心服务</td>
</tr>
<tr>
<td style="text-align:center">drm</td>
<td style="text-align:center">/system/bin/drmserver</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">media</td>
<td style="text-align:center">/system/bin/mediaserver</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">bootanim</td>
<td style="text-align:center">/system/bin/bootanimation</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">installd</td>
<td style="text-align:center">/system/bin/installd</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">flash_recovery</td>
<td style="text-align:center">/system/etc/install-recovery.sh</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">racoon</td>
<td style="text-align:center">/system/bin/racoon</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">mtpd</td>
<td style="text-align:center">/system/bin/mtpd</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">keystore</td>
<td style="text-align:center">/system/bin/keystore</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">dumpstate</td>
<td style="text-align:center">/system/bin/dumpstate</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">sshd</td>
<td style="text-align:center">/system/bin/start-ssh</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">mdnsd</td>
<td style="text-align:center">/system/bin/mdnsd</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<h2 id="属性服务">属性服务</h2><p>众所周知在windows中有一个注册表机制，在注册表中提供了大量的key-value属性。在Android(或Linux)中也有类似的机制：属性服务（property service）。init在启动的过程中会启动属性服务（Socket服务），并且在内存中建立一块存储区域，用来存储这些属性。当读取这些属性时，直接从这一内存区域读取，如果修改属性值，需要通过Socket连接属性服务完成。在init.c文件中main函数通过property_service_init_action调用了start_property_service函数来启动属性服务。</p>
<p>属性文件是由系统依次读取位于不同目录的配置文件，关于属性文件的解析也涉及到很多内容，这里就不去详细分析了，关键函数和路径如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># system\core\init\property_service.c</span></span><br><span class="line">void start_property_service(void)</span><br><span class="line">const char* property_get(const char *name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># bionic/libc/bionic/system_properties.c</span></span><br><span class="line">const prop_info *__system_property_find(const char *name)</span><br><span class="line">static int init_property_area(void)</span><br><span class="line">static int send_prop_msg(prop_msg *msg)</span><br><span class="line">int __system_property_<span class="built_in">set</span>(const char *key, const char *value)</span><br><span class="line"></span><br><span class="line"><span class="comment"># bionic\libc\include\sys\_system_properties.h ,定义了相关属性文件</span></span><br><span class="line"><span class="comment">#define PROP_PATH_RAMDISK_DEFAULT  "/default.prop"</span></span><br><span class="line"><span class="comment">#define PROP_PATH_SYSTEM_BUILD     "/system/build.prop"</span></span><br><span class="line"><span class="comment">#define PROP_PATH_SYSTEM_DEFAULT   "/system/default.prop"</span></span><br><span class="line"><span class="comment">#define PROP_PATH_VENDOR_BUILD     "/vendor/build.prop"</span></span><br><span class="line"><span class="comment">#define PROP_PATH_LOCAL_OVERRIDE   "/data/local.prop"</span></span><br><span class="line"><span class="comment">#define PROP_PATH_FACTORY          "/factory/factory.prop"</span></span><br></pre></td></tr></table></figure></p>
<p>另，我们可以在adb shell中通过getprop获取所有属性名，或者通过getprop &lt; 根属性名&gt;获取具体属性值，如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取所有属性值</span></span><br><span class="line">C:\Users\Administrator&gt;adb shell</span><br><span class="line">shell@msm8916_32:/ $ getprop</span><br><span class="line">getprop</span><br><span class="line">[DEVICE_PROVISIONED]: [<span class="number">1</span>]</span><br><span class="line">[audio.dolby.ds2.enabled]: [<span class="literal">true</span>]</span><br><span class="line">[audio.offload.buffer.size.kb]: [<span class="number">64</span>]</span><br><span class="line">[audio.offload.gapless.enabled]: [<span class="literal">true</span>]</span><br><span class="line">[audio.offload.min.duration.secs]: [<span class="number">30</span>]</span><br><span class="line">[av.offload.enable]: [<span class="literal">true</span>]</span><br><span class="line">[bluetooth.hfp.client]: [<span class="number">1</span>]</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取指定属性具体属性值</span></span><br><span class="line">shell@msm8916_32:/ $ getprop ro.build.product</span><br><span class="line">getprop ro.build.product</span><br><span class="line">msm8916_32</span><br></pre></td></tr></table></figure></p>
<h2 id="Zygote">Zygote</h2><p>Zygote是Android中非常重要十分核心的一个服务，将由其去运行系统服务及孵化Activity进程等，接下来就好好分析一下Zygote。</p>
<p>在Java中，不同的虚拟机实例会为不同的应用分配不同的内存，每一个实例都有它自己的核心库类文件和堆对象的拷贝。但Android系统如果为每一个应用启动不同的Dalvik虚拟机实例，就会消耗大量的内存以及时间。因此，为了克服这个问题，Android系统创造了”Zygote”。Zygote让Dalvik虚拟机共享代码、低内存占用以及最小的启动时间成为可能。Zygote是一个虚拟器进程，在系统引导的时候启动。Zygote预加载以及初始化核心库类。通常，这些核心类是只读的，也是Android SDK或者核心框架的一部分。</p>
<h3 id="Zygote的启动">Zygote的启动</h3><p>首先，先看一下Zygote在相关zygote.rc文件中的定义：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">service zygote /system/bin/app_process -Xzygote /system/bin --zygote --start-system-server <span class="comment"># 此处定义了启动zygote时会启动那些进程</span></span><br><span class="line">    class main</span><br><span class="line">    socket zygote stream <span class="number">660</span> root system</span><br><span class="line">    onrestart write /sys/android_power/request_state wake</span><br><span class="line">    onrestart write /sys/power/state on</span><br><span class="line">    onrestart restart media</span><br><span class="line">    onrestart restart netd</span><br></pre></td></tr></table></figure></p>
<p>当init.c中解析了rc文件后，rc文件中定义class_start命令对应do_class_start函数将启动服务(包括Zygote)进程，关键源码如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># system\core\init\builtins.c</span></span><br><span class="line">int <span class="keyword">do</span>_class_start(int nargs, char **args)</span><br><span class="line">&#123;</span><br><span class="line">        /* Starting a class does not start services</span><br><span class="line">         * <span class="built_in">which</span> are explicitly disabled.  They must</span><br><span class="line">         * be started individually.</span><br><span class="line">         */</span><br><span class="line">    service_<span class="keyword">for</span>_each_class(args[<span class="number">1</span>], service_start_<span class="keyword">if</span>_not_disabled); // 从service_list链表找到class_name和参数一致的，然后调用service_start_<span class="keyword">if</span>_not_disabled启动服务</span><br><span class="line">    <span class="built_in">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void service_start_<span class="keyword">if</span>_not_disabled(struct service *svc)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(svc-&gt;flags &amp; SVC_DISABLED)) &#123;</span><br><span class="line">        service_start(svc, NULL);  //启动服务</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        svc-&gt;flags |= SVC_DISABLED_START;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># system\core\init\init.c</span></span><br><span class="line">void service_start(struct service *svc, const char *dynamic_args)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    /* 检查需要开启进程的可执行文件是否存在，如：Zygote路径/system/bin/app_process */</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">stat</span>(svc-&gt;args[<span class="number">0</span>], &amp;s) != <span class="number">0</span>) &#123;</span><br><span class="line">        ERROR(<span class="string">"cannot find '%s', disabling '%s'\n"</span>, svc-&gt;args[<span class="number">0</span>], svc-&gt;name);</span><br><span class="line">        svc-&gt;flags |= SVC_DISABLED;</span><br><span class="line">        <span class="built_in">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    pid = fork(); // 创建子进程，父进程为init创建的service进程</span><br><span class="line">    ...</span><br><span class="line">    execve(svc-&gt;args[<span class="number">0</span>], (char**) arg_ptrs, (char**) ENV); // 执行进程，如/system/bin/app_process</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (properties_inited())</span><br><span class="line">        notify_service_state(svc-&gt;name, <span class="string">"running"</span>); // 设置服务为running状态</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>经过上述流程，app_proces等进程就被启动起来了就进入到app_process相关code了，如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor"># frameworks\base\cmds\app_process\app_main.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* <span class="keyword">const</span> argv[])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function">AppRuntime <span class="title">runtime</span><span class="params">(argv[0], computeArgBlockSize(argc, argv)</span>)</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (zygote) &#123;</span><br><span class="line">        runtime.start(<span class="string">"com.android.internal.os.ZygoteInit"</span>, args);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor"># frameworks\base\core\jni\AndroidRuntime.cpp</span></span><br><span class="line"><span class="comment">/* 开始Android运行， 打开虚拟机，调用"static void main(String[] args)"*/</span></span><br><span class="line"><span class="keyword">void</span> AndroidRuntime::start(<span class="keyword">const</span> <span class="keyword">char</span>* className, <span class="keyword">const</span> Vector&lt;String8&gt;&amp; options)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/* start the virtual machine */</span></span><br><span class="line">    JniInvocation jni_invocation;</span><br><span class="line">    jni_invocation.Init(NULL);</span><br><span class="line">    JNIEnv* env;</span><br><span class="line">    <span class="keyword">if</span> (startVm(&amp;mJavaVM, &amp;env) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    onVmCreated(env);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/*</span><br><span class="line">     * Register android functions.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">if</span> (startReg(env) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"Unable to register all android natives\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/*</span><br><span class="line">     * Start VM.  This thread becomes the main thread of the VM, and will</span><br><span class="line">     * not return until the VM exits.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">char</span>* slashClassName = toSlashClassName(className);</span><br><span class="line">    jclass startClass = env-&gt;FindClass(slashClassName);</span><br><span class="line">    jmethodID startMeth = env-&gt;GetStaticMethodID(startClass, <span class="string">"main"</span>,<span class="string">"([Ljava/lang/String;)V"</span>); <span class="comment">//获取静态main方法</span></span><br><span class="line">    env-&gt;CallStaticVoidMethod(startClass, startMeth, strArray); <span class="comment">// 调用main方法</span></span><br></pre></td></tr></table></figure></p>
<p>这样就真正进入了Zygote进程了，如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># frameworks\base\core\java\com\android\internal\os\ZygoteInit.java</span></span><br><span class="line">public static void main(String argv[]) &#123;</span><br><span class="line">    // Start profiling the zygote initialization.</span><br><span class="line">   SamplingProfilerIntegration.start();</span><br><span class="line">   ...</span><br><span class="line">    registerZygoteSocket(socketName);  // 为Zygote注册服务器套接字（server socket）</span><br><span class="line">    ...</span><br><span class="line">    preload(); // 调用preloadClassed()：加载一系列类的文本文件（“preloaded-classes”），位于/frameworks/base</span><br><span class="line">                       调用preloadResources():  加载本地主题、布局以及android.R文件中包含的所有东西</span><br><span class="line">    ...</span><br><span class="line">    startSystemServer(abiList, socketName); // 准备参数，通过Zygote孵化新 system server 进程</span><br><span class="line">    runSelectLoop(abiList); // 运行Zygote进程选中的loop，此函数中不断接受新的connections，并读取<span class="built_in">command</span>执行</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></p>
<p>到了这个阶段，就可以看到启动动画了。前面分析了Zygote的流程，可以总结为如下一张图：<br><img src="http://7xjdax.com1.z0.glb.clouddn.com/blogZygote.jpg" alt="from internet"></p>
<p>在rc文件中有通过onrestart定义需要重启的动作或服务，这块就不去详细分析了，只将重启流程中的关键函数和路径列出：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># system\core\init\init.c</span></span><br><span class="line">queue_<span class="built_in">builtin</span>_action(signal_init_action, <span class="string">"signal_init"</span>); //main函数中</span><br><span class="line">static int signal_init_action(int nargs, char **args) //此函数调用singal_init</span><br><span class="line"></span><br><span class="line"><span class="comment"># system\core\init\signal_handler.c</span></span><br><span class="line">void signal_init(void)</span><br><span class="line">static void sigchld_handler(int s)</span><br><span class="line">int get_signal_fd()</span><br><span class="line">void handle_signal(void)</span><br><span class="line">static int <span class="built_in">wait</span>_<span class="keyword">for</span>_one_process(int block) // 此函数中将发出restarting信号，然后init.c中的main函数收到此信号后将重启相应进程</span><br></pre></td></tr></table></figure></p>
<h2 id="Home_Lanucher启动">Home Lanucher启动</h2><p>上ZygoteInit.java中mian函数在loop之前会调用一个关键函数startSystemServer，其除了准备一些参数外还将fork进程。其中就包括SystemServer，在SystemServer中最终会调用到ActivityManagerService，然后Home Lanucher就由ActivityManagerService中的方法来启动。关键源码和路径如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># frameworks\base\services\java\com\android\server\SystemServer.java</span></span><br><span class="line"><span class="comment"># frameworks\base\services\core\java\com\android\server\am\ActivityManagerService.java</span></span><br><span class="line">public void systemReady(final Runnable goingCallback) &#123;</span><br><span class="line">     // Start up initial activity.</span><br><span class="line">     mBooting = <span class="literal">true</span>;</span><br><span class="line">     startHomeActivityLocked(mCurrentUserId, <span class="string">"systemReady"</span>);</span><br><span class="line">&#125;</span><br><span class="line">boolean startHomeActivityLocked(int userId, String reason) &#123;</span><br><span class="line">    <span class="built_in">set</span>DefaultLauncher(); // 第一次开机时设置</span><br><span class="line">    mStackSupervisor.startHomeActivity(intent, aInfo, reason); // 开启homeActivity</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>花了这么长的时间，终于把这个流程走完了。 不过还是有很多地方偷懒了，没有详细研究，只了解了一个大概，然后做了记录。如有错误请谅解！</p>
<h2 id="Reference">Reference</h2><p>在我分析启动流程时，主要参考引用了如下地址，后3篇博文对init.c和init.rc分析得十分详细，感兴趣可以参考一下这几篇博文。<br><a href="http://developer.android.com/index.html" target="_blank" rel="external">Android官网</a><br><a href="http://android.jobbole.com/67931/" target="_blank" rel="external">Android设备启动流程</a><br><a href="http://my.oschina.net/youranhongcha/blog/469028" target="_blank" rel="external">Android 4.4的init进程</a><br><a href="http://blog.csdn.net/hu3167343/article/details/38299969" target="_blank" rel="external">Android情景分析之详解init进程</a><br><a href="http://www.cnblogs.com/nokiaguy/archive/2013/04/14/3020774.html" target="_blank" rel="external">Androidinit过程详解</a></p>
<blockquote>
<p>本文边分析边记录而成，由于时间原因，很多地方没有详细分析，简单看了一下就跳过。可能会有很多描述不清楚甚至错误的地方，欢迎指出，共同学习，共同进步。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p><em>Platform Information :<br>　System:    Ａndroid5.1<br>　Platform:  Qualcomm msm8916<br>　Author:     Andy Lee<br>　Email:        huaqianlee@gmail.com</em></p>
<p><strong>如有错误欢迎指出，共同学习，共同进步</strong><br>　<br>在我第一次接触Android得时候，我就很想知道Android设备在按下电源键后是怎么启动到主界面的，但是到现在为止也没有完全理清这个过程，所以就决定从按下power键开始来分析一下这个流程。虽然Android基于Linux内核开发的一个操作系统，但是在init进程后Android附加了很多其他操作，所以其启动流程还是有比较大的差别的，关于Linux系统的启动流程可以参考我的另一篇博文：<a href="http://huaqianlee.me/2015/08/21/Linux/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Linux%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/">深入理解linux启动过程</a>。</p>
<p>因为我现在工作中用到的是高通的源码，并且高通也是目前Android手机的主流芯片，所以我就按照高通的msm8916来分析了，不过其他的也应该大同小异。<br>　<br>首先来看一下官方给出的Android系统架构：<br>]]>
    
    </summary>
    
      <category term="Qualcomm" scheme="http://huaqianlee.me/tags/Qualcomm/"/>
    
      <category term="源码分析" scheme="http://huaqianlee.me/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="Android" scheme="http://huaqianlee.me/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入理解Linux启动过程(译)]]></title>
    <link href="http://huaqianlee.me/2015/08/21/Linux/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Linux%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/"/>
    <id>http://huaqianlee.me/2015/08/21/Linux/深入理解Linux启动过程/</id>
    <published>2015-08-21T13:23:41.000Z</published>
    <updated>2015-08-22T16:02:35.317Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p><strong>第一篇完全译文，因为自己对技术和英文的热爱，所以决定翻译此文，水平有限，所以肯定会有不恰当的地方，欢迎移驾至原地址：<a href="http://www.ibm.com/developerworks/linux/library/l-linuxboot/" target="_blank" rel="external">http://www.ibm.com/developerworks/linux/library/l-linuxboot/</a></strong><br>注：因为想写一篇博文来阐述并理清Android启动的完全过程，发现了这篇文章，觉得写得十分好，帮我解答了很多疑惑。</p>
</blockquote>
<h2 id="引言">引言</h2><p>Linux系统的启动过程由很多阶段组成，但是无论你是启动标准的x86桌面还是启动嵌入式PowerPC目标，许多流程都是惊人的相似的。这篇文章从初始化引导程序到第一个用户空间应用程序探索Linux启动进程。顺着这个流程，你将知道很多和启动相关的主题，比如：引导程序，内核解压, 初始RAM磁盘,以及其他Linux引导元素。<br><a id="more"></a><br>早期，引导计算机启动需要插入一条带有引导程序的纸带或者手动控制带有地址/数据/控制开关的面板加载启动程序。今天的计算机<br>装备了简化启动进程的工具，不过并不一定使这个过程变得简单了。</p>
<p>我们先从Linux启动的顶层视图开始分析，以便你能有一个整体的认识。然后我们将回顾每一个分离的步骤。顺着这个流程的源码引用将帮助你浏览内核树结构，以便在以后深入分析。</p>
<h2 id="概述">概述</h2><p>图一将为你展示两万英里的视图。</p>
<p><strong>Figure 1. The 20,000-foot view of the Linux boot process</strong><br><img src="http://7xjdax.com1.z0.glb.clouddn.com/blogfigure1.gif" alt="Figure 1"></p>
<p>当系统第一次启动或重启时，处理器将执行一个已知地方的代码。对应个人电脑，这个地方是存在主板上内存内的BIOS；对于嵌入式系统中的cpu，将会加载引导区去启动flash/ROM中已知地址的程序。无论怎样，结果是相同的。个人电脑提供了很多灵和性，BIOS必须觉得哪些设备是候补准备启动，稍后再详细讲。</p>
<p>当一个启动设备被发现，第一阶段引导程序被加载到RAM并执行。这一部分引导程序最大为512字节（1单位扇区大小），他的作用是去加载第二阶段引导程序。</p>
<p>当第二阶段引导程序被加载进RAM并执行，启动界面将被显示，并且Linux和可选的初始磁盘（临时文件系统）被加载进内存。当镜像被加载以后，控制权从第二阶段引导程序传递到内核镜像，内核镜像先自解压和初始化。在这一步，第二阶段引导程序将检查系统硬件，枚举硬件设备，挂载主设备，加载必须的内核模块。当这些完成时，用户空间的第一个程序(init)开始执行，这样就开始顶层系统初始化开始了。</p>
<p>上面这些是Linux启动的一个外壳，接下来我们开始更深层次的探索启动进程的细节。</p>
<h2 id="系统启动">系统启动</h2><p>系统启动依赖于引导Linux的硬件。在嵌入式平台，系统在启动或重启时会用到引导程序环境变量，比如：包括u-boot，redboot及lucent公司的MicroMonitor。嵌入式平台通常附带一个引导监视器。这些程序位于目标硬件的flash内存中一个特别的区域，为Linux内核镜像加载到flash内存提供方法，并在随后执行Linux内核。除了存储和启动Linux镜像外，引导监视器还会执行一些系统测试及硬件初始化。在一个嵌入式目标，引导监视器通常存在于第一步及第二步引导程序。</p>
<p>对于个人计算机，Linux从0xffff0地址的BIOS开始启动。BIOS的第一步是上电自检（POST）。上电自检的工作是检查硬件。BIOS的第二步是枚举和初始化本地设备。</p>
<p>鉴于BIOS的不同用途，BIOS主要由两部分组成：上电自检代码和运行服务。在上电自检完成后，上电自检代码从内存被清除，但是运行服务被保留并且对目标操作系统仍然有效。</p>
<p>要引导一个操作系统，BIOS运行时会按照CMOS的设置定义的顺序来搜索处于活动状态并且可以引导的设备。引导设备可以为软盘，CD-ROM，硬盘的分区，网络上的设备以及U盘。</p>
<p>Linux一般从MBR包含初级引导程序的硬盘启动。MBR是一个512字节的扇区，位于硬盘的第一扇区（0道0柱1扇区）。在MBR被加载到RAM中后，由BIOS去控制它。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">提取MBR（主引导记录）</span><br><span class="line"></span><br><span class="line">可以通过如下命令查看你的MBR：</span><br><span class="line"><span class="comment"># dd if=/dev/hda of=mbr.bin bs=512 count=1</span></span><br><span class="line"><span class="comment"># od -xa mbr.bin</span></span><br><span class="line"></span><br><span class="line">dd命令：需要root权限，从/dev/hda（第一个集成驱动电路或IDE驱动器）中读取<span class="number">512</span>字节内容并写到mbr.bin文件。</span><br><span class="line">od命令：以hex和ASCII格式打印二进制文件</span><br></pre></td></tr></table></figure></p>
<h2 id="第一阶段引导程序">第一阶段引导程序</h2><p>初级引导程序位于512字节的MBR镜像，MBR镜像由一个小型分区表和代码组成（见Figure 2）。前446字节是初级引导程序代码，包括执行代码和错误信息。接下来的64字节是一个分区表，包含4个16字节的分区记录。MBR最后的两字节定义了一个magic数字（0xaa55）。这个magic数字用来校验检查MBR。</p>
<p><strong>Figure 2. Anatomy of the MBR</strong><br><img src="http://7xjdax.com1.z0.glb.clouddn.com/blogfigure2.gif" alt="Figure 2"></p>
<p>初级引导程序主要就是找到并且加载第二阶段引导程序。其通过分区表寻找一个活动的分区。在找到一个活动的分区表后，其将扫描剩余的分区确定它们不是活动的。当这些被确定后，活动分区的启动启动记录将从设备加载到RAM并且执行。</p>
<h2 id="第二阶段引导程序">第二阶段引导程序</h2><p>第二阶段引导程序其实叫着内核引导程序更加合适。因为其任务就是加载Linux内核和可选的初始磁盘。</p>
<p>在x86环境中，第一阶段和第二阶段引导程序结合一起叫着Linux引导程序（LILO）或者 GRand Unified Bootloader（GRUB）。因为LILO有一些在GRUB中已经被纠正的缺点，所有我们就分析GRUB。（如果想了解更多关于GRUB，LILO和相关主题的信息，请看文章最后的Resources）</p>
<p>GRUB最伟大的是其包含已知的所有Linux文件系统。GRUB不像LILO一样使用裸扇区，而能从ext2和ext3文件系统中加载Linux内核。它通过将两阶段的引导程序转换为三阶段的引导程序来实现此功能。第一阶段（MBR）启动能识别Linux内核镜像中包含的特殊文件系统的第1.5阶段引导程序。比如reiserfs_stage1_5（从Reiser日志文件系统加载） 或者 e2fs_stage1_5（从ext2或者ext3文件系统加载）。当第1.5阶段引导程序被加载并运行后，第2阶段引导程序就能被加载了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CRUB阶段引导程序</span><br><span class="line"></span><br><span class="line">/boot/grup路径包括第<span class="number">1</span>阶段，第<span class="number">1.5</span>阶段，以及第<span class="number">2</span>阶段引导程序，以及一些交替引导程序（如：CR-ROMs 使用iso9660_stage_1_5）</span><br></pre></td></tr></table></figure>
<p>随着第二阶段被加载，CRUB会根据需求显示一个可用的内核列表（定义在/etc/grub.con，以及/etc/grub/menu.lst和/etc/grub.conf的软连接）。你可以选中一个内核，并且可以用附加的内核参数改进它。另外，你还能通过shell终端命令行的方式手动控制整个启动过程。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">GRUB中手动启动</span><br><span class="line"></span><br><span class="line">通过grub命令行，你可以用initrd镜像启动一个指定的内核，如下：</span><br><span class="line">grub&gt; kernel /bzImage-<span class="number">2.6</span>.<span class="number">14.2</span></span><br><span class="line">  [Linux-bzImage, setup=<span class="number">0</span>x1400, size=<span class="number">0</span>x29672e]</span><br><span class="line"></span><br><span class="line">grub&gt; initrd /initrd-<span class="number">2.6</span>.<span class="number">14.2</span>.img</span><br><span class="line">  [Linux-initrd @ <span class="number">0</span>x5f13000, <span class="number">0</span>xcc199 bytes]</span><br><span class="line"></span><br><span class="line">grub&gt; boot</span><br><span class="line"></span><br><span class="line">Uncompressing Linux... Ok, booting the kernel.</span><br><span class="line"></span><br><span class="line">如果你不知道需要启动的内核名字，只需要敲一个斜杠（<span class="string">"/"</span>）并按Tab键。GRUB将显示内核镜像和initrd镜像列表。</span><br></pre></td></tr></table></figure>
<p>第二阶段引导程序被加载进内存后，将查询文件系统，加载默认内核镜像和initrd镜像到内存。当所有镜像准备好后，将从第二阶段跳转到内核镜像。</p>
<h2 id="内核">内核</h2><p>随着内核镜像加载到内存并且从第二阶段引导程序获得控制权，内核阶段开始了。内核镜像不是一个可以执行的内核，而是一个被压缩的内核镜像。通常是用zlib工具压缩的一个zImage（被压缩的镜像，小于512kb）或者一个bzImage（大的压缩镜像，大于512kb）。在内核镜像的头部有一个小型程序routine，其做少量的硬件设置，然后自解压内核镜像并放到高端内存。如果存在初始磁盘镜像（initrd），routine将拷贝initrd以供稍后安装使用。然后routine将调用内核开始内核启动。</p>
<p>当bzImage（i1386的镜像）被调用，将从汇编程序“./arch/i386/boot/head.S”的start入口开始（见Figure 3）。这段程序做些基本的硬件设置然后调用“./arch/i386/boot/compressed/head.S”中的startup_32。startup_32设置一些基本的环境（如堆栈等），并且清除BBS（Block Started by Symbol - 以符号启始的区块）。然后调用一个c函数decompress_kernel（位于./arch/i386/boot/compressed/misc.c）解压内核镜像。当内核被解压到内存后，将调用另一个位于“./arch/i386/kernel/head.S”的startup_32函数。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">decompress_kernel 输出</span><br><span class="line"></span><br><span class="line">decompress_kernel函数执行时，通常会看到如下解压内核信息：</span><br><span class="line"></span><br><span class="line">Uncompressing Linux... Ok, booting the kernel.</span><br></pre></td></tr></table></figure>
<p>在这个新的startup_32函数（也叫清除程序或者进程0）中，会对页表进行初始化，并启用内存分页功能。然后会为任何可选的浮点单元（FPU）检测 CPU 的类型，并将其存储起来供以后使用。然后调用 start_kernel 函数（在 init/main.c 中），它会将您带入与体系结构无关的 Linux 内核部分。从本质上讲，这才是Linux内核的主要功能。</p>
<p><strong>Figure 3. Major functions flow for the Linux kernel i386 boot</strong><br><img src="http://7xjdax.com1.z0.glb.clouddn.com/blogfigure3.gif" alt="Figure 3"></p>
<p>调用start_kernel函数之后，会调用一系列初始化函数来设置中断，执行进一步的内存配置，并加载初始RAM磁盘。最后将掉用kernel_thread（在arch/i386/kernel/process.c中）启动一个init函数，init函数是用户控件的第一个进程。最后，空闲进程将会开始执行并且进程调度器将获得控制权（当cpu调用cpu_idle后）。通过启用中断，抢占式的调度器就可以周期性地接管控制权，从而提供多任务处理能力。</p>
<p>在内核引导过程中，初始 RAM 磁盘（initrd）是由第 2 阶段引导程序加载到内存中的，它会被复制到 RAM 中并挂载到系统上。这个 initrd作为 RAM 中的临时根文件系统使用，并允许内核在没有挂载任何物理磁盘的情况下完整地实现引导。由于与外围设备进行交互所需要的模块可是 initrd 的一部分，因此内核可以非常小，但是仍然支持大量可能的硬件配置。在内核启动后，就可以正式装备根文件系统了（通过 pivot_root），此时会将 initrd 根文件系统卸载掉，并挂载真正的根文件系统。</p>
<p>initrd 函数让我们可以创建一个小型的 Linux 内核，其中包括作为可加载模块编译的驱动程序。这些可加载的模块为内核提供了访问磁盘和磁盘上的文件系统的方法，并为其他硬件提供了驱动程序。由于根文件系统是磁盘上的一个文件系统，因此 initrd 函数会提供一种启动方法来获得对磁盘的访问，并挂载真正的根文件系统。在没有硬盘的嵌入式目标中，initrd 可以是最终的根文件系统，或者也可以通过网络文件系统（NFS）来挂载最终的根文件系统。</p>
<h2 id="init进程">init进程</h2><p>在内核被启动并初始化后，内核启动第一个用户空间应用程序。这是调用的第一个使用标准 C 库编译的程序。在此进程之前，还没有执行任何标准的 C 应用程序。</p>
<p>在桌面 Linux 系统上，启动的第一个程序通常是 /sbin/init。不过完全没必要这样，很少有嵌入式系统会需要使用 init 所提供的丰富初始化功能（通过 /etc/inittab 配置的）。很多情况下，我们可以直接调用一个简单的 shell 脚本来启动必需的嵌入式应用程序。</p>
<h2 id="总结">总结</h2><p>与 Linux 本身非常类似，Linux 的引导过程也非常灵活，可以支持众多的处理器和硬件平台。最初，为加载引导程序提供了一种简单的方法，不用任何花架子就可以引导 Linux。LILO 引导程序对引导能力进行了扩展，但是它却缺少文件系统的识别能力。最新一代的引导程序，例如 GRUB，允许 Linux 从多种文件系统（如从 Minix 到 Reiser）上进行引导。</p>
<h2 id="Resource">Resource</h2><blockquote>
<p>这部分就不翻译了，安心当一个大自然的搬运工，不过将所有链接都做上去了的。</p>
</blockquote>
<p><strong>Learn</strong></p>
<ul>
<li><a href="http://mirror.href.com/thestarman/asm/mbr/MBR_in_detail.htm" target="_blank" rel="external">Boot Records Revealed</a> is a great resource on MBRs and the various boot loaders. This resource not only disassembles MBRs, but also discusses GRUB, LILO, and the various Windows? boot loaders.</li>
<li>Check out the <a href="http://www.rwc.uc.edu/koehler/comath/42.html" target="_blank" rel="external">Disk Geometry</a> page to understand disks and their geometries. You’ll find an interesting summary of disk attributes.</li>
<li>A <a href="http://en.wikipedia.org/wiki/LiveCD" target="_blank" rel="external">live CD</a> is an operating system that’s bootable from a CD or DVD without needing a hard drive.</li>
<li><a href="http://www.ibm.com/developerworks/linux/library/l-bootload.html" target="_blank" rel="external">“Boot loader showdown: Getting to know LILO and GRUB”</a> (developerWorks, August 2005) gives you a detailed look at the LILO and GRUB boot loaders.</li>
<li>In the <a href="http://www.ibm.com/developerworks/linux/lpi/101.html?S_TACT=105AGX03&amp;S_CMP=art" target="_blank" rel="external">Linux Professional Institute (LPI) exam prep</a> series of developerWorks tutorials, get a comprehensive introduction to booting a Linux system and many other fundamental Linux tasks while you prepare for system administrator certification.</li>
<li><a href="http://www.freshmeat.net/projects/lilo/" target="_blank" rel="external">LILO</a> was the precursor to GRUB, but you can still find it booting Linux.</li>
<li>The <a href="http://www.netadmintools.com/html/mkinitrd.man.html" target="_blank" rel="external">mkintrd</a> command is used to create an initial RAM disk image. This command is useful for building an initial root file system for boot configuration that allows preloading of block devices needed to access the real root file system.</li>
<li>At the <a href="http://debianlinux.net/linux.html" target="_blank" rel="external">Debian Linux Kernel Project</a>, find more information on the Linux kernel, boot, and embedded development.</li>
<li>In the <a href="http://www.ibm.com/developerworks/linux/" target="_blank" rel="external">developerWorks Linux zone</a>, find more resources for Linux developers.</li>
<li>Stay current with <a href="http://www.ibm.com/developerworks/offers/techbriefings/?S_TACT=105AGX03&amp;S_CMP=art" target="_blank" rel="external">developerWorks technical events and Webcasts</a>.</li>
</ul>
<p><strong>Get products and technologies</strong></p>
<ul>
<li>The <a href="http://www.linuxdevices.com/articles/AT8516113114.html" target="_blank" rel="external">MicroMonitor</a> provides a boot environment for a variety of small target devices. You can use this monitor to boot Linux in an embedded environment. It has ports for ARM, XScale, MIPS, PowerPC, Coldfire, and Hitachi’s Super-H.</li>
<li><a href="http://www.gnu.org/software/grub/" target="_blank" rel="external">GNU GRUB</a> is a boot shell filled with options and flexibility.</li>
<li><a href="http://www.linuxbios.org/index.php/Main_Page" target="_blank" rel="external">LinuxBIOS</a> is a BIOS replacement. Not only does it boot Linux, LinuxBIOS, itself, is a compressed Linux kernel.</li>
<li><a href="http://www.openbios.org/" target="_blank" rel="external">OpenBIOS</a> is another portable BIOS project that operates on a variety of architectures such as x86, Alpha, and AMD64.</li>
<li>At <a href="http://www.kernel.org/" target="_blank" rel="external">kernel.org</a>, grab the latest kernel tree.</li>
<li>With <a href="http://www.ibm.com/developerworks/downloads/?S_TACT=105AGX03&amp;S_CMP=art" target="_blank" rel="external">IBM trial software</a>, available for download directly from developerWorks, build your next development project on Linux.</li>
</ul>
<p><strong>Discuss</strong></p>
<ul>
<li>Check out <a href="http://www.ibm.com/developerworks/blogs/" target="_blank" rel="external">developerWorks blogs</a> and get involved in the <a href="http://www.ibm.com/developerworks/community" target="_blank" rel="external">developerWorks community</a>.</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p><strong>第一篇完全译文，因为自己对技术和英文的热爱，所以决定翻译此文，水平有限，所以肯定会有不恰当的地方，欢迎移驾至原地址：<a href="http://www.ibm.com/developerworks/linux/library/l-linuxboot/">http://www.ibm.com/developerworks/linux/library/l-linuxboot/</a></strong><br>注：因为想写一篇博文来阐述并理清Android启动的完全过程，发现了这篇文章，觉得写得十分好，帮我解答了很多疑惑。</p>
</blockquote>
<h2 id="引言">引言</h2><p>Linux系统的启动过程由很多阶段组成，但是无论你是启动标准的x86桌面还是启动嵌入式PowerPC目标，许多流程都是惊人的相似的。这篇文章从初始化引导程序到第一个用户空间应用程序探索Linux启动进程。顺着这个流程，你将知道很多和启动相关的主题，比如：引导程序，内核解压, 初始RAM磁盘,以及其他Linux引导元素。<br>]]>
    
    </summary>
    
      <category term="译文" scheme="http://huaqianlee.me/tags/%E8%AF%91%E6%96%87/"/>
    
      <category term="Linux" scheme="http://huaqianlee.me/categories/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[高通平台Android源码分析之Linux内核设备树(DT - Device Tree)]]></title>
    <link href="http://huaqianlee.me/2015/08/19/Android/%E9%AB%98%E9%80%9A%E5%B9%B3%E5%8F%B0Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BLinux%E5%86%85%E6%A0%B8%E8%AE%BE%E5%A4%87%E6%A0%91-DT-Device-Tree-dts%E6%96%87%E4%BB%B6/"/>
    <id>http://huaqianlee.me/2015/08/19/Android/高通平台Android源码分析之Linux内核设备树-DT-Device-Tree-dts文件/</id>
    <published>2015-08-19T14:11:46.000Z</published>
    <updated>2015-09-24T16:59:57.512Z</updated>
    <content type="html"><![CDATA[<p>刚开始接触Android源码的时候，发现在kernel里面多了一种dts文件，因为当初自学Linux时和在第一家公司做物联网模型时都是用的比较老的内核，内核代码还比较混乱，没有采用dts这种方便简洁的格式。后面才知道这是因为Linus的一句”this whole arm thing is a fucking pain in ass“促进改革的，记得Linux早期代码里面板级细节都是在C文件中描述的，代码就显得十分臃肿和混乱。如此优化之后就显得简洁多了，并且也更易于学习、移植。<br>　<br>今天准备专门来分析一下内核设备树，主要按照如下三个方向来分析：</p>
<ul>
<li>Device Tree组成及用法；</li>
<li>DTS文件解析常用api介绍；</li>
<li>DTS文件的编译；</li>
<li>高通Android源码中dts文件引用流程；<a id="more"></a>
</li>
</ul>
<h2 id="Device_Tree组成及用法">Device Tree组成及用法</h2><p>Device Tree由一系列node（节点）和property（属性）组成，节点本身可包含更多的子节点。属性是成对出现的name-value键值对。在device tree中主要描述如下信息：</p>
<ul>
<li>CPU的数量及类别</li>
<li>内存基地址和size</li>
<li>总线和桥</li>
<li>外设连接</li>
<li>中断</li>
<li>GPIO</li>
<li>CLOCK</li>
</ul>
<p>Device Tree在内核的作用有点类似于描述出PCB上的CPU、内存、总线、设备及IRQ GPIO等组成的tree结构。然后经由bootloader传递给内核，内核再根据此设备树解析出需要的i2c、spi等设备，然后将内存、IRQ、GPIO等资源绑定到相应的设备。</p>
<blockquote>
<p>lk中通过tag传递到kernel，文件路径：bootable/bootloader/lk/app/aboot/aboot.c，由DEVICE_TREE宏开关控制</p>
</blockquote>
<h2 id="DTS(device_tree_source)">DTS(device tree source)</h2><p>dts文件是一种ASCII文本格式的device tree描述文件，其结构明了，第一次看到都能大概猜出其描述意图。在内核中arm部分，基本上一个.dts文件对应一个arm的machine，一般位于kernel/arch/arm/boot/dts。由于一个soc可能对应多个machine，<br>所以一般讲多个machine通用的部分提炼为一个.dsti文件，有点类似于头文件的作用，引用方式也类似：#include “xxx.dtsi”，dtsi文件也可以相互引用。</p>
<h3 id="dts中的基本元素">dts中的基本元素</h3><p>dts中的基本元素为节点和属性，节点可以包含属性和子节点，属性为name-value键值对，如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/ &#123;&#10;    node1 &#123;&#10;        a-string-property = &#34;A string&#34;; // &#20540;&#20026;&#23383;&#31526;&#20018;&#10;        a-string-list-property = &#34;first string&#34;, &#34;second string&#34;;// &#20540;&#20026;&#23383;&#31526;&#25968;&#32452;&#10;        a-byte-data-property = [0x01 0x23 0x34 0x56]; // &#20540;&#20026;&#20108;&#36827;&#21046;&#10;        child-node1 &#123;&#10;            first-child-property; &#10;            second-child-property = &#60;1&#62;; &#10;            a-string-property = &#34;Hello, world&#34;;&#10;        &#125;;&#10;        child-node2 &#123;&#10;        &#125;;&#10;    &#125;;&#10;    node2 &#123;&#10;        an-empty-property; // &#20540;&#20026;kog&#10;        /* each number (cell) is a uint32 */&#10;        a-cell-property = &#60;1 2 3 4&#62;;  // cells&#65288;&#30001;uint32&#32452;&#25104;&#65289;&#10;        child-node1 &#123;&#10;        &#125;;&#10;    &#125;;&#10;&#125;;</span><br></pre></td></tr></table></figure></p>
<p>上述dt并没有什么真实用途，没有描述任何东西。不过展示了dt的结构：</p>
<ul>
<li>一个根节点：”/“；</li>
<li>一对子节点：”node1”和”node2”；</li>
<li>子节点的子节点：”child-node”；</li>
<li>属性定义： 属性值可以为空、字符串、cells(整数组成)、数组及二进制等任意字节流；</li>
</ul>
<p>属性中常用的字节流如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 字符串，用双引号引用： </span></span><br><span class="line">string-property = <span class="string">"A string"</span>; </span><br><span class="line"><span class="comment">#cells(32 bits)，用尖括号引用分隔开的32bit无符号整数：</span></span><br><span class="line">cell-property = &lt;<span class="number">0</span>xbeef <span class="number">123</span> <span class="number">0</span>xabcd1234&gt;；</span><br><span class="line"><span class="comment"># 二进制数据，用方括号引用：</span></span><br><span class="line">binary-property = [<span class="number">0</span>x01 <span class="number">0</span>x23 <span class="number">0</span>x45 <span class="number">0</span>x67];</span><br><span class="line"><span class="comment"># 通过逗号链接不同数据：</span></span><br><span class="line">mixed-property = <span class="string">"a string"</span>, [<span class="number">0</span>x01 <span class="number">0</span>x23 <span class="number">0</span>x45 <span class="number">0</span>x67], &lt;<span class="number">0</span>x12345678&gt;;</span><br><span class="line"><span class="comment"># 通过逗号创建字符串数组：</span></span><br><span class="line">string-list = <span class="string">"red fish"</span>, <span class="string">"blue fish"</span>;</span><br></pre></td></tr></table></figure></p>
<h2 id="Sample_Machine">Sample Machine</h2><p>理解设备树怎么被用的最好办法，就是做一遍，接下来就通过一步一步构建描述一个简单machine的device tree来理解设备树。假设machine的硬件配置如下：</p>
<ul>
<li>一个32bit的ARM CPU</li>
<li>处理器的local bus的内存映射分布了串口、spi总线控制器、i2c控制器、中断控制器和外部总线桥</li>
<li>256MB的SDRAM，基地址为0</li>
<li>2个串口基地址为：0x101f1000 和 0x101f2000</li>
<li>GPIO控制器，基地址为0x101f3000</li>
<li>spi控制器，基地址为0x10170000,从属设备：<ul>
<li>MMC slot with ss pin attached to GPIO #1 (不能很好理解其意思，所以就不胡乱翻译了)</li>
</ul>
</li>
<li>External bus桥，从属设备：<ul>
<li>smc smc91111 Ethernet设备，基地址为0x10100000</li>
<li>i2c控制器，基地址为0x10160000，从属设备：<ul>
<li>Maxim DS1338时钟芯片，从设备I2C地址 1101000(0x58)</li>
</ul>
</li>
<li>64MB Nor flash,基地址为0x30000000</li>
</ul>
</li>
</ul>
<h3 id="初始化结构">初始化结构</h3><p>首先，为machine创建一个框架结构，一个有效设备树的最简单的结构，如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/ &#123;&#10;    compatible = &#34;acme,coyotes-revenge&#34;;&#10;&#125;;</span><br></pre></td></tr></table></figure></p>
<p>compatible指定系统的名字，格式： compatible = “&lt; manufacturer&gt;,&lt; model&gt;”（制造商，型号）。它非常重要，用来精确指定设备，并通过包含manufacurer(制造商)名字来避免冲突。因为操作系统通过compatible的值来决定machine怎么运行，所以使用正确的值是非常重要的。<br>　<br>理论上来说，compatible是操作系统所有数据标示machine的唯一标示符，os将通过顶层compatible寻找相应的值。</p>
<h3 id="CPUs">CPUs</h3><p>第二步，描述CPU的”cpus”节点，其包含每一个CPU描述信息的子节点，在这个例子中，CPU为一个双核的arm cortex A9处理器，所以其描述如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/ &#123;&#10;    compatible = &#34;acme,coyotes-revenge&#34;;&#10;&#10;    cpus &#123;&#10;        cpu@0 &#123;&#10;            compatible = &#34;arm,cortex-a9&#34;; // &#26684;&#24335;&#21516;&#39030;&#23618;&#33410;&#28857;&#65292;&#60;manufacturer&#62;,&#60;model&#62;&#10;        &#125;;&#10;        cpu@1 &#123;&#10;            compatible = &#34;arm,cortex-a9&#34;;&#10;        &#125;;&#10;    &#125;;&#10;&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="节点名">节点名</h3><p>每一个节点必须有一个节点名，格式： &lt; name&gt;[@&lt; unit-address&gt;]。</p>
<ul>
<li>&lt; name&gt;：为最长31个字符的ascii字符串，一般用其代表的设备类型命名，ie. 一个3com Ethernet adapter的节点名：ethernet，不用3com509。</li>
<li>unit-address： 描述设备的地址，一般情况下，其提供访问设备的基地址，节点的reg property也用此参数，见下文。</li>
</ul>
<p>同层次兄弟节点的节点名必须是独一无二的，不过多个节点可以使用一样的通用name，只要地址不同就可以了。ie. serial@101f1000 &amp; serial@101f2000</p>
<h3 id="Devices">Devices</h3><p>每一个device在系统中由一个设备树节点描述，所以接下来，第三步是为设备填充树的节点。不过，现在我为新节点创建一个空节点，直到我们知道地址范围和如何处理irqs请求之后再填写相应内容。如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/ &#123;&#10;    compatible = &#34;acme,coyotes-revenge&#34;;&#10;&#10;    cpus &#123;&#10;        cpu@0 &#123;&#10;            compatible = &#34;arm,cortex-a9&#34;;&#10;        &#125;;&#10;        cpu@1 &#123;&#10;            compatible = &#34;arm,cortex-a9&#34;;&#10;        &#125;;&#10;    &#125;;&#10;&#10;    serial@101F0000 &#123;&#10;        compatible = &#34;arm,pl011&#34;;&#10;    &#125;;&#10;&#10;    serial@101F2000 &#123;&#10;        compatible = &#34;arm,pl011&#34;;&#10;    &#125;;&#10;&#10;    gpio@101F3000 &#123;&#10;        compatible = &#34;arm,pl061&#34;;&#10;    &#125;;&#10;&#10;    interrupt-controller@10140000 &#123;&#10;        compatible = &#34;arm,pl190&#34;;&#10;    &#125;;&#10;&#10;    spi@10115000 &#123;&#10;        compatible = &#34;arm,pl022&#34;;&#10;    &#125;;&#10;&#10;    external-bus &#123;&#10;        ethernet@0,0 &#123;&#10;            compatible = &#34;smc,smc91c111&#34;;&#10;        &#125;;&#10;&#10;        i2c@1,0 &#123;&#10;            compatible = &#34;acme,a1234-i2c-bus&#34;;&#10;            rtc@58 &#123;&#10;                compatible = &#34;maxim,ds1338&#34;;&#10;            &#125;;&#10;        &#125;;&#10;&#10;        flash@2,0 &#123;&#10;            compatible = &#34;samsung,k8f1315ebm&#34;, &#34;cfi-flash&#34;;&#10;        &#125;;&#10;    &#125;;&#10;&#125;;</span><br></pre></td></tr></table></figure></p>
<p>在此tree中，在系统中为每一个device增加了节点，其层次结构反应了系统中的连接情况。ie. extern bus上的的设备憋创建为external bus节点的子节点，i2c设备被创建为i2c总线控制器的子节点。简单来说，tree中的层次结构代表了系统中的CPU视图。</p>
<p>目前，这个tree是无效的，因为它没有设备之间的连接信息，接下来再添加这些信息。<br>在这个tree中有几点需要注意：</p>
<ul>
<li>每个设备节点都有一个compatible属性</li>
<li>flash节点的compatible属性有两个字符串值。</li>
<li>如前所述，节点名反映设备类型，而非详细型号。</li>
</ul>
<h4 id="compatible详解">compatible详解</h4><p>设备树中每个节点都需要有compatible属性，compatible属性决定每一个设备驱动绑定哪一个设备。如上所介绍，compatible是一个字符串序列，第一个字符串指定精确设备，第二字符串指定兼容设备。</p>
<p>例如：Freescale MPC8349片上有一个根据国家半导体ns16550接口实现的串行设备，定义为：compatible = “fsl,mpc8349-uart”, “ns16550”. 第一个字符串指定精确设备，第二个指定国家半导体16550 uart兼容设备。</p>
<blockquote>
<p>ns16550没有制造商前缀（manufacturer）纯属历史原因，所有的compatible值应该带有制造商前缀。</p>
</blockquote>
<p>这种做法允许将存在的设备驱动绑定到一类更新的设备，并且仍然能识别到精确的设备。</p>
<blockquote>
<p>警告：不要使用通配符赋值，如：”fsl,mpc83xx-uart”等。为了兼容后续设备，一般会选择一个特定实现，如上的：”ns16550”。</p>
</blockquote>
<h3 id="设备寻址">设备寻址</h3><p>关于设备寻址，设备树中通过如下属性encode地址信息：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">reg ：每个可寻址的设备有一个reg cells.</span><br><span class="line">格式：reg = &lt;address1 length1 [address2 length2] [address3 length3] ... &gt;</span><br><span class="line">// 因为地址和地址长度是变量，所以父节点中定义<span class="comment">#address-cells和#size-cells两个属性，声明每个域里会用到多少cell</span></span><br><span class="line"><span class="comment">#address-cells</span></span><br><span class="line"><span class="comment">#size-cells</span></span><br></pre></td></tr></table></figure></p>
<h5 id="CPU寻址">CPU寻址</h5><p>CPU节点寻址是寻址里面最简单的，每个CPU被一个独一无二的ID标记，没有size与CPU ids关联。如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cpus &#123;&#10;    #address-cells = &#60;1&#62;;&#10;    #size-cells = &#60;0&#62;; // &#27492;&#20004;&#20010;&#23646;&#24615;&#34920;&#26126;&#23376;&#33410;&#28857;reg &#20540;&#20026;&#19968;&#20010;&#27809;&#26377;size&#30340;uint32&#22320;&#22336;&#10;    cpu@0 &#123;&#10;        compatible = &#34;arm,cortex-a9&#34;;&#10;        reg = &#60;0&#62;; // &#20540;&#19982;&#33410;&#28857;&#21517;&#30340;unit-address&#30456;&#21516;&#10;    &#125;;&#10;    cpu@1 &#123;&#10;        compatible = &#34;arm,cortex-a9&#34;;&#10;        reg = &#60;1&#62;; &#10;    &#125;;&#10;&#125;;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>如果一个节点有reg属性，则节点名必须包含unit-address，并且取reg属性的第一个address值。</p>
</blockquote>
<h3 id="有内存映像地址的设备">有内存映像地址的设备</h3><p>与cpu中只有address值不同，有内存映像地址的设备还需分配地址范围值，每个子节点reg元素定义地址长度值的数量由父节点的#size-cells指定。如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/ &#123;&#10;    #address-cells = &#60;1&#62;; // &#20540;&#20026; 1 cell(32bits)&#10;    #size-cells = &#60;1&#62;; // &#27599;&#20010;&#38271;&#24230;&#20540;&#20026; 1 cell&#10;    // &#22914;&#26524;&#26159;64 bit machines&#65292; &#21017;&#20197;&#19978;&#20004;&#20540;&#20026;2&#10;    ...&#10;&#10;    serial@101f0000 &#123;&#10;        compatible = &#34;arm,pl011&#34;;&#10;        reg = &#60;0x101f0000 0x1000 &#62;; &#10;        // &#31532;&#19968;&#20010;&#21442;&#25968;&#20026;&#22522;&#22320;&#22336;&#65292;&#31532;&#20108;&#20010;&#21442;&#25968;&#20026;&#22320;&#22336;&#38271;&#24230;&#65292;&#27492;&#22788;&#34920;&#31034;serial&#30340;&#20869;&#23384;&#22320;&#22336;&#33539;&#22260;&#65306;0x101f0000~0x101f0fff&#10;    &#125;;&#10;&#10;    serial@101f2000 &#123;&#10;        compatible = &#34;arm,pl011&#34;;&#10;        reg = &#60;0x101f2000 0x1000 &#62;;&#10;    &#125;;&#10;&#10;    gpio@101f3000 &#123;&#10;        compatible = &#34;arm,pl061&#34;;&#10;        reg = &#60;0x101f3000 0x1000&#10;               0x101f4000 0x0010&#62;; // GPIO&#35774;&#22791;&#34987;&#20998;&#37197;&#21040;&#20004;&#20010;&#22320;&#22336;&#33539;&#22260;&#10;    &#125;;&#10;&#10;    interrupt-controller@10140000 &#123;&#10;        compatible = &#34;arm,pl190&#34;;&#10;        reg = &#60;0x10140000 0x1000 &#62;;&#10;    &#125;;&#10;&#10;    spi@10115000 &#123;&#10;        compatible = &#34;arm,pl022&#34;;&#10;        reg = &#60;0x10115000 0x1000 &#62;;&#10;    &#125;;&#10;&#10;    ...&#10;&#10;&#125;;</span><br></pre></td></tr></table></figure></p>
<p>当然，并不是所有设备都直接和cpu相连，也有一些设备通过挂载到一条总线上和cpu相连。对于挂接到总线的设备，每个父节点为子节点定义地址域，如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">external-bus &#123;  //&#29238;&#33410;&#28857;&#10;#address-cells = &#60;2&#62; // &#23376;&#33410;&#28857;&#26377;2 cells&#22522;&#22320;&#22336;&#20540;&#65292;&#19968;&#20010;&#29992;&#20110;&#25351;&#23450;chip number&#65292;&#19968;&#20010;&#29992;&#20110;&#25351;&#23450;&#36873;&#20013;&#33455;&#29255;&#22522;&#22320;&#22336;&#30340;&#20559;&#31227;&#37327;&#10;#size-cells = &#60;1&#62;; // &#23376;&#33410;&#28857;&#26377;1 cell &#22320;&#22336;&#38271;&#24230;&#10;&#10;    ethernet@0,0 &#123;&#10;        compatible = &#34;smc,smc91c111&#34;;&#10;        reg = &#60;0 0 0x1000&#62;;&#10;    &#125;;&#10;&#10;    i2c@1,0 &#123;&#10;        compatible = &#34;acme,a1234-i2c-bus&#34;;&#10;        reg = &#60;1 0 0x1000&#62;;&#10;        rtc@58 &#123;&#10;            compatible = &#34;maxim,ds1338&#34;;&#10;        &#125;;&#10;    &#125;;&#10;&#10;    flash@2,0 &#123;&#10;        compatible = &#34;samsung,k8f1315ebm&#34;, &#34;cfi-flash&#34;;&#10;        reg = &#60;2 0 0x4000000&#62;;&#10;    &#125;;&#10;&#125;;</span><br></pre></td></tr></table></figure></p>
<p>由于地址域被节点和其子节点一起定义，所以父节点可以为总线定义任何寻址方式。除了直接父亲以外的所有节点和子节点都不用关心本地的寻址域，不用关心地址从哪映射到哪。</p>
<blockquote>
<p>如不明白，请继续往下看，相信接下来的部分会帮你解惑</p>
</blockquote>
<h3 id="无内存映像的设备">无内存映像的设备</h3><p>无内存映像的设备没有直接访问cpu的权限，父设备的驱动将间接访问cpu，其cpu一样reg属性会有一个地址值，但没有地址长度或范围，如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i2c@1,0 &#123;&#10;    compatible = &#34;acme,a1234-i2c-bus&#34;;&#10;    #address-cells = &#60;1&#62;;&#10;    #size-cells = &#60;0&#62;;&#10;    reg = &#60;1 0 0x1000&#62;;&#10;    rtc@58 &#123;&#10;        compatible = &#34;maxim,ds1338&#34;;&#10;        reg = &#60;58&#62;;&#10;    &#125;;&#10;&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="地址转换">地址转换</h3><p>前面讲了怎么给设备分配本地地址，但没有说明怎么映射到cpu能直接访问的地址。接下来就详细分析一下这一部分：</p>
<p>根节点描述cpu地址空间视图，根节点的子节点不需要做任何显性的映射直接使用cpu的地址域。比如：serial@101f0000直接分配到地址0x101f0000.</p>
<p>而不是根节点的直接孩子的节点不使用cpu的地址域，为了能将其映射到cpu的内存地址，设备树就得对其地址进行转换，ranges属性就是用来实现这个目的的，加入ranges属性后如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/ &#123;&#10;    compatible = &#34;acme,coyotes-revenge&#34;;&#10;    #address-cells = &#60;1&#62;;&#10;    #size-cells = &#60;1&#62;;&#10;    ...&#10;    external-bus &#123;&#10;        #address-cells = &#60;2&#62;&#10;        #size-cells = &#60;1&#62;;&#10;        ranges = &#60;0 0  0x10100000   0x10000     // Chipselect 0, Ethernet&#10;                         1 0  0x10160000   0x10000     // Chipselect 1, i2c controller&#10;                         2 0  0x30000000   0x10000000&#62;; // Chipselect 2, NOR Flash&#65292;&#27492;&#22788;&#21442;&#32771;&#25991;&#31456;&#22320;&#22336;&#31354;&#38388;&#22823;&#23567;&#23569;&#19968;&#20010;0&#65292;&#20294;&#25105;&#35273;&#24471;&#19981;&#23545;&#65292;&#25152;&#20197;&#33258;&#24049;&#20570;&#20102;&#20462;&#25913;&#65292;&#19979;&#21516;&#65292;&#23601;&#19981;&#20877;&#35828;&#26126;&#10;&#10;// &#30456;&#20449;&#22823;&#23478;&#30452;&#25509;&#36890;&#36807;&#36825;&#20010;&#21015;&#34920;&#23601;&#33021;&#30693;&#36947;&#22320;&#22336;&#24590;&#20040;&#36716;&#25442;&#30340;&#20102;&#65292;&#22914;&#19979;&#65306;&#10;&#10;1. &#20559;&#31227;&#37327;&#20026;0&#30340;Chipselect0&#26144;&#23556;&#21040;0x10100000~0x1010ffff&#10;2. &#20559;&#31227;&#37327;&#20026;0&#30340;Chipselect1&#26144;&#23556;&#21040;0x10160000~0x1016ffff&#10;3. &#20559;&#31227;&#37327;&#20026;0&#30340;Chipselect2&#26144;&#23556;&#21040;0x30000000~0x3fffffff &#65288;&#27492;&#22788;&#21442;&#32771;&#25991;&#31456;&#20889;&#30340;0x10000000&#65292;&#20294;&#25105;&#35273;&#24471;&#24212;&#35813;&#26159;0x3fffffff&#65292;&#21407;&#22320;&#22336;&#35265;&#21338;&#25991;&#26368;&#21518;&#24341;&#29992;&#65289;&#10;&#10;        ethernet@0,0 &#123;&#10;            compatible = &#34;smc,smc91c111&#34;;&#10;            reg = &#60;0 0 0x1000&#62;;&#10;        &#125;;&#10;&#10;// i2c&#24635;&#32447;&#33410;&#28857;&#27809;&#26377;ranges&#21442;&#25968;&#65292;&#22240;&#20026;i2c&#24635;&#32447;&#19978;&#30340;&#35774;&#22791;&#19981;&#38656;&#26144;&#23556;&#21040;cpu&#22320;&#22336;&#22495;&#65292;cpu&#30452;&#25509;&#36890;&#36807;i2c&#23601;&#33021;&#35775;&#38382;i2c&#35774;&#22791;&#10;        i2c@1,0 &#123;&#10;            compatible = &#34;acme,a1234-i2c-bus&#34;;&#10;            #address-cells = &#60;1&#62;;&#10;            #size-cells = &#60;0&#62;;&#10;            reg = &#60;1 0 0x1000&#62;;&#10;            rtc@58 &#123;&#10;                compatible = &#34;maxim,ds1338&#34;;&#10;                reg = &#60;58&#62;;&#10;            &#125;;&#10;        &#125;;&#10;&#10;        flash@2,0 &#123;&#10;            compatible = &#34;samsung,k8f1315ebm&#34;, &#34;cfi-flash&#34;;&#10;            reg = &#60;2 0 0x10000000&#62;; // &#27492;&#22788;&#21442;&#32771;&#25991;&#31456;&#20889;&#30340;0x4000000&#65292; &#20294;&#25105;&#35273;&#24471;&#20026;0x10000000 - 256MB&#10;        &#125;;&#10;    &#125;;&#10;&#125;;</span><br></pre></td></tr></table></figure></p>
<p>ranges参数的值是一个地址转换列表，每一个条目由如下几部分组成：</p>
<ul>
<li>子节点地址：由子节点的#address-cells值决定</li>
<li>父节点地址：由父节点的#address-cells值决定</li>
<li>子节点地址空间的大小 ：由子节点的#size-cells值决定</li>
</ul>
<p>如果ranges参数为空，则表示子节点地址和父节点地址1:1映射。你可能会有疑问，既然1:1映射，为什么还要通过地址转换来获得地址空间。一些总线（比如PCI）有完全不同的地址空间细节需要暴露给操作系统。其他带DMA的设备需要知道设备在总线上的真实地址。有时设备需要组合在一起去共享相同的可编程物理地址映射。是否需要通过1:1映射依赖于操作系统和硬件设计的很多信息。</p>
<p>缺乏ranges参数意味着，一个设备只能被其父节点访问而不能被cpu直接访问。</p>
<h3 id="中断">中断</h3><p>中断信号可以来自machine的任何设备，中断信号在设备树中被描述为节点之间的links。主要有如下4中属性：</p>
<ul>
<li>interrupt-controller：一个空属性，定义节点为中断控制器；</li>
<li>#interrupt-cells：表明连接此中断控制器的interrupts属性cell大小（类似于#address-cells和#size-cells）；</li>
<li>interrupt-parent：指定节点设备所依附的中断控制器的phandle，若没有此参数，则从父节点继承；</li>
<li>interrupts：中断说明符列表，节点通过此方法指定中断号、触发方式等；</li>
</ul>
<p>一个中断说明符描述指定中断输入设备的相关信息，由#interrupt-cells指定中断说明符cell数量。设备可能一个或多个中断源。一个中断设备的说明符完全取决于绑定的中断控制器设备。  定义一个中断源需要多少cells由中断控制器决定。加入中断相关属性后如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/ &#123;&#10;    compatible = &#34;acme,coyotes-revenge&#34;;&#10;    #address-cells = &#60;1&#62;;&#10;    #size-cells = &#60;1&#62;;&#10;    interrupt-parent = &#60;&#38;intc&#62;;  // intc-&#62;interrupt-controller&#65292;&#20316;&#20026;&#31995;&#32479;&#40664;&#35748;&#30340;interrupt-parent&#23646;&#24615;&#65292;&#23376;&#33410;&#28857;&#37325;&#20889;&#21017;&#35206;&#30422;&#10;&#10;    cpus &#123;&#10;        #address-cells = &#60;1&#62;;&#10;        #size-cells = &#60;0&#62;;&#10;        cpu@0 &#123;&#10;            compatible = &#34;arm,cortex-a9&#34;;&#10;            reg = &#60;0&#62;;&#10;        &#125;;&#10;        cpu@1 &#123;&#10;            compatible = &#34;arm,cortex-a9&#34;;&#10;            reg = &#60;1&#62;;&#10;        &#125;;&#10;    &#125;;&#10;&#10;    serial@101f0000 &#123;&#10;        compatible = &#34;arm,pl011&#34;;&#10;        reg = &#60;0x101f0000 0x1000 &#62;;&#10;        interrupts = &#60; 1 0 &#62;; // &#25351;&#23450;&#20013;&#26029;&#28304;&#10;    &#125;;&#10;&#10;    serial@101f2000 &#123;&#10;        compatible = &#34;arm,pl011&#34;;&#10;        reg = &#60;0x101f2000 0x1000 &#62;;&#10;        interrupts = &#60; 2 0 &#62;;&#10;    &#125;;&#10;&#10;    gpio@101f3000 &#123;&#10;        compatible = &#34;arm,pl061&#34;;&#10;        reg = &#60;0x101f3000 0x1000&#10;               0x101f4000 0x0010&#62;;&#10;        interrupts = &#60; 3 0 &#62;;&#10;    &#125;;&#10;&#10;    intc: interrupt-controller@10140000 &#123;  // &#20013;&#26029;&#25511;&#21046;&#22120;&#10;        compatible = &#34;arm,pl190&#34;;&#10;        reg = &#60;0x10140000 0x1000 &#62;;&#10;        interrupt-controller;&#10;        #interrupt-cells = &#60;2&#62;; // &#20013;&#26029;&#35828;&#26126;&#31526;&#26377;2 cells&#65292;&#27492;&#20363;&#20013;cell 1&#34920;&#31034;&#20013;&#26029;&#21495;&#65292;cell 2 &#34920;&#31034;&#35302;&#21457;&#26041;&#24335;&#10;    &#125;;&#10;&#10;    spi@10115000 &#123;&#10;        compatible = &#34;arm,pl022&#34;;&#10;        reg = &#60;0x10115000 0x1000 &#62;;&#10;        interrupts = &#60; 4 0 &#62;; // &#27880;&#65306;&#35774;&#22791;&#36824;&#21487;&#20197;&#20351;&#29992;&#22810;&#20010;&#20013;&#26029;&#21495;&#65292;&#20551;&#22914;&#27492;spi&#20351;&#29992;&#20004;&#20010;&#65292;&#21017;&#65306;interrupts = &#60;0 4 0&#62;, &#60;1 5 0&#62;;&#10;    &#125;;&#10;&#10;    external-bus &#123;&#10;        #address-cells = &#60;2&#62;&#10;        #size-cells = &#60;1&#62;;&#10;        ranges = &#60;0 0  0x10100000   0x10000     // Chipselect 0, Ethernet&#10;                  1 0  0x10160000   0x10000     // Chipselect 1, i2c controller&#10;                  2 0  0x30000000   0x10000000&#62;; // Chipselect 2, NOR Flash&#10;&#10;        ethernet@0,0 &#123;&#10;            compatible = &#34;smc,smc91c111&#34;;&#10;            reg = &#60;0 0 0x1000&#62;;&#10;            interrupts = &#60; 5 2 &#62;;&#10;        &#125;;&#10;&#10;        i2c@1,0 &#123;&#10;            compatible = &#34;acme,a1234-i2c-bus&#34;;&#10;            #address-cells = &#60;1&#62;;&#10;            #size-cells = &#60;0&#62;;&#10;            reg = &#60;1 0 0x1000&#62;;&#10;            interrupts = &#60; 6 2 &#62;;&#10;            rtc@58 &#123;&#10;                compatible = &#34;maxim,ds1338&#34;;&#10;                reg = &#60;58&#62;;&#10;                interrupts = &#60; 7 3 &#62;;&#10;            &#125;;&#10;        &#125;;&#10;&#10;        flash@2,0 &#123;&#10;            compatible = &#34;samsung,k8f1315ebm&#34;, &#34;cfi-flash&#34;;&#10;            reg = &#60;2 0 0x10000000&#62;;&#10;        &#125;;&#10;    &#125;;&#10;&#125;;</span><br></pre></td></tr></table></figure></p>
<p>另， 关于cell含义在内核中的相关文档有详细描述，比如arm gic 中断：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># Documentation/devicetree/bindings/arm/gic.txt&#10;The 1st cell is the interrupt type; 0 for SPI interrupts, 1 for PPI  &#10;interrupts.  &#10;&#10;The 2nd cell contains the interrupt number for the interrupt type.  &#10;SPI interrupts are in the range [0-987].  PPI interrupts are in the  &#10;range [0-15].   &#10;&#10;The 3rd cell is the flags, encoded as follows:  &#10;       bits[3:0] trigger type and level flags.  &#10;               1 = low-to-high edge triggered  &#10;               2 = high-to-low edge triggered  &#10;               4 = active high level-sensitive  &#10;               8 = active low level-sensitive  &#10;       bits[15:8] PPI interrupt cpu mask.  Each bit corresponds to each of  &#10;       the 8 possible cpus attached to the GIC.  A bit set to &#39;1&#39; indicated  &#10;       the interrupt is wired to that CPU.  Only valid for PPI interrupts.</span><br></pre></td></tr></table></figure></p>
<h3 id="设备特有数据">设备特有数据</h3><p>除了上面讲的常用属性，任意需要的属性和子节点都可以被加入到设备树，不过新device-specific属性应将制造商名作为前缀命名，以避免与标准的属性冲突；</p>
<blockquote>
<p>其实还有一些要求，不过主要针对内核开发者的，而我还没有那个水平，就没详细看了 </p>
</blockquote>
<h3 id="特殊节点">特殊节点</h3><h4 id="aliases节点">aliases节点</h4><p>一个specific节点通常以完全路径的形式引用，如：/external-bus/ethernet@0,0 ， 但是这样太复杂了，不利于阅读。所以通常会用以一个短的别名命名的aliases节点去指定设备的完全路径，如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aliases &#123;&#10;    ethernet0 = &#38;eth0;  &#10;    serial0 = &#38;serial0;&#10;&#125;;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注：property = &amp;Label 不同于如上中断phandle引用的phandle = &lt;&amp;Lable&gt;</p>
</blockquote>
<h4 id="chosen节点">chosen节点</h4><p>chosen节点不指明真实的设备，其为硬件和操作系统数据传输服务，如：启动参数。通常chosen节点在dts源文件中写为空，在启动时再填充，在例中增加如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chosen &#123;&#10;        bootargs = &#34;root=/dev/nfs rw nfsroot=192.168.1.1 console=ttyS0,115200&#34;;&#10;    &#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="DTC_(device_tree_compiler)">DTC (device tree compiler)</h2><p>DTC将.dts编译为.dtb的工具。DTC的源代码位于内核的scripts/dtc目录，在Linux内核使能了Device Tree的情况下，编译内核的时候主机工具dtc会被编译出来，对应scripts/dtc/Makefile中的“hostprogs-y := dtc”。<br>在Linux内核的arch/arm/boot/dts/Makefile中，描述了当某种SoC被选中后，哪些.dtb文件会被编译出来，如与VEXPRESS对应的.dtb包括：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dtb-$(CONFIG_ARCH_VEXPRESS) += vexpress-v2p-ca5s.dtb \  </span><br><span class="line">        vexpress-v2p-ca9.dtb \  </span><br><span class="line">        vexpress-v2p-ca15-tc1.dtb \  </span><br><span class="line">        vexpress-v2p-ca15_a7.dtb \  </span><br><span class="line">        xenvm-<span class="number">4.2</span>.dtb</span><br></pre></td></tr></table></figure></p>
<p>在Linux下，我们可以通过make dtbs命令单独编译Device Tree文件。因为arch/arm/Makefile中含有一个dtbs编译target，如下：<br><figure class="highlight mk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Build the DT binary blobs if we have OF configured</span></span><br><span class="line">ifeq ($(CONFIG_USE_OF),y)</span><br><span class="line"><span class="constant">KBUILD_DTBS</span> := dtbs</span><br><span class="line">endif</span><br></pre></td></tr></table></figure></p>
<h3 id="Device_Tree_Blob_(dtb)">Device Tree Blob (dtb)</h3><p>dtb是dts被DTC编译后生成的二进制格式Device Tree描述，可由Linux内核解析。系统设计时通常会单独留下一个很小的flash空间存放.dtb文件，bootloader在引导kernel的过程中，会先读取该.dtb到内存。</p>
<h3 id="Binding">Binding</h3><p>对于Device Tree中的结点和属性具体是如何来描述设备的硬件细节的，内核里有相应的文档，位于：Documentation/devicetree/bindings目录，其下又分为很多子目录。</p>
<h2 id="dts解析API">dts解析API</h2><blockquote>
<p>注：此部分基本完全摘自参考文档</p>
</blockquote>
<p>在Linux的BSP和驱动代码中，解析dts的API通常被以“of_”作为前缀，它们的实现代码位于内核的drivers/of目录。接下来就介绍一下常用的API。</p>
<p><strong>int of_device_is_compatible(const struct device_node <em>device,const char </em>compat);</strong></p>
<p>判断设备结点的compatible 属性是否包含compat指定的字符串。当一个驱动支持2个或多个设备的时候，这些不同.dts文件中设备的compatible 属性都会进入驱动 OF匹配表。因此驱动可以透过Bootloader传递给内核的Device Tree中的真正结点的compatible 属性以确定究竟是哪一种设备，从而根据不同的设备类型进行不同的处理。如drivers/pinctrl/pinctrl-sirf.c即兼容于”sirf,prima2-pinctrl”，又兼容于”sirf,prima2-pinctrl”，在驱动中就有相应分支处理：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (of_device_is_compatible(np, <span class="string">"sirf,marco-pinctrl"</span>))  </span><br><span class="line">      is_marco = <span class="number">1</span>;  </span><br><span class="line"><span class="keyword">struct</span> device_node *of_find_compatible_node(<span class="keyword">struct</span> device_node *from,</span><br><span class="line">         <span class="keyword">const</span> <span class="keyword">char</span> *type, <span class="keyword">const</span> <span class="keyword">char</span> *compatible);</span><br></pre></td></tr></table></figure></p>
<p>根据compatible属性，获得设备结点。遍历Device Tree中所有的设备结点，看看哪个结点的类型、compatible属性与本函数的输入参数匹配，大多数情况下，from、type为NULL。</p>
<p><strong>int of_property_read_u8_array(const struct device_node <em>np, const char </em>propname, u8 <em>out_values, size_t sz);<br>int of_property_read_u16_array(const struct device_node </em>np, const char <em>propname, u16 </em>out_values, size_t sz);<br>int of_property_read_u32_array(const struct device_node <em>np, const char </em>propname, u32 <em>out_values, size_t sz);<br>int of_property_read_u64(const struct device_node </em>np, const char <em>propname, u64 </em>out_value);</strong></p>
<p>读取设备结点np的属性名为propname，类型为8、16、32、64位整型数组的属性。对于32位处理器来讲，最常用的是of_property_read_u32_array()。如在arch/arm/mm/cache-l2x0.c中，透过如下语句读取L2 cache的”arm,data-latency”属性：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">of_property_read_u32_array(np, <span class="string">"arm,data-latency"</span>,  </span><br><span class="line">      data, ARRAY_SIZE(data));</span><br></pre></td></tr></table></figure></p>
<p>在arch/arm/boot/dts/vexpress-v2p-ca9.dts中，含有”arm,data-latency”属性的L2 cache结点如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">L2: cache-controller@<span class="number">1e00</span>a000 &#123;  </span><br><span class="line">        compatible = <span class="string">"arm,pl310-cache"</span>;  </span><br><span class="line">        reg = &lt;<span class="number">0x1e00a000</span> <span class="number">0x1000</span>&gt;;  </span><br><span class="line">        interrupts = &lt;<span class="number">0</span> <span class="number">43</span> <span class="number">4</span>&gt;;  </span><br><span class="line">        cache-level = &lt;<span class="number">2</span>&gt;;  </span><br><span class="line">        arm,data-latency = &lt;<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>&gt;;  </span><br><span class="line">        arm,tag-latency = &lt;<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>&gt;;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>有些情况下，整形属性的长度可能为1，于是内核为了方便调用者，又在上述API的基础上封装出了更加简单的读单一整形属性的API，它们为int of_property_read_u8()、of_property_read_u16()等，实现于include/linux/of.h：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">of_property_read_u8</span><span class="params">(<span class="keyword">const</span> <span class="keyword">struct</span> device_node *np,  </span><br><span class="line">                                       <span class="keyword">const</span> <span class="keyword">char</span> *propname,  </span><br><span class="line">                                       u8 *out_value)</span>  </span><br><span class="line"></span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> of_property_read_u8_array(np, propname, out_value, <span class="number">1</span>);  </span><br><span class="line">&#125;  </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">of_property_read_u16</span><span class="params">(<span class="keyword">const</span> <span class="keyword">struct</span> device_node *np,  </span><br><span class="line">                                       <span class="keyword">const</span> <span class="keyword">char</span> *propname,  </span><br><span class="line">                                       u16 *out_value)</span>  </span><br><span class="line"></span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> of_property_read_u16_array(np, propname, out_value, <span class="number">1</span>);  </span><br><span class="line">&#125;  </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">of_property_read_u32</span><span class="params">(<span class="keyword">const</span> <span class="keyword">struct</span> device_node *np,  </span><br><span class="line">                                       <span class="keyword">const</span> <span class="keyword">char</span> *propname,  </span><br><span class="line">                                       u32 *out_value)</span>  </span><br><span class="line"></span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> of_property_read_u32_array(np, propname, out_value, <span class="number">1</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>int of_property_read_string(struct device_node <em>np, const char </em>propname, const char </strong>out_string);<br>int of_property_read_string_index(struct device_node <em>np, const char    </em>propname, int index, const char <strong>output);</strong></p>
<p>前者读取字符串属性，后者读取字符串数组属性中的第index个字符串。如drivers/clk/clk.c中的of_clk_get_parent_name()透过of_property_read_string_index()遍历clkspec结点的所有”clock-output-names”字符串数组属性。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *of_clk_get_parent_name(<span class="keyword">struct</span> device_node *np, <span class="keyword">int</span> index)  </span><br><span class="line">&#123;  </span><br><span class="line">        <span class="keyword">struct</span> of_phandle_args clkspec;  </span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *clk_name;  </span><br><span class="line">        <span class="keyword">int</span> rc;  </span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span>)  </span><br><span class="line">                <span class="keyword">return</span> NULL;  </span><br><span class="line"> </span><br><span class="line">        rc = of_parse_phandle_with_args(np, <span class="string">"clocks"</span>, <span class="string">"#clock-cells"</span>, index,  </span><br><span class="line">                                        &amp;clkspec);  </span><br><span class="line">        <span class="keyword">if</span> (rc)  </span><br><span class="line">                <span class="keyword">return</span> NULL;  </span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (of_property_read_string_index(clkspec.np, <span class="string">"clock-output-names"</span>,  </span><br><span class="line">                                  clkspec.args_count ? clkspec.args[<span class="number">0</span>] : <span class="number">0</span>,  </span><br><span class="line">                                          &amp;clk_name) &lt; <span class="number">0</span>)  </span><br><span class="line">                clk_name = clkspec.np-&gt;name;  </span><br><span class="line"> </span><br><span class="line">        of_node_put(clkspec.np);  </span><br><span class="line">        <span class="keyword">return</span> clk_name;  </span><br><span class="line">&#125;  </span><br><span class="line">EXPORT_SYMBOL_GPL(of_clk_get_parent_name);</span><br></pre></td></tr></table></figure></p>
<p><strong>static inline bool of_property_read_bool(const struct device_node <em>np, const char </em>propname);</strong></p>
<p>如果设备结点np含有propname属性，则返回true，否则返回false。一般用于检查空属性是否存在。</p>
<p><strong>void __iomem <em>of_iomap(struct device_node </em>node, int index);</strong><br>通过设备结点直接进行设备内存区间的 ioremap()，index是内存段的索引。若设备结点的reg属性有多段，可通过index标示要ioremap的是哪一段，只有1段的情况，index为0。采用Device Tree后，大量的设备驱动通过of_iomap()进行映射，而不再通过传统的ioremap。</p>
<p><strong>unsigned int irq_of_parse_and_map(struct device_node *dev, int index);</strong><br>透过Device Tree或者设备的中断号，实际上是从.dts中的interrupts属性解析出中断号。若设备使用了多个中断，index指定中断的索引号。<br>还有一些OF API，这里不一一列举，具体可参考include/linux/of.h头文件。</p>
<h2 id="高通Android源码中dts文件">高通Android源码中dts文件</h2><h3 id="AndroidBoard-mk">AndroidBoard.mk</h3><p>Android编译过程（如想了解更多可参考：<a href="http://huaqianlee.me/2015/07/11/Android/Android%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3%E4%B9%8B%E4%B8%80/" target="_blank" rel="external">Android编译过程详解</a>）中会解析到device\qcom\msm8916_32\AndroidBoard.mk，此文件中选择了kernel的默认配置文件，如下：<br><figure class="highlight mk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># device\qcom\msm8916_32\AndroidBoard.mk</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#----------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Compile (L)ittle (K)ernel bootloader and the nandwrite utility</span></span><br><span class="line"><span class="comment">#----------------------------------------------------------------------</span></span><br><span class="line">ifneq ($(strip $(TARGET_NO_BOOTLOADER)),true)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Compile</span></span><br><span class="line">include bootable/bootloader/lk/AndroidBoot.mk</span><br><span class="line"></span><br><span class="line">$(INSTALLED_BOOTLOADER_MODULE): $(TARGET_EMMC_BOOTLOADER) | $(ACP)</span><br><span class="line">    $(transform-prebuilt-to-target)</span><br><span class="line">$(BUILT_TARGET_FILES_PACKAGE): $(INSTALLED_BOOTLOADER_MODULE)</span><br><span class="line"></span><br><span class="line">droidcore: $(INSTALLED_BOOTLOADER_MODULE)</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line"><span class="comment">#----------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Compile Linux Kernel</span></span><br><span class="line"><span class="comment">#----------------------------------------------------------------------</span></span><br><span class="line">ifeq ($(KERNEL_DEFCONFIG),)</span><br><span class="line">    KERNEL_DEFCONFIG := msm8916_defconfig  //选择msm8916_defconfig文件为默认配置文件</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line">include kernel/AndroidKernel.mk</span><br><span class="line"></span><br><span class="line">$(INSTALLED_KERNEL_TARGET): $(TARGET_PREBUILT_KERNEL) | $(ACP)</span><br><span class="line">    $(transform-prebuilt-to-target)</span><br></pre></td></tr></table></figure></p>
<h3 id="msm8916_defconfig">msm8916_defconfig</h3><p>此文件中主要是一些编译开关，包括dts文件的编译开关，如下：<br><figure class="highlight mk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># kernel\arch\arm\configs\msm8916_defconfig</span></span><br><span class="line">...</span><br><span class="line"><span class="constant">CONFIG_ARCH_MSM</span>=y</span><br><span class="line"><span class="constant">CONFIG_ARCH_MSM8916</span>=y  // dts文件的编译开关，当然也在其他地方用到，如加载板级文件：obj-<span class="variable">$(CONFIG_ARCH_MSM8916)</span> += board-8916.o</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<h3 id="Makefile">Makefile</h3><p>dts文件目录的mk文件决定需要加载哪些dts文件，这些文件最终打包到dt.img，再经由mkbootimg工具和其他镜像一起打包到boot.img。关键源码如下：<br><figure class="highlight mk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># kernel\arch\arm\boot\dts\qcom\Makefile</span></span><br><span class="line">...</span><br><span class="line">// 我们的代码针对每一个项目新建了一个dts文件，然后通过此文件去include了相关dts文件，所以下面都被屏蔽掉了</span><br><span class="line">dtb-$(CONFIG_ARCH_MSM8916) += msm8916-qrd-skuh-$(OEM_PROJECT_NAME).dtb  </span><br><span class="line"><span class="comment">#msm8916-sim.dtb</span></span><br><span class="line"><span class="comment">#msm8916-rumi.dtb</span></span><br><span class="line"><span class="comment">#msm8916-cdp.dtb</span></span><br><span class="line"><span class="comment">#msm8916-cdp-smb1360.dtb</span></span><br><span class="line"><span class="comment">#msm8916-mtp.dtb</span></span><br><span class="line"><span class="comment">#msm8916-512mb-mtp.dtb</span></span><br><span class="line"><span class="comment">#msm8916-mtp-smb1360.dtb</span></span><br><span class="line"><span class="comment">#msm8916-512mb-mtp-smb1360.dtb</span></span><br><span class="line"><span class="comment">#msm8916-512mb-qrd-skui.dtb</span></span><br><span class="line"><span class="comment">#msm8916-qrd-skuh.dtb</span></span><br><span class="line"><span class="comment">#msm8916-qrd-skuhf.dtb</span></span><br><span class="line"><span class="comment">#msm8916-qrd-skui.dtb</span></span><br><span class="line"><span class="comment">#msm8916-512mb-qrd-skuh.dtb</span></span><br><span class="line"><span class="comment">#msm8939-sim.dtb</span></span><br><span class="line"><span class="comment">#msm8939-rumi.dtb</span></span><br><span class="line"><span class="comment">#msm8939-qrd-skuk.dtb</span></span><br><span class="line"><span class="comment">#msm8939-cdp.dtb</span></span><br><span class="line"><span class="comment">#msm8939-cdp-smb1360.dtb</span></span><br><span class="line"><span class="comment">#msm8939-mtp.dtb</span></span><br><span class="line"><span class="comment">#msm8939-mtp-smb1360.dtb</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<h3 id="dts中的platform_info">dts中的platform info</h3><p>msm8916-cdp.dts文件中定义平台信息，如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># kernel\arch\arm\boot\dts\qcom\msm8916-cdp.dts&#10;#include &#34;msm8916-cdp.dtsi&#34;&#10;#include &#34;msm8916-memory.dtsi&#34;&#10;&#10;/ &#123;&#10;    model = &#34;Qualcomm Technologies, Inc. MSM 8916 CDP&#34;;&#10;    compatible = &#34;qcom,msm8916-cdp&#34;, &#34;qcom,msm8916&#34;, &#34;qcom,cdp&#34;;&#10;    qcom,board-id = &#60;1 0&#62;;&#10;&#125;;&#10;...</span><br></pre></td></tr></table></figure></p>
<p>不过我们在每个项目的dts文件中重新定义了平台信息，如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># kernel\arch\arm\boot\dts\qcom\msm8916-qrd-skuh-$(OEM_PROJECT_NAME).dts &#10;#include &#34;msm8916-qrd-skuh.dtsi&#34;&#10;#include &#34;msm8916-memory.dtsi&#34;&#10;&#10;/ &#123;&#10;    model = &#34;Qualcomm Technologies, Inc. MSM 8916 QRD SKUH changcheng l783&#34;;&#10;    compatible = &#34;qcom,msm8916-qrd-skuh&#34;, &#34;qcom,msm8916-qrd&#34;, &#34;qcom,msm8916&#34;, &#34;qcom,qrd&#34;;&#10;    qcom,board-id = &#60;0x1000b 0&#62; , &#60;0x1000b 4&#62;;&#10;&#125;;&#10;...</span><br></pre></td></tr></table></figure></p>
<h3 id="Reference">Reference</h3><p>我的这篇博文只是写了一些基本的东西，主要参考下面这些文档，并且很多内容直接翻译自下面的文档，如果想了解更多请查阅如下引用文档：<br><a href="http://pan.baidu.com/s/1c0mBcek" target="_blank" rel="external">kernel\Documentation\devicetree</a>：<em>源码中的文档，很有参考价值，其实需要的基本能在里面找到，我已上传至百度云，可以click下载查看</em><br><a href="http://devicetree.org/Device_Tree_Usage" target="_blank" rel="external">http://devicetree.org/Device_Tree_Usage</a> ：<em>很多内容译自此处</em><br><a href="http://pan.baidu.com/s/1c0c195I" target="_blank" rel="external">Power_ePAPR_APPROVED_v1.0.pdf</a>：<em>进阶文档，因为官网总是不能成功访问，所以在我百度网盘存了一份，分享给大家</em><br><a href="http://blog.csdn.net/21cnbao/article/details/8457546" target="_blank" rel="external">http://blog.csdn.net/21cnbao/article/details/8457546</a> </p>
]]></content>
    <summary type="html">
    <![CDATA[<p>刚开始接触Android源码的时候，发现在kernel里面多了一种dts文件，因为当初自学Linux时和在第一家公司做物联网模型时都是用的比较老的内核，内核代码还比较混乱，没有采用dts这种方便简洁的格式。后面才知道这是因为Linus的一句”this whole arm thing is a fucking pain in ass“促进改革的，记得Linux早期代码里面板级细节都是在C文件中描述的，代码就显得十分臃肿和混乱。如此优化之后就显得简洁多了，并且也更易于学习、移植。<br>　<br>今天准备专门来分析一下内核设备树，主要按照如下三个方向来分析：</p>
<ul>
<li>Device Tree组成及用法；</li>
<li>DTS文件解析常用api介绍；</li>
<li>DTS文件的编译；</li>
<li>高通Android源码中dts文件引用流程；]]>
    
    </summary>
    
      <category term="Qualcomm" scheme="http://huaqianlee.me/tags/Qualcomm/"/>
    
      <category term="dts文件" scheme="http://huaqianlee.me/tags/dts%E6%96%87%E4%BB%B6/"/>
    
      <category term="kernel" scheme="http://huaqianlee.me/tags/kernel/"/>
    
      <category term="源码分析" scheme="http://huaqianlee.me/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="译文" scheme="http://huaqianlee.me/tags/%E8%AF%91%E6%96%87/"/>
    
      <category term="Android" scheme="http://huaqianlee.me/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[高通平台Android源码bootloader分析之sbl1(三)]]></title>
    <link href="http://huaqianlee.me/2015/08/18/Android/%E9%AB%98%E9%80%9A%E5%B9%B3%E5%8F%B0Android%E6%BA%90%E7%A0%81bootloader%E5%88%86%E6%9E%90%E4%B9%8Bsbl1-%E4%B8%89/"/>
    <id>http://huaqianlee.me/2015/08/18/Android/高通平台Android源码bootloader分析之sbl1-三/</id>
    <published>2015-08-17T16:48:26.000Z</published>
    <updated>2015-09-24T17:00:33.483Z</updated>
    <content type="html"><![CDATA[<p><a href="http://huaqianlee.me/2015/08/15/Android/%E9%AB%98%E9%80%9A%E5%B9%B3%E5%8F%B0Android%E6%BA%90%E7%A0%81bootloader%E5%88%86%E6%9E%90%E4%B9%8Bsbl1-%E4%B8%80/" target="_blank" rel="external">高通平台Android源码bootloader分析之sbl1(一)</a><br><a href="http://huaqianlee.me/2015/08/15/Android/%E9%AB%98%E9%80%9A%E5%B9%B3%E5%8F%B0Android%E6%BA%90%E7%A0%81bootloader%E5%88%86%E6%9E%90%E4%B9%8Bsbl1-%E4%BA%8C/" target="_blank" rel="external">高通平台Android源码bootloader分析之sbl1(二)</a><br><a href="http://huaqianlee.me/2015/08/18/Android/%E9%AB%98%E9%80%9A%E5%B9%B3%E5%8F%B0Android%E6%BA%90%E7%A0%81bootloader%E5%88%86%E6%9E%90%E4%B9%8Bsbl1-%E4%B8%89/" target="_blank" rel="external">高通平台Android源码bootloader分析之sbl1(三)</a></p>
<p>前两篇博文分析了启动流程、代码流程、cdt，接下来就分析另外几个需要格外关注的部分。</p>
<h2 id="log系统">log系统</h2><p>sbl1中的log系统也是sbl1部分调试会经常接触得部分高通平台在sbl中做的log系统并不是很强大， 但是对于我们调试已经远远足够了。</p>
<h3 id="sbl1_boot_logger_init">sbl1_boot_logger_init</h3><p>sbl1_boot_logger_init是log系统的初始化函数，被sbl1_main_ctl函数调用（详细参考：高通平台Android源码bootloader分析之sbl1(一)），其源码如下：<br><a id="more"></a><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor"># boot_images\core\boot\secboot3\hw\msm8916\sbl1\sbl1_mc.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sbl1_boot_logger_init</span><span class="params">(  boot_log_init_data *boot_log_data,  boot_pbl_shared_data_type *pbl_shared)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="comment">/*initialize boot logger*/</span></span><br><span class="line">  boot_log_init(boot_log_data); </span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Write PBL timestamp milestones into beginning of log */</span></span><br><span class="line">  boot_pbl_log_milestones(pbl_shared);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Set the reference time to 0 as the start of boot*/</span></span><br><span class="line">  boot_log_set_ref_time(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Add SBL start entry using stored time from beginning of sbl1_main_ctl */</span></span><br><span class="line">  boot_log_message_raw(<span class="string">"SBL1, Start"</span>,</span><br><span class="line">                       sbl_start_time,</span><br><span class="line">                       LOG_MSG_TYPE_BOOT,</span><br><span class="line">                       NULL);</span><br><span class="line"></span><br><span class="line">&#125;<span class="comment">/* sbl1_boot_logger_init */</span></span><br></pre></td></tr></table></figure></p>
<h3 id="boot_log_init">boot_log_init</h3><p>boot_log_init被上面函数调用，位于boot_logger.c中，log的打印函数也全在此文件，其源码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#boot_images\core\boot\secboot3\src\boot_logger.c</span></span><br><span class="line">另几个<span class="built_in">log</span>相关的文件，与boot_logger.c同一路径：</span><br><span class="line"> boot_logger_uart.c</span><br><span class="line"> boot_logger_ram.c</span><br><span class="line"> boot_logger_timer.<span class="function">c</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title">boot_log_init</span><span class="params">(boot_log_init_data *init_data)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="comment">/*we must first set meta info becasue boot_log_init_ram and</span><br><span class="line">   * boot_log_init_timer will use the meta info structure*/</span></span><br><span class="line">  boot_log_set_meta_info(init_data-&gt;meta_info_start);</span><br><span class="line">  boot_log_init_ram(init_data); <span class="comment">// 初始化ram log</span></span><br><span class="line">  boot_init_timer(init_data); <span class="comment">// 初始化时钟</span></span><br><span class="line">  boot_log_init_uart();<span class="comment">// 初始化串口</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Write image version values out to the log. */</span></span><br><span class="line">  boot_log_image_version();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Write the Boot Config register out to the log. */</span></span><br><span class="line">  boot_log_boot_config_register();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Write the Core 0 Apps frequency out to the log. */</span></span><br><span class="line">  boot_log_apps_frequency(<span class="number">0</span>);</span><br><span class="line">&#125;<span class="comment">/* boot_log_init */</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#常用的两个打印函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">boot_log_message</span><span class="params">(<span class="keyword">char</span> * message)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title">boot_log_message_optional_data</span><span class="params">(<span class="keyword">char</span> * message,<span class="keyword">char</span> * optional_data)</span></span></span><br></pre></td></tr></table></figure></p>
<h3 id="log用法">log用法</h3><p>打印log时可以打印到串口和ram，如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 直接使用如下两个函数即可</span></span><br><span class="line">void boot_<span class="built_in">log</span>_message(char * message)</span><br><span class="line">void boot_<span class="built_in">log</span>_message_optional_data(char * message,char * optional_data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印变量小技巧</span></span><br><span class="line">static char error_message[BOOT_ERROR_MSG_LEN];</span><br><span class="line"></span><br><span class="line">snprintf(error_message, BOOT_ERROR_MSG_LEN, <span class="string">"Error code %lx at %s Line %lu var = %d"</span>, err_code, filename_ptr, line，var);   </span><br><span class="line">boot_<span class="built_in">log</span>_message(error_message);</span><br></pre></td></tr></table></figure></p>
<h2 id="下载模式">下载模式</h2><p>高通目前主要支持两种下载模式：紧急下载模式和普通下载模式。</p>
<p>其代码我就不去详细分析了，只来看一下几个关键函数，主要源码路径：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">boot_images\core\boot\secboot3\src\boot_dload.c</span><br><span class="line">boot_images\core\boot\secboot3\hw\msm8916\sbl1\sbl1_target.c</span><br><span class="line">boot_images\core\boot\secboot3\hw\msm8916\sbl1\sbl1_mc.c</span><br></pre></td></tr></table></figure></p>
<h3 id="boot_dload_check">boot_dload_check</h3><p>boot_dload_check函数检测是否需要进入QPST下载，然后进入下载模式。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor"># boot_images\core\boot\secboot3\src\boot_dload.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">boot_dload_check</span><span class="params">(   bl_shared_data_type *bl_shared_data )</span></span><br><span class="line"></span>&#123;</span><br><span class="line"></span><br><span class="line">  boolean status = FALSE;</span><br><span class="line">  <span class="comment">/* Check whether USB D+ line is grounded. If it is, then enter</span><br><span class="line">     PBL Download mode */</span></span><br><span class="line">  <span class="keyword">if</span>(boot_usb_al_check_for_pbl_dload(<span class="number">0</span>))</span><br><span class="line">  &#123;</span><br><span class="line">    boot_dload_transition_pbl_forced_dload(); <span class="comment">//进入PBL下载模式</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Determine if the downloader should be entered at this time,</span><br><span class="line">     instead of continuing with the normal boot process. */</span></span><br><span class="line">  <span class="keyword">if</span> ( boot_dload_entry( ) == TRUE )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* Check the UEFI ram dump cookie, we enter download mode</span><br><span class="line">       only if UEFI ram dump cookie is NOT set*/</span></span><br><span class="line">    <span class="keyword">if</span> ( !( boot_shared_imem_cookie_ptr != NULL &amp;&amp;</span><br><span class="line">            boot_shared_imem_cookie_ptr-&gt;uefi_ram_dump_magic == </span><br><span class="line">            UEFI_CRASH_DUMP_MAGIC_NUM ) )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Enter downloader for QPST */</span>  </span><br><span class="line">      sbl_dload_entry();  <span class="comment">// 进入QPST下载模式，即普通下载模式</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* Check if PMIC warm reset occured */</span></span><br><span class="line">  BL_VERIFY((boot_pm_pon_warm_reset_status(<span class="number">0</span>, &amp;status) == PM_ERR_FLAG__SUCCESS), BL_ERR_SBL);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* If status is true, set abonormal reset cookie and </span><br><span class="line">     clear the warm reset status in PMIC */</span></span><br><span class="line">  <span class="keyword">if</span>(status)</span><br><span class="line">  &#123; </span><br><span class="line">    <span class="keyword">if</span> ( boot_shared_imem_cookie_ptr != NULL )</span><br><span class="line">       boot_shared_imem_cookie_ptr-&gt;abnormal_reset_occurred = ABNORMAL_RESET_ENABLED;</span><br><span class="line"></span><br><span class="line">    BL_VERIFY((boot_pm_pon_warm_reset_status_clear(<span class="number">0</span>) == PM_ERR_FLAG__SUCCESS), BL_ERR_SBL);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* boot_dload_check() */</span></span><br></pre></td></tr></table></figure></p>
<h3 id="紧急下载模式">紧急下载模式</h3><p>紧急下载模式进入又分为两种情况：</p>
<ul>
<li>自动进入：裸片或者sbl1异常，系统自动进入紧急下载模式；</li>
<li>手动进入：<ul>
<li>硬件下拉某一GPIO，PBL阶段检测到此GPIO则进入紧急下载模式。</li>
<li>软件设置magic numbers，热重启，PBL检测到magic numbers后进入紧急下载模式。</li>
</ul>
</li>
</ul>
<h4 id="boot_dload_transition_pbl_forced_dload">boot_dload_transition_pbl_forced_dload</h4><p>boot_dload_transition_pbl_forced_dload函数由上boot_dload_check函数调用，其设置magic numbers，然后重启，当PBL检测到设置的magic numbers则会强制进入下载模式。源码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor"># boot_images\core\boot\secboot3\src\boot_dload.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">boot_dload_transition_pbl_forced_dload</span><span class="params">( <span class="keyword">void</span> )</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="comment">/* PBL uses the last four bits of BOOT_MISC_DETECT to trigger forced download.</span><br><span class="line">     Preserve the other bits of the register. */</span></span><br><span class="line"></span><br><span class="line">  uint32 register_value = </span><br><span class="line">    HWIO_TCSR_BOOT_MISC_DETECT_INM(HWIO_TCSR_BOOT_MISC_DETECT_RMSK);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Clear the PBL masked area and then apply HS_USB value */</span></span><br><span class="line">  register_value &amp;= ~(FORCE_DLOAD_MASK);</span><br><span class="line">  register_value |= FORCE_DLOAD_HS_USB_MAGIC_NUM;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Write the new value back out to the register */</span></span><br><span class="line">  HWIO_TCSR_BOOT_MISC_DETECT_OUTM(FORCE_DLOAD_MASK,</span><br><span class="line">                                  register_value);</span><br><span class="line"></span><br><span class="line">  boot_hw_reset(BOOT_WARM_RESET_TYPE);</span><br><span class="line">&#125; <span class="comment">/* boot_dload_transition_pbl_forced_dload() */</span></span><br></pre></td></tr></table></figure></p>
<h3 id="普通下载模式">普通下载模式</h3><p>一般情况下，在通过PBL下载了软件后 ，除非device挂掉，不会再通过PBL进入紧急下载，这时会通过sbl对软件更新。在上boot_dload_check函数中会检查USB D+是否接地，是否了设置下载模式cookie（通过boot_dload_set_cookie()设置），如果皆为否，则进入普通下载模式。</p>
<h4 id="boot_dload_set_cookie">boot_dload_set_cookie</h4><p>当sbl1发生异常时，sbl_error_handler函数（位于sbl1_mc.c）会调用此函数设置cookie，此函数比较简单，源码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor"># boot_images\core\boot\secboot3\src\boot_dload.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">boot_dload_set_cookie</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  HWIO_TCSR_BOOT_MISC_DETECT_OUTM(SBL_DLOAD_MODE_BIT_MASK,</span><br><span class="line">                                  SBL_DLOAD_MODE_BIT_MASK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="sbl_dload_entry">sbl_dload_entry</h4><p>sbl_dload_entry函数指针默认指向紧急下载入口boot_dload_transition_pbl_forced_dload函数，由PBL通过firehose协议实现下载。如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor"># boot_images\core\boot\secboot3\hw\msm8916\sbl1\sbl1_target.c</span></span><br><span class="line"><span class="keyword">void</span> (*sbl_dload_entry)(<span class="keyword">void</span>) = boot_dload_transition_pbl_forced_dload;</span><br></pre></td></tr></table></figure></p>
<h4 id="sbl1_dload_entry">sbl1_dload_entry</h4><p>不过如果没有定义sbl错误时进入PBL错误处理的宏，sbl_dload_entry函数指针将被重定向到sbl1_dload_entry函数，其在sbl1中直接通过sahara协议下载。如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor"># boot_images\core\boot\secboot3\hw\msm8916\sbl1\sbl1_mc.c</span></span><br><span class="line"><span class="comment">/*DLOAD flag for SBL1 to enter PBL error handler*/</span></span><br><span class="line"><span class="preprocessor">#ifdef BOOT_ENTER_PBL_DLOAD_ON_SBL_ERROR</span></span><br><span class="line">  <span class="keyword">static</span> boot_boolean edload_flag = TRUE;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="keyword">static</span> boot_boolean edload_flag = FALSE;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sbl1_post_ddr_init</span><span class="params">(bl_shared_data_type *bl_shared_data)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">...  </span><br><span class="line">  <span class="keyword">if</span> (edload_flag != TRUE)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* Update the dload entry to sbl1 sahara dload entry function */</span></span><br><span class="line">    sbl_dload_entry = sbl1_dload_entry;</span><br><span class="line">  &#125; </span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor"># boot_images\core\boot\secboot3\hw\msm8916\sbl1\sbl1_target.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sbl1_dload_entry</span> <span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">static</span> uint32 dload_entry_count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  dload_entry_count++; </span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Only execute the pre-dload procedures the first time we try to enter</span><br><span class="line">   * dload in case there is an error within these procedures. */</span></span><br><span class="line">  <span class="keyword">if</span>( dload_entry_count == <span class="number">1</span> &amp;&amp; &amp;bl_shared_data != NULL )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* Entering dload routine for the first time */</span></span><br><span class="line">    boot_do_procedures( &amp;bl_shared_data, sbl1_pre_dload_procs );</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Enter boot Sahara */</span></span><br><span class="line">  boot_dload_transition_enter_sahara();</span><br><span class="line">  </span><br><span class="line">&#125;<span class="comment">/* sbl_dload_entry() */</span></span><br></pre></td></tr></table></figure></p>
<h2 id="升级模式">升级模式</h2><p>上面的下载模式对于开发来说不是很方便，接下来分析一下更适合开发、生产的下载模式，也分为两种，如下：</p>
<ol>
<li>通过组合按键进入：比如power键+音量下键进入PBL紧急下载。</li>
<li>通过命令进入：开机后连接USB， 通过adb reboot edl/dload 进入PBL紧急下载或sbl普通下载。</li>
</ol>
<p>未完待续。。。。</p>
<blockquote>
<p>由于最近时间比较紧张，需要做的事比较多，并且余下的部分也没怎么接触过，对于我来说也不是很重要，所以剩余部分就留在以后有空再来分析了</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="http://huaqianlee.me/2015/08/15/Android/%E9%AB%98%E9%80%9A%E5%B9%B3%E5%8F%B0Android%E6%BA%90%E7%A0%81bootloader%E5%88%86%E6%9E%90%E4%B9%8Bsbl1-%E4%B8%80/">高通平台Android源码bootloader分析之sbl1(一)</a><br><a href="http://huaqianlee.me/2015/08/15/Android/%E9%AB%98%E9%80%9A%E5%B9%B3%E5%8F%B0Android%E6%BA%90%E7%A0%81bootloader%E5%88%86%E6%9E%90%E4%B9%8Bsbl1-%E4%BA%8C/">高通平台Android源码bootloader分析之sbl1(二)</a><br><a href="http://huaqianlee.me/2015/08/18/Android/%E9%AB%98%E9%80%9A%E5%B9%B3%E5%8F%B0Android%E6%BA%90%E7%A0%81bootloader%E5%88%86%E6%9E%90%E4%B9%8Bsbl1-%E4%B8%89/">高通平台Android源码bootloader分析之sbl1(三)</a></p>
<p>前两篇博文分析了启动流程、代码流程、cdt，接下来就分析另外几个需要格外关注的部分。</p>
<h2 id="log系统">log系统</h2><p>sbl1中的log系统也是sbl1部分调试会经常接触得部分高通平台在sbl中做的log系统并不是很强大， 但是对于我们调试已经远远足够了。</p>
<h3 id="sbl1_boot_logger_init">sbl1_boot_logger_init</h3><p>sbl1_boot_logger_init是log系统的初始化函数，被sbl1_main_ctl函数调用（详细参考：高通平台Android源码bootloader分析之sbl1(一)），其源码如下：<br>]]>
    
    </summary>
    
      <category term="Qualcomm" scheme="http://huaqianlee.me/tags/Qualcomm/"/>
    
      <category term="源码分析" scheme="http://huaqianlee.me/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="Android" scheme="http://huaqianlee.me/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[高通平台Android源码bootloader分析之sbl1(二)]]></title>
    <link href="http://huaqianlee.me/2015/08/15/Android/%E9%AB%98%E9%80%9A%E5%B9%B3%E5%8F%B0Android%E6%BA%90%E7%A0%81bootloader%E5%88%86%E6%9E%90%E4%B9%8Bsbl1-%E4%BA%8C/"/>
    <id>http://huaqianlee.me/2015/08/15/Android/高通平台Android源码bootloader分析之sbl1-二/</id>
    <published>2015-08-15T12:44:46.000Z</published>
    <updated>2015-09-24T17:00:40.054Z</updated>
    <content type="html"><![CDATA[<p><a href="http://huaqianlee.me/2015/08/15/Android/%E9%AB%98%E9%80%9A%E5%B9%B3%E5%8F%B0Android%E6%BA%90%E7%A0%81bootloader%E5%88%86%E6%9E%90%E4%B9%8Bsbl1-%E4%B8%80/" target="_blank" rel="external">高通平台Android源码bootloader分析之sbl1(一)</a><br><a href="http://huaqianlee.me/2015/08/15/Android/%E9%AB%98%E9%80%9A%E5%B9%B3%E5%8F%B0Android%E6%BA%90%E7%A0%81bootloader%E5%88%86%E6%9E%90%E4%B9%8Bsbl1-%E4%BA%8C/" target="_blank" rel="external">高通平台Android源码bootloader分析之sbl1(二)</a><br><a href="http://huaqianlee.me/2015/08/18/Android/%E9%AB%98%E9%80%9A%E5%B9%B3%E5%8F%B0Android%E6%BA%90%E7%A0%81bootloader%E5%88%86%E6%9E%90%E4%B9%8Bsbl1-%E4%B8%89/" target="_blank" rel="external">高通平台Android源码bootloader分析之sbl1(三)</a></p>
<p>在上一篇博文中主要描述了启动流程，及代码执行流程，并重点介绍了一下我重点关注的部分。这个sbl部分也算有点庞大，我们没有精力也没有必要去分析全部，所以接下来就来分析一下sbl1中另外几个需要格外关注的部分：</p>
<ul>
<li>CDT ：主要提供平台设备数据</li>
<li>log system：log日志系统，当然没有kernel里面那么强大了</li>
<li>download：代码下载烧写实现</li>
<li>ramdump：异常信息dump<br>　<br>本篇博文就先来分析一下CDT， 其他部分后面再分析。<a id="more"></a>
<h2 id="CDT">CDT</h2>CDT主要提供Platform ID、ddr硬件配置等平台设备数据。很多module利用这些信息去减少依赖及执行动态初始化。CDT通常被厂家写入EEPROM中，如没有eeprom则会在编译bootloader时链入。<br>　<br>sbl中主要涉及到如下关键文件：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">boot_images\core\boot\secboot3\hw\msm8916\boot_cdt_array.c // config_data_table配置表定义</span><br><span class="line">boot_images\core\systemdrivers\platforminfo\src\PlatformInfo.c</span><br><span class="line">boot_images\core\boot\secboot3\scripts\cdt_generator.py</span><br><span class="line">boot_images\core\boot\secboot3\scripts\jedec_lpddr3_single_channel.xml</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="boot程序加载CDT">boot程序加载CDT</h3><p>对于CDT，boot程序主要有如下动作：</p>
<ol>
<li>sbl1校验eMMC的boot分区中的CDT分区，如果ok，则加载CDT镜像，如果不ok，则执行第2步；</li>
<li>sbl1从sbl1.mbn中加载默认cdt分区表（config_data_table[]）；</li>
<li>sbl1通过SMEM将平台信息传递到lk；sbl1 - SMEM_HW_SW_BUILD_ID，lk - SMEM_BOARD_INFO_LOCATION.</li>
<li>lk获取平台信息，加载dt头，然后搜寻相应的dt入口；</li>
<li>lk通过正确的dt入口地址跳转到kernel。</li>
</ol>
<h4 id="关键函数：">关键函数：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#sbl1</span></span><br><span class="line">boot_updat_config_data_table（boot_images\core\boot\secboot3\src\boot_config_emmc.c）</span><br><span class="line"><span class="comment">#lk</span></span><br><span class="line">dev_tree_get_entry_info(bootable\bootloader\lk\platform\msm_shared\dev_tree.c)</span><br></pre></td></tr></table></figure>
<h4 id="关键枚举：">关键枚举：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#boot_images\core\api\systemdrivers\DDIChipInfo.h</span></span><br><span class="line">DALCHIPINFO_ID_APQ8026     = <span class="number">199</span>,</span><br><span class="line">DALCHIPINFO_ID_MSM8926     = <span class="number">200</span>,</span><br><span class="line">DALCHIPINFO_ID_MSM8326     = <span class="number">205</span>,</span><br><span class="line">DALCHIPINFO_ID_MSM8916     = <span class="number">206</span>,</span><br><span class="line">DALCHIPINFO_ID_MSM8994     = <span class="number">207</span>,</span><br><span class="line"><span class="comment">#boot_images\core\api\systemdrivers\PlatformInfoDefs.h</span></span><br><span class="line">DALPLATFORMINFO_TYPE_SURF         = <span class="number">0</span>x01,  /**&lt; Target is a SURF device. */</span><br><span class="line">DALPLATFORMINFO_TYPE_CDP          = DALPLATFORMINFO_TYPE_SURF,  /**&lt; Target is a CDP (aka SURF) device. */</span><br><span class="line">DALPLATFORMINFO_TYPE_MTP_MSM      = <span class="number">0</span>x08,  /**&lt; Target is a MSM MTP device. */</span><br><span class="line">DALPLATFORMINFO_TYPE_QRD          = <span class="number">0</span>x0B,  /**&lt; Target is a QRD device. */</span><br></pre></td></tr></table></figure>
<h4 id="DT头">DT头</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#kernel\arch\arm\boot\dts\qcom\msm8916-cdp.dts&#10;/ &#123;&#10;  model = &#34;Qualcomm Technologies, Inc. MSM 8916 CDP&#34;;&#10;  compatible = &#34;qcom,msm8916-cdp&#34;, &#34;qcom,msm8916&#34;, &#34;qcom,cdp&#34;;&#10;  qcom,board-id = &#60;1 0&#62;;// id&#20026;0x01&#21017;&#20026;cdp&#35774;&#22791;&#65292;&#19982;&#19979;cdt&#25551;&#36848;xml&#20013;&#23545;&#24212;&#10;&#125;;&#10;#kernel\arch\arm\boot\dts\qcom\msm8916-mtp.dts&#10;/ &#123;&#10;  model = &#34;Qualcomm Technologies, Inc. MSM 8916 MTP&#34;;&#10;  compatible = &#34;qcom,msm8916-mtp&#34;, &#34;qcom,msm8916&#34;, &#34;qcom, mtp&#34;;&#10;  qcom,board-id = &#60;8 0&#62;; // id&#20026;0x08&#21017;&#20026;mtp&#35774;&#22791;&#10;&#125;;&#10;#kernel\arch\arm\boot\dts\qcom\msm8916-qrd.dts&#10;/ &#123;&#10;  model = &#34;Qualcomm Technologies, Inc. MSM 8916 QRD&#34;;&#10;  compatible = &#34;qcom,msm8916-qrd&#34;, &#34;qcom,msm8916&#34;, &#34;qcom, qrd&#34;;&#10;  qcom,board-id = &#60;11 0&#62;; // id&#20026;0x0b&#21017;&#20026;qrd&#35774;&#22791;&#10;&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>dt.img的格式，参考dtbtool.txt和bootable\bootloader\lk\platform\msm_shared\smem.h</p>
</blockquote>
<h4 id="CDT描述的xml文件">CDT描述的xml文件</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#boot_images\core\boot\secboot3\scripts\jedec_lpddr3_single_channel.xml</span><br><span class="line">      <span class="tag">&lt;<span class="title">device</span> <span class="attribute">id</span>=<span class="value">"cdb0"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">props</span> <span class="attribute">name</span>=<span class="value">"platform_id"</span> <span class="attribute">type</span>=<span class="value">"DALPROP_ATTR_TYPE_BYTE_SEQ"</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">          /*byte0 - platform id版本</span><br><span class="line">             byte1 - platform id，因此此为mtp设备</span><br><span class="line">             byte2 - platform id硬件版本*/         </span><br><span class="line">          0x03, 0x08, 0x01, 0x00, 0x00, 0x00, end </span><br><span class="line">        </span><br><span class="line">        <span class="tag">&lt;/<span class="title">props</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="title">device</span>&gt;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>上述xml中设备对应的结构体包如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> PACKED <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">  uint8                 nVersion;</span><br><span class="line">  uint8                 nPlatform;　　　　　 <span class="comment">//平台id，用于高通不同平台，不能修改。</span></span><br><span class="line">  uint8                 nHWVersionMajor;     <span class="comment">//硬件版本号</span></span><br><span class="line">  uint8                 nHWVersionMinor;</span><br><span class="line">  uint8                 nSubtype;　　　　<span class="comment">//　默认为０，可以用来区分项目</span></span><br><span class="line">  uint8                 nNumKVPS;</span><br><span class="line">  PlatformInfoKVPSCDTType  aKVPS[];</span><br><span class="line">&#125; PlatformInfoCDTType;</span><br></pre></td></tr></table></figure></p>
<h3 id="platform_info">platform info</h3><p>在上一篇博文分析的sbl执行流程中，有两个和platform info有关的两个关键函数，如下：</p>
<h4 id="boot_config_data_table_init">boot_config_data_table_init</h4><p>此函数主要初始化配置数据表，如果eeprom/emmc中存在cdt，则更新编译时链入的cdt表。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#boot_images\core\boot\secboot3\src\boot_config_data.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">boot_config_data_table_init</span><span class="params">(bl_shared_data_type* bl_shared_data)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> bootlog_buffer[BOOT_LOG_TEMP_BUFFER_SIZE];</span><br><span class="line">  uint32 bytes_read = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Reset the flash byte counter so the number of bytes read from flash</span><br><span class="line">     can be retreived later. */</span></span><br><span class="line">  boot_statistics_reset_flash_byte_counter();</span><br><span class="line"></span><br><span class="line">  boot_log_message(<span class="string">"boot_config_data_table_init, Start"</span>);</span><br><span class="line">  boot_log_start_timer();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/*populate configuration data table's info*/</span></span><br><span class="line">  config_data_table_info.size = config_data_table_size;</span><br><span class="line">  config_data_table_info.cdt_ptr = config_data_table; <span class="comment">// 定义在boot_cdt_array.c </span></span><br><span class="line"></span><br><span class="line">  boot_update_config_data_table(&amp;config_data_table_info);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/*put a pointer to the table info into sbl shared data so next sbl can access it*/</span></span><br><span class="line">  bl_shared_data-&gt;sbl_shared_data-&gt;config_data_table_info = &amp;config_data_table_info;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Retreive the number of bytes read from flash via boot statistics. */</span></span><br><span class="line">  bytes_read = boot_statistics_get_flash_byte_counter();</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Convert CDT size to string for boot logger. */</span></span><br><span class="line">  <span class="built_in">snprintf</span>(bootlog_buffer,</span><br><span class="line">           BOOT_LOG_TEMP_BUFFER_SIZE,</span><br><span class="line">           <span class="string">"(%d Bytes)"</span>,</span><br><span class="line">           bytes_read);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  boot_log_stop_timer_optional_data(<span class="string">"boot_config_data_table_init, Delta"</span>,</span><br><span class="line">                                    bootlog_buffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="config_data_table">config_data_table</h4><p>config_data_table定义了与上xml文件对应的配置表，存储在memory，用于初始化cdt，如此表存在则此表数据为最终数据。源码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor"># boot_images\core\boot\secboot3\hw\msm8916\boot_cdt_array.c</span></span><br><span class="line">uint8 config_data_table[CONFIG_DATA_TABLE_MAX_SIZE] = </span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Header */</span></span><br><span class="line"></span><br><span class="line">  <span class="number">0x43</span>, <span class="number">0x44</span>, <span class="number">0x54</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Meta data */</span></span><br><span class="line"></span><br><span class="line">  <span class="number">0x16</span>, <span class="number">0x00</span>, <span class="number">0x06</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x1C</span>, <span class="number">0x00</span>, <span class="number">0x88</span>, <span class="number">0x01</span>, </span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Block data */</span></span><br><span class="line"><span class="preprocessor">#ifdef BOOT_PRE_SILICON</span></span><br><span class="line">  <span class="preprocessor">#ifdef FEATURE_RUMI_BOOT</span></span><br><span class="line">  <span class="number">0x03</span>, <span class="number">0x0F</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="preprocessor">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="number">0x03</span>, <span class="number">0x10</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="number">0x03</span>, <span class="number">0x0B</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,<span class="comment">// platform id 等信息</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">....</span><br><span class="line"></span><br><span class="line">uint32 config_data_table_size = <span class="number">420</span>; <span class="comment">// cdt表size</span></span><br></pre></td></tr></table></figure></p>
<h4 id="sbl1_hw_platform_smem">sbl1_hw_platform_smem</h4><p>此函数主要解析cdt表获得sw-platform id，调用platform id api并传送指针到获得的id，然后调用hw_init_smem存储platform id到SMEM。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#boot_images\core\boot\secboot3\hw\msm8909\sbl1\sbl1_mc.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sbl1_hw_platform_smem</span><span class="params">(bl_shared_data_type* bl_shared_data)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    ....... </span><br><span class="line">  <span class="keyword">struct</span> cdt_info *cdt_info_ptr = (<span class="keyword">struct</span> cdt_info *)</span><br><span class="line">                          bl_shared_data-&gt;sbl_shared_data-&gt;config_data_table_info;</span><br><span class="line">  <span class="comment">/*get a pointer to platform id data from configuration data table*/</span></span><br><span class="line">  platform_id_cdb_ptr = </span><br><span class="line">              boot_get_config_data_block(cdt_info_ptr-&gt;cdt_ptr,</span><br><span class="line">                                         CONFIG_DATA_BLOCK_INDEX_V1_PLATFORM_ID,</span><br><span class="line">                                         &amp;platform_id_len);  </span><br><span class="line">  <span class="keyword">if</span>(platform_id_cdb_ptr != NULL)</span><br><span class="line">  &#123;</span><br><span class="line">    eResult = boot_DAL_DeviceAttachEx(NULL,</span><br><span class="line">                                      DALDEVICEID_PLATFORMINFO,</span><br><span class="line">                                      DALPLATFORMINFO_INTERFACE_VERSION,</span><br><span class="line">                                      &amp;phPlatform);</span><br><span class="line">    <span class="keyword">if</span> (eResult == DAL_SUCCESS) </span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/*call the following API to store the platform id to DAL and SMEM*/</span></span><br><span class="line">      boot_DalPlatformInfo_CDTConfigPostDDR(phPlatform, platform_id_cdb_ptr);      </span><br><span class="line">      boot_DAL_DeviceDetach(phPlatform);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="platform_info匹配">platform info匹配</h3><p>platform info中的platform id十分重要，lk、kernel中dts都是根据platform id及subtype id等platform info来匹配的。lk和kernel中涉及到的主要函数和代码路径如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#lk</span></span><br><span class="line">/*ootable\bootloader\lk\platform\msm_shared\smem.h */</span><br><span class="line">enum platform_subtype </span><br><span class="line"></span><br><span class="line">/*bootable\bootloader\lk\platform\msm_shared\board.c */</span><br><span class="line">static void platform_detect()</span><br><span class="line">uint32_t board_hardware_subtype(void)</span><br><span class="line">uint32_t board_hardware_id()</span><br><span class="line"></span><br><span class="line">/*bootable\bootloader\lk\platform\msm_shared\dev_tree.c*/</span><br><span class="line">int dev_tree_get_entry_info(struct dt_table *table, struct dt_entry *dt_entry_info)</span><br><span class="line"></span><br><span class="line"><span class="comment">#kernel</span></span><br><span class="line">kernel\arch\arm\kernel\setup.c</span><br><span class="line">kernel\arch\arm\boot\dts\qcom</span><br></pre></td></tr></table></figure></p>
<p>当我们在项目开发时就可以同cdt这些信息来配置不同项目，如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-------------------------------------------------------------</span><br><span class="line">  sbl1        platform subtype_id           boot_cdt_array.c</span><br><span class="line">-------------------------------------------------------------</span><br><span class="line">  lk              匹配dts                    dev_tree.c</span><br><span class="line">-------------------------------------------------------------</span><br><span class="line">  kernel     通过传入dts地址创建设备          setup.c</span><br><span class="line">-------------------------------------------------------------</span><br></pre></td></tr></table></figure></p>
<h3 id="DDR配置">DDR配置</h3><p>ddr相关的东西我很少动， 也就不深入分析了，列出几个关键函数，如果需要深入了解的话再分析。ddr初始化主要涉及3个函数，见如下load_qsee_pre_procs函数指针数组：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"> boot_procedure_func_type load_qsee_pre_procs[] = </span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Save reset register logs */</span></span><br><span class="line">  boot_save_reset_register_log,</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Initialize the flash device */</span></span><br><span class="line">  boot_flash_init,</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Copy the configure data table from eeprom */</span></span><br><span class="line">  boot_config_data_table_init, <span class="comment">// 函数一 ： 加载配置表</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Store platform id */</span></span><br><span class="line">  sbl1_hw_platform_pre_ddr,</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Configure ddr parameters based on eeprom CDT table data. */</span></span><br><span class="line">  sbl1_ddr_set_params, <span class="comment">// 函数二：配置ddr</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Initialize DDR */</span></span><br><span class="line">  (boot_procedure_func_type)sbl1_ddr_init, <span class="comment">// 函数三：初始化ddr</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*----------------------------------------------------------------------</span><br><span class="line">   Run deviceprogrammer if compiling the deviceprogrammer_ddr image.</span><br><span class="line">  ----------------------------------------------------------------------*/</span></span><br><span class="line">  boot_deviceprogrammer_ddr_main,</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Initialize SBL1 DDR ZI region, relocate boot log to DDR */</span>   </span><br><span class="line">  sbl1_post_ddr_init,</span><br><span class="line">  </span><br><span class="line">  sbl1_hw_init_secondary,</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* DDR training */</span></span><br><span class="line">  (boot_procedure_func_type)sbl1_wait_for_ddr_training,</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Initialize SBL1 DDR ZI region, relocate page table to DDR */</span></span><br><span class="line">  sbl1_post_ddr_training_init, </span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Zero out QSEE and QHEE region if needed.  This MUST be done before</span><br><span class="line">     boot_dload_dump_security_regions executes for security reasons. */</span></span><br><span class="line">  sbl1_cleanse_security_regions,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Backup QSEE and QHEE region for ramdumps taken after SBL has executed */</span></span><br><span class="line">  boot_dload_dump_security_regions,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Check to see if DLOAD mode needs to be entered */</span></span><br><span class="line">  boot_dload_check,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Last entry in the table. */</span></span><br><span class="line">  NULL </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="http://huaqianlee.me/2015/08/15/Android/%E9%AB%98%E9%80%9A%E5%B9%B3%E5%8F%B0Android%E6%BA%90%E7%A0%81bootloader%E5%88%86%E6%9E%90%E4%B9%8Bsbl1-%E4%B8%80/">高通平台Android源码bootloader分析之sbl1(一)</a><br><a href="http://huaqianlee.me/2015/08/15/Android/%E9%AB%98%E9%80%9A%E5%B9%B3%E5%8F%B0Android%E6%BA%90%E7%A0%81bootloader%E5%88%86%E6%9E%90%E4%B9%8Bsbl1-%E4%BA%8C/">高通平台Android源码bootloader分析之sbl1(二)</a><br><a href="http://huaqianlee.me/2015/08/18/Android/%E9%AB%98%E9%80%9A%E5%B9%B3%E5%8F%B0Android%E6%BA%90%E7%A0%81bootloader%E5%88%86%E6%9E%90%E4%B9%8Bsbl1-%E4%B8%89/">高通平台Android源码bootloader分析之sbl1(三)</a></p>
<p>在上一篇博文中主要描述了启动流程，及代码执行流程，并重点介绍了一下我重点关注的部分。这个sbl部分也算有点庞大，我们没有精力也没有必要去分析全部，所以接下来就来分析一下sbl1中另外几个需要格外关注的部分：</p>
<ul>
<li>CDT ：主要提供平台设备数据</li>
<li>log system：log日志系统，当然没有kernel里面那么强大了</li>
<li>download：代码下载烧写实现</li>
<li>ramdump：异常信息dump<br>　<br>本篇博文就先来分析一下CDT， 其他部分后面再分析。]]>
    
    </summary>
    
      <category term="Qualcomm" scheme="http://huaqianlee.me/tags/Qualcomm/"/>
    
      <category term="源码分析" scheme="http://huaqianlee.me/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="Android" scheme="http://huaqianlee.me/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[高通平台Android源码bootloader分析之sbl1(一)]]></title>
    <link href="http://huaqianlee.me/2015/08/15/Android/%E9%AB%98%E9%80%9A%E5%B9%B3%E5%8F%B0Android%E6%BA%90%E7%A0%81bootloader%E5%88%86%E6%9E%90%E4%B9%8Bsbl1-%E4%B8%80/"/>
    <id>http://huaqianlee.me/2015/08/15/Android/高通平台Android源码bootloader分析之sbl1-一/</id>
    <published>2015-08-15T12:44:33.000Z</published>
    <updated>2015-09-24T17:01:24.528Z</updated>
    <content type="html"><![CDATA[<p><a href="http://huaqianlee.me/2015/08/15/Android/%E9%AB%98%E9%80%9A%E5%B9%B3%E5%8F%B0Android%E6%BA%90%E7%A0%81bootloader%E5%88%86%E6%9E%90%E4%B9%8Bsbl1-%E4%B8%80/" target="_blank" rel="external">高通平台Android源码bootloader分析之sbl1(一)</a><br><a href="http://huaqianlee.me/2015/08/15/Android/%E9%AB%98%E9%80%9A%E5%B9%B3%E5%8F%B0Android%E6%BA%90%E7%A0%81bootloader%E5%88%86%E6%9E%90%E4%B9%8Bsbl1-%E4%BA%8C/" target="_blank" rel="external">高通平台Android源码bootloader分析之sbl1(二)</a><br><a href="http://huaqianlee.me/2015/08/18/Android/%E9%AB%98%E9%80%9A%E5%B9%B3%E5%8F%B0Android%E6%BA%90%E7%A0%81bootloader%E5%88%86%E6%9E%90%E4%B9%8Bsbl1-%E4%B8%89/" target="_blank" rel="external">高通平台Android源码bootloader分析之sbl1(三)</a></p>
<p>高通8k平台的boot过程搞得比较复杂， 我也是前段时间遇到一些问题深入研究了一下才搞明白。不过虽然弄得很复杂，我们需要动的东西其实很少，modem侧基本就sbl1（全称：Secondary boot loader）的代码需要动一下，ap侧就APPSBL代码需要动（对此部分不了解，可参照：<a href="http://huaqianlee.me/2015/07/25/Android/Android%E6%BA%90%E7%A0%81bootable%E8%A7%A3%E6%9E%90%E4%B9%8BLK-bootloader-little-kernel/" target="_blank" rel="external">bootable源码解析</a>），其他的都是高通搞好了的，甚至有些我们看不到代码。今天就要分析一下开机前几秒钟起着关键作用的sbl1， 这套代码在modem侧的boot_images\中。</p>
<h2 id="启动流程">启动流程</h2><p>首先来看一下高通的bootloader流程框图，主要由ap、RPM及modem三部分构成，由于我工作主要涉及到ap侧，所以对RPM和modem侧代码不了解，以后有空时间的话到可以研究一下，框图如下：<br><a id="more"></a><br><img src="http://7xjdax.com1.z0.glb.clouddn.com/20155304921b788-8a63-472f-be7c-2220a98cf428.jpg" alt="boot arch"><br>由上图可知，系统启动流程主要由以下几步组成：</p>
<ol>
<li><p>系统上电或重启。</p>
</li>
<li><p>在Cortex-a53芯片中，ap侧的PBL执行，从boot device中加载sbl1镜像到TCM，并对镜像进行校验，然后跳转到sbl1中继续执行.</p>
</li>
<li><p>sbl1初始化ddr，从boot device中加载QSEE镜像和QHEE镜像到DDR，并对镜像进行校验，QSEE执行并设置一个安全的环境，QHEE为VMM设置、SMMU配置及xPU访问控制服务。</p>
</li>
<li><p>sbl1从boot device加载RPM固件镜像到code-RAM，并对镜像进行校验。</p>
</li>
<li><p>sbl1从启动设备加载HLOS APPSBL镜像到ddr，并对镜像进行校验。</p>
</li>
<li><p>sbl1跳转到QSEE-&gt;QHEE。</p>
</li>
<li><p>QHEE通知RPM侧跳转到RPM固件中并自己跳转到HLOS APPSBL中执行。RPM侧开始执行RPM固件。</p>
</li>
<li><p>QHEE跳转到HLOS APPSBL中初始化系统。</p>
</li>
<li><p>HLOS APPSBL加载和校验HLOS内核。</p>
</li>
<li><p>由内核来加载文件系统等完成整个Android系统的启动。</p>
</li>
</ol>
<blockquote>
<p>HLOS APPSBL即为ap侧的bootloader，见：<a href="http://huaqianlee.me/2015/07/25/Android/Android%E6%BA%90%E7%A0%81bootable%E8%A7%A3%E6%9E%90%E4%B9%8BLK-bootloader-little-kernel/" target="_blank" rel="external">bootable源码解析</a></p>
</blockquote>
<p>　　<br>modem侧主要是射频网络相关的代码，我没有研究过也不了解，RPM侧的代码也没怎么研究，高通文档对其介绍如下：<br><img src="http://7xjdax.com1.z0.glb.clouddn.com/blogRPM.png" alt="RPM"></p>
<h2 id="sbl1流程分析">sbl1流程分析</h2><p>接下来我就来跟一下sbl1的代码，总结出关键流程，此部分代码皆在modem侧。我平时主要会涉及的几个重要文件：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">boot_images\core\boot\secboot3\hw\msm8916\sbl1\sbl1_hw.c</span><br><span class="line">boot_images\core\systemdrivers\pmic\framework\src\pm_init.c</span><br><span class="line">boot_images\core\boot\secboot3\hw\msm8909\sbl1\sbl1_config.c</span><br><span class="line">boot_images\core\systemdrivers\pmic\app\chg\src\pm_app_chg_alg.c</span><br><span class="line">boot_images\core\systemdrivers\pmic\drivers\smb\src\pm_smb.c // 如果带smb135x芯片</span><br></pre></td></tr></table></figure></p>
<p>首先从其入口文件sbl1.s开始，如下：</p>
<h3 id="sbl1入口：_sbl1-s">sbl1入口： sbl1.s</h3><p>此部分代码路径在：boot_images/core/boot/secboot3/hw/msm8916/sbl1/sbl1.s，此文件引导处理器，主要有实现如下操作：</p>
<ul>
<li>设置硬件，继续boot进程。</li>
<li>初始化ddr。</li>
<li>加载Trust_Zone操作系统。</li>
<li>加载RPM固件。</li>
<li>加载APPSBL然后继续boot进程。</li>
</ul>
<p>关键源码如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/*&#24341;&#20837;c&#20989;&#25968;&#65292;&#20027;&#35201;&#20026;&#24322;&#24120;&#23454;&#29616;&#20989;&#25968;&#65292;&#21450;&#19968;&#20010;&#20851;&#38190;&#20989;&#25968;sbl1_main_ctl*/&#10;; Import the external symbols that are referenced in this module.&#10;IMPORT |Image$$SBL1_SVC_STACK$$ZI$$Limit|&#10;IMPORT |Image$$SBL1_UND_STACK$$ZI$$Limit|&#10;IMPORT |Image$$SBL1_ABT_STACK$$ZI$$Limit|&#10;IMPORT boot_undefined_instruction_c_handler&#10;IMPORT boot_swi_c_handler&#10;IMPORT boot_prefetch_abort_c_handler&#10;IMPORT boot_data_abort_c_handler&#10;IMPORT boot_reserved_c_handler&#10;IMPORT boot_irq_c_handler&#10;IMPORT boot_fiq_c_handler&#10;IMPORT boot_nested_exception_c_handler&#10;IMPORT sbl1_main_ctl #&#20027;&#35201;&#20851;&#27880;&#27492;&#20989;&#25968;&#10;IMPORT boot_crash_dump_regs_ptr&#10;...&#10;# &#20851;&#20110;&#20013;&#26029;&#21521;&#37327;&#37197;&#32622;&#31561;&#27719;&#32534;&#35821;&#21477;&#65292;&#23601;&#27809;&#26377;&#21435;&#35814;&#32454;&#30475;&#20102;&#65292;&#25105;&#20204;&#19968;&#33324;&#20063;&#19981;&#20250;&#28041;&#21450;&#21040;&#36825;&#20040;&#24213;&#23618;&#30340;&#19996;&#35199;</span><br></pre></td></tr></table></figure></p>
<h3 id="sbl1_main_ctl">sbl1_main_ctl</h3><p>此函数位于boot_images\core\boot\secboot3\hw\mdm9x45\sbl1\sbl1_mc.c，主要完成初始化RAM等工作， 注此函数决不return。部分关键源码如下，我加汉字解释的是我认为我们应该关注的部分：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Calculate the SBL start time for use during boot logger initialization. */</span></span><br><span class="line">sbl_start_time = CALCULATE_TIMESTAMP(HWIO_IN(TIMETICK_CLK));</span><br><span class="line">boot_clock_debug_init();</span><br><span class="line"><span class="comment">/* Enter debug mode if debug cookie is set */</span></span><br><span class="line">sbl1_debug_mode_enter();  </span><br><span class="line"><span class="comment">/* Initialize the stack protection canary */</span></span><br><span class="line">boot_init_stack_chk_canary();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Initialize boot shared imem */</span></span><br><span class="line">boot_shared_imem_init(&amp;bl_shared_data);</span><br><span class="line"><span class="comment">/*初始化RAM*/</span></span><br><span class="line">boot_ram_init(&amp;sbl1_ram_init_data);</span><br><span class="line"><span class="comment">/*初始化log系统，即串口驱动*/</span></span><br><span class="line">sbl1_boot_logger_init(&amp;boot_log_data, pbl_shared);</span><br><span class="line"><span class="comment">/*检索PBL传递过来的数据*/</span> </span><br><span class="line">sbl1_retrieve_shared_info_from_pbl(pbl_shared); </span><br><span class="line"><span class="comment">/* Initialize the QSEE interface */</span></span><br><span class="line">sbl1_init_sbl_qsee_interface(&amp;bl_shared_data,&amp;sbl_verified_info);</span><br><span class="line"><span class="comment">/* Initialize SBL memory map. Initializing early because drivers could be located in RPM Code RAM. */</span></span><br><span class="line">sbl1_populate_initial_mem_map(&amp;bl_shared_data);</span><br><span class="line"><span class="comment">/*初始化DAL*/</span></span><br><span class="line">boot_DALSYS_InitMod(NULL); </span><br><span class="line"><span class="comment">/*配置PMIC芯片，以便我们能通过PS_HOLD复位*/</span></span><br><span class="line">sbl1_hw_init();</span><br><span class="line"><span class="comment">/*执行sbl1的目标依赖进程*/</span></span><br><span class="line">boot_config_process_bl(&amp;bl_shared_data, SBL1_IMG, sbl1_config_table);</span><br></pre></td></tr></table></figure></p>
<h3 id="sbl1_config_table">sbl1_config_table</h3><p>sbl1_config_table为一个结构体数组，里面存储了加载QSEE、RPM、APPSBL等镜像所需要的配置参数及执行函数，位于boot_images\core\boot\secboot3\hw\msm8909\sbl1\sbl1_config.c。其关键代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">boot_configuration_table_entry sbl1_config_table[] = </span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* SBL1 -&gt; QSEE */</span></span><br><span class="line">  &#123;</span><br><span class="line">    SBL1_IMG,                   <span class="comment">/* host_img_id */</span></span><br><span class="line">    CONFIG_IMG_QC,              <span class="comment">/* host_img_type */</span></span><br><span class="line">    GEN_IMG,                    <span class="comment">/* target_img_id */</span></span><br><span class="line">    CONFIG_IMG_ELF,             <span class="comment">/* target_img_type */</span></span><br><span class="line">    ...</span><br><span class="line">    load_qsee_pre_procs,        <span class="comment">/* pre_procs */</span> </span><br><span class="line">    load_qsee_post_procs,       <span class="comment">/* post_procs */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* SBL1 -&gt; QHEE */</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">/* SBL1 -&gt; RPM */</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">/* SBL1 -&gt; APPSBL （即lk部分） */</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<h3 id="load_qsee_pre_procs">load_qsee_pre_procs</h3><p>load_qsee_pre_procs为一个函数结构体数组，在QSEE加载之前执行。源码注释写得很清楚并且容易理解，我就不多此一举去翻译了，关键源码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Save reset register logs */</span></span><br><span class="line">boot_save_reset_register_log,</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Initialize the flash device */</span></span><br><span class="line">boot_flash_init,</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Copy the configure data table from eeprom */</span></span><br><span class="line">boot_config_data_table_init,</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Store platform id */</span></span><br><span class="line">sbl1_hw_platform_pre_ddr,</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Configure ddr parameters based on eeprom CDT table data. */</span></span><br><span class="line">sbl1_ddr_set_params,</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Initialize DDR */</span></span><br><span class="line">(boot_procedure_func_type)sbl1_ddr_init,</span><br><span class="line"></span><br><span class="line"><span class="comment">/*----------------------------------------------------------------------</span><br><span class="line"> Run deviceprogrammer if compiling the deviceprogrammer_ddr image.</span><br><span class="line">----------------------------------------------------------------------*/</span></span><br><span class="line">boot_deviceprogrammer_ddr_main,</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Initialize SBL1 DDR ZI region, relocate boot log to DDR */</span>   </span><br><span class="line">sbl1_post_ddr_init,</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 此函数挺重要，我能改到的东西基本上都基于它，所有的PMIC API都是在此函数调用boot_pm_dirver_init()之后再被调用*/</span></span><br><span class="line">sbl1_hw_init_secondary, </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* DDR training */</span></span><br><span class="line">(boot_procedure_func_type)sbl1_wait_for_ddr_training,</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Initialize SBL1 DDR ZI region, relocate page table to DDR */</span></span><br><span class="line">sbl1_post_ddr_training_init, </span><br><span class="line"></span><br><span class="line"><span class="comment">/* Zero out QSEE and QHEE region if needed.  This MUST be done before</span><br><span class="line">   boot_dload_dump_security_regions executes for security reasons. */</span></span><br><span class="line">sbl1_cleanse_security_regions,</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Backup QSEE and QHEE region for ramdumps taken after SBL has executed */</span></span><br><span class="line">boot_dload_dump_security_regions,</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Check to see if DLOAD mode needs to be entered */</span></span><br><span class="line">boot_dload_check,</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Last entry in the table. */</span></span><br><span class="line">NULL</span><br></pre></td></tr></table></figure></p>
<h3 id="load_qsee_post_procs">load_qsee_post_procs</h3><p>load_qsee_post_procs同样也为一个函数结构体数组，其在加载QSEE之后执行。关键源码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/* Enable the secure watchdog</span><br><span class="line">     This is done after boot_dload_check that way if we are in the final stage</span><br><span class="line">     of an abnormal reset boot_dload_check will finalize the stage. */</span></span><br><span class="line">  boot_secure_watchdog_init,</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Load SEC partition if it exists.  This must be done after QSEE is</span><br><span class="line">     loaded as the partition is loaded into a QSEE buffer. */</span></span><br><span class="line">  sbl1_load_sec_partition,  </span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Set the memory barrier pointer to shared memory */</span></span><br><span class="line">  boot_cache_set_memory_barrier,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*----------------------------------------------------------------------</span><br><span class="line">   Put SMEM in debug state such that smem_alloc() calls will return NULL. </span><br><span class="line">   The state is changed back to normal once smem_boot_init() is called.</span><br><span class="line">   This call has to be made after setting the memory barrier.</span><br><span class="line">  ----------------------------------------------------------------------*/</span></span><br><span class="line">  boot_smem_debug_init,  </span><br><span class="line">    </span><br><span class="line">  <span class="comment">/* Initialize shared memory after dload to preserve logs */</span></span><br><span class="line">  boot_smem_init,</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> !defined(FEATURE_RUMI_BOOT)</span></span><br><span class="line">  <span class="comment">/* Stub out for rumi build. pmic api  pm_get_power_on_status gets </span><br><span class="line">     called from below api to get power on reason */</span> </span><br><span class="line">  <span class="comment">/*----------------------------------------------------------------------</span><br><span class="line">   Store Power on Status in SMEM. </span><br><span class="line">   Needs to be done after PMIC and SMEM initialization</span><br><span class="line">  ----------------------------------------------------------------------*/</span></span><br><span class="line">  boot_smem_store_pon_status,</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span>  </span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*----------------------------------------------------------------------</span><br><span class="line">   Store the platform id to smem</span><br><span class="line">  ----------------------------------------------------------------------*/</span></span><br><span class="line">  sbl1_hw_platform_smem,</span><br><span class="line">   </span><br><span class="line">  <span class="comment">/*----------------------------------------------------------------------</span><br><span class="line">   Get shared data out of the flash device module</span><br><span class="line">  ----------------------------------------------------------------------*/</span></span><br><span class="line">  boot_share_flash_data,</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/*----------------------------------------------------------------------</span><br><span class="line">   populate the ram partition table</span><br><span class="line">  ----------------------------------------------------------------------*/</span></span><br><span class="line">  boot_populate_ram_partition_table,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*----------------------------------------------------------------------</span><br><span class="line">   Initialize GPIO for low power configuration</span><br><span class="line">  ----------------------------------------------------------------------*/</span></span><br><span class="line">  sbl1_tlmm_init,</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/*-----------------------------------------------------------------------</span><br><span class="line">   Calls efs cookie handling api to perform efs backup/restore</span><br><span class="line">  -----------------------------------------------------------------------*/</span>  </span><br><span class="line">  sbl1_efs_handle_cookies,</span><br><span class="line">    </span><br><span class="line">  <span class="comment">/*-----------------------------------------------------------------------</span><br><span class="line">   APT Security Test</span><br><span class="line">   ----------------------------------------------------------------------*/</span></span><br><span class="line">  (boot_procedure_func_type)boot_apt_test,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Last entry in the table. */</span></span><br><span class="line">  NULL</span><br></pre></td></tr></table></figure></p>
<h3 id="pm_chg_charger_detect_state">pm_chg_charger_detect_state</h3><p>pm_chg_charger_detect_state函数是启动工程中非常重要的一个函数，它将监测电池的状态，然后决定启动过程，调用关系和解析如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sbl1_hw_init_secondary</span><br><span class="line"> -&gt;boot_pm_dirver_init </span><br><span class="line">  -&gt;pm_driver_init <span class="comment">#初始化PMIC驱动</span></span><br><span class="line">   -&gt;pm_driver_post_init</span><br><span class="line">    -&gt;pm_chg_sbl_charging_state_entry</span><br><span class="line">     -&gt;pm_chg_battery_and_debug_board_detect_state</span><br><span class="line">      -&gt;pm_chg_charger_detect_state <span class="comment">#监测电池状态，电池正常则启动，weak则死循环，充电知道电池正常</span></span><br><span class="line">       -&gt;pm_chg_<span class="built_in">enable</span>_usb_charging</span><br></pre></td></tr></table></figure></p>
<h3 id="pm_chg_sbl_charging_state_entry">pm_chg_sbl_charging_state_entry</h3><p>pm_chg_sbl_charging_state_entry是充电状态机的入口函数， 如果充电状态不正确的话会造成死机，代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">pm_err_flag_type  <span class="title">pm_chg_sbl_charging_state_entry</span><span class="params">(<span class="keyword">void</span>)</span>   <span class="comment">//called at the end of pm_driver_init</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    pm_err_flag_type err_flag = PM_ERR_FLAG__SUCCESS;</span><br><span class="line"></span><br><span class="line">    pm_chg_status.previous_state = PM_CHG_ENTRY_STATE;</span><br><span class="line">    pm_chg_status.current_state  = PM_CHG_ENTRY_STATE;</span><br><span class="line">    pm_chg_status.batt_level  = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Get handle for charger algorithm specific data (from Dal config)</span></span><br><span class="line">    sbl_chg_app_ds = (uint16*)pm_target_information_get_specific_info(PM_PROP_CHG_APP_LUT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Check Battery/Debug board presence</span></span><br><span class="line">    next_state_ptr = &amp;pm_chg_state__battery_and_debug_board_detect;</span><br><span class="line"></span><br><span class="line">    err_flag |= pm_chg_sbl_charging_initialize();</span><br><span class="line">    </span><br><span class="line">    err_flag |= pm_chg_process_sbl_charger_states();  <span class="comment">//Process next sbl charging state</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>( err_flag != PM_ERR_FLAG__SUCCESS)  </span><br><span class="line">    &#123;<span class="comment">//Handle All SBL charger algorithm errors</span></span><br><span class="line">       PM_ERR_FATAL();      <span class="comment">// sbl充电状态异常的话，调用此函数，此函数其实就是一个空的while(1)，如果执行到此步，机器则死机，必须断电才能继续工作</span></span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> err_flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="pm_chg_process_sbl_charger_states">pm_chg_process_sbl_charger_states</h3><p>pm_chg_process_sbl_charger_states函数也是启动过程中非常重要的一个函数，此函数里面有一个死循环，用来更新充电状态或者关机，其被pm_chg_sbl_charging_state_entry函数调用（见上调用关系）。插上充电器开机前几秒就出现的重启问题， 多半是此部分出了状况。代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> pm_err_flag_type  <span class="title">pm_chg_process_sbl_charger_states</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    pm_err_flag_type err_flag = PM_ERR_FLAG__SUCCESS;</span><br><span class="line">    pm_chg_state_alg_ptr_type next_state = NULL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Process SBL charging states transitions</span></span><br><span class="line">    <span class="keyword">while</span>( (next_state_ptr != NULL)  )</span><br><span class="line">    &#123;</span><br><span class="line">        pm_chg_status.previous_state = pm_chg_status.current_state;</span><br><span class="line">        pm_chg_status.current_state  = next_state_ptr-&gt;current_chg_state;</span><br><span class="line"></span><br><span class="line">        next_state = next_state_ptr-&gt;next_chg_state_alg;</span><br><span class="line">        <span class="keyword">if</span> (next_state)</span><br><span class="line">        &#123;</span><br><span class="line">           err_flag = next_state();  <span class="comment">//transition to next state</span></span><br><span class="line">        &#125;</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">if</span> ( ( err_flag                     != PM_ERR_FLAG__SUCCESS  )  ||</span><br><span class="line">             ( pm_chg_status.current_state == PM_CHG_BOOTUP_STATE   )  ||</span><br><span class="line">             ( pm_chg_status.current_state == PM_CHG_SHUTDOWN_STATE )      <span class="comment">//Shutdown state condition will never happen but we have it for sake of being complete</span></span><br><span class="line">           )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> err_flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="http://huaqianlee.me/2015/08/15/Android/%E9%AB%98%E9%80%9A%E5%B9%B3%E5%8F%B0Android%E6%BA%90%E7%A0%81bootloader%E5%88%86%E6%9E%90%E4%B9%8Bsbl1-%E4%B8%80/">高通平台Android源码bootloader分析之sbl1(一)</a><br><a href="http://huaqianlee.me/2015/08/15/Android/%E9%AB%98%E9%80%9A%E5%B9%B3%E5%8F%B0Android%E6%BA%90%E7%A0%81bootloader%E5%88%86%E6%9E%90%E4%B9%8Bsbl1-%E4%BA%8C/">高通平台Android源码bootloader分析之sbl1(二)</a><br><a href="http://huaqianlee.me/2015/08/18/Android/%E9%AB%98%E9%80%9A%E5%B9%B3%E5%8F%B0Android%E6%BA%90%E7%A0%81bootloader%E5%88%86%E6%9E%90%E4%B9%8Bsbl1-%E4%B8%89/">高通平台Android源码bootloader分析之sbl1(三)</a></p>
<p>高通8k平台的boot过程搞得比较复杂， 我也是前段时间遇到一些问题深入研究了一下才搞明白。不过虽然弄得很复杂，我们需要动的东西其实很少，modem侧基本就sbl1（全称：Secondary boot loader）的代码需要动一下，ap侧就APPSBL代码需要动（对此部分不了解，可参照：<a href="http://huaqianlee.me/2015/07/25/Android/Android%E6%BA%90%E7%A0%81bootable%E8%A7%A3%E6%9E%90%E4%B9%8BLK-bootloader-little-kernel/">bootable源码解析</a>），其他的都是高通搞好了的，甚至有些我们看不到代码。今天就要分析一下开机前几秒钟起着关键作用的sbl1， 这套代码在modem侧的boot_images\中。</p>
<h2 id="启动流程">启动流程</h2><p>首先来看一下高通的bootloader流程框图，主要由ap、RPM及modem三部分构成，由于我工作主要涉及到ap侧，所以对RPM和modem侧代码不了解，以后有空时间的话到可以研究一下，框图如下：<br>]]>
    
    </summary>
    
      <category term="Qualcomm" scheme="http://huaqianlee.me/tags/Qualcomm/"/>
    
      <category term="源码分析" scheme="http://huaqianlee.me/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="Android" scheme="http://huaqianlee.me/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android源码bootable解析之bootloader LK(little kernel)]]></title>
    <link href="http://huaqianlee.me/2015/07/25/Android/Android%E6%BA%90%E7%A0%81bootable%E8%A7%A3%E6%9E%90%E4%B9%8BLK-bootloader-little-kernel/"/>
    <id>http://huaqianlee.me/2015/07/25/Android/Android源码bootable解析之LK-bootloader-little-kernel/</id>
    <published>2015-07-25T07:56:13.000Z</published>
    <updated>2015-08-15T12:54:23.996Z</updated>
    <content type="html"><![CDATA[<p>记得当初学Linux时候，bootloader 代码相对来说还比较简单，主要几个汇编文件加上几个C文件，编译一个uboot就ok了。做Android驱动后，发现Android专门做了一个目录bootable来实现boot等相关功能。功能也比较多，所以就准备来研究一下这一部分。今天就先研究一下LK，LK全称为Little Kernel，是AP模块bootloader中实现的一个微型系统。</p>
<h2 id="boot架构">boot架构</h2><a id="more"></a>
<p>首先来了解一下bootable代码的目录结构，其下主要有三个子目录，如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#bootable</span></span><br><span class="line">-bootloader/LK</span><br><span class="line">   -app            <span class="comment">#功能实现，如 adb 命令</span></span><br><span class="line">   -arch           <span class="comment">#CPU架构</span></span><br><span class="line">   -dev            <span class="comment">#设备驱动</span></span><br><span class="line">   -include      <span class="comment">#头文件</span></span><br><span class="line">   -kernel        <span class="comment">#主文件，main.c</span></span><br><span class="line">   -lib             <span class="comment">#库文件</span></span><br><span class="line">   -platform    <span class="comment">#平台文件，如：msm8916</span></span><br><span class="line">   -projiect     <span class="comment">#mk文件</span></span><br><span class="line">   -make       <span class="comment">#mk文件</span></span><br><span class="line">   -scripts      <span class="comment">#脚本文件</span></span><br><span class="line">   -target        <span class="comment">#目标设备文件</span></span><br><span class="line">   AndroidBoot.mk</span><br><span class="line">   makefie</span><br><span class="line">-recovery <span class="comment">#由lk启动，主要用来更新主系统（即我们平时使用的Android系统）</span></span><br><span class="line">-diskinstaller <span class="comment">#打包镜像</span></span><br></pre></td></tr></table></figure></p>
<h2 id="LK流程分析">LK流程分析</h2><p>在LK的链接文件ssystem-onesegment.ld 或  system-twosegment.ld （位于bootable/bootloadler/lk/arch/arm/，此文件用来指定代码的内存分布等）中，LK指定lk/arch/crt0.s中的_start函数为入口函数，crt.s主要初始化CPU，然后长跳转（bl）到lk/kernel/main.c中kmain函数，初始化lk系统，接着初始化boot，跳转到kernel。接下来按照此流程来分析一下。</p>
<h3 id="kmain()">kmain()</h3><p>与 boot 启动初始化相关函数为 arch_early_init、  platform_early_init 、bootstrap2/bootstrap_nandwrite，这些函数比较重要,待会儿再详解,如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">void kmain(void)</span><br><span class="line">&#123;</span><br><span class="line">	thread_init_early(); // 初始化化lk线程上下文</span><br><span class="line">	arch_early_init(); // 架构初始化，如关闭cache，使能mmu</span><br><span class="line">	platform_early_init(); // 平台早期初始化</span><br><span class="line">	target_early_init(); //目标设备早期初始化</span><br><span class="line">	bs_<span class="built_in">set</span>_timestamp(BS_BL_START);</span><br><span class="line">	call_constructors(); //静态构造函数初始化</span><br><span class="line">	heap_init(); // 堆初始化</span><br><span class="line">	thread_init(); // 初始化线程</span><br><span class="line">	dpc_init();  //lk系统控制器初始化</span><br><span class="line">	timer_init(); //kernel时钟初始化</span><br><span class="line"></span><br><span class="line"><span class="comment">#if (!ENABLE_NANDWRITE)</span></span><br><span class="line">	thread_resume(thread_create(<span class="string">"bootstrap2"</span>, &amp;bootstrap2, NULL, DEFAULT_PRIORITY, DEFAULT_STACK_SIZE)); // 创建一个线程初始化系统</span><br><span class="line">	<span class="built_in">exit</span>_critical_section(); //使能中断</span><br><span class="line">	thread_become_idle(); //本线程切换为idle线程</span><br><span class="line"><span class="comment">#else</span></span><br><span class="line">        bootstrap_nandwrite(); </span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="arch_early_init()">arch_early_init()</h3><p>因为高通平台用的arm架构,所以文件路径为:\bootable\bootloader\lk\arch\arm\arch.c.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">void arch_early_init(void)</span><br><span class="line">&#123;</span><br><span class="line">	arch_<span class="built_in">disable</span>_cache(UCACHE); //关闭cache</span><br><span class="line">	<span class="built_in">set</span>_vector_base(MEMBASE); // 设置异常向量基地址</span><br><span class="line">	arm_mmu_init(); //初始化mmu</span><br><span class="line">	arch_<span class="built_in">enable</span>_cache(UCACHE); //打开cache</span><br><span class="line"></span><br><span class="line">	/* <span class="built_in">enable</span> cp10 and cp11 */</span><br><span class="line">	__asm__ volatile(<span class="string">"mrc	p15, 0, %0, c1, c0, 2"</span> : <span class="string">"=r"</span> (val));</span><br><span class="line">	val |= (<span class="number">3</span>&lt;&lt;<span class="number">22</span>)|(<span class="number">3</span>&lt;&lt;<span class="number">20</span>);</span><br><span class="line">	__asm__ volatile(<span class="string">"mcr	p15, 0, %0, c1, c0, 2"</span> :: <span class="string">"r"</span> (val));</span><br><span class="line">	/* <span class="built_in">set</span> <span class="built_in">enable</span> bit <span class="keyword">in</span> fpexc(中断相关寄存器) */</span><br><span class="line">	__asm__ volatile(<span class="string">"mrc  p10, 7, %0, c8, c0, 0"</span> : <span class="string">"=r"</span> (val));</span><br><span class="line">	val |= (<span class="number">1</span>&lt;&lt;<span class="number">30</span>);</span><br><span class="line">	__asm__ volatile(<span class="string">"mcr  p10, 7, %0, c8, c0, 0"</span> :: <span class="string">"r"</span> (val));</span><br><span class="line">	/* <span class="built_in">enable</span> the cycle count register */</span><br><span class="line">	__asm__ volatile(<span class="string">"mrc	p15, 0, %0, c9, c12, 0"</span> : <span class="string">"=r"</span> (en));</span><br><span class="line">	en &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">3</span>); /* cycle count every cycle */</span><br><span class="line">	en |= <span class="number">1</span>; /* <span class="built_in">enable</span> all performance counters */</span><br><span class="line">	__asm__ volatile(<span class="string">"mcr	p15, 0, %0, c9, c12, 0"</span> :: <span class="string">"r"</span> (en));</span><br><span class="line"></span><br><span class="line">	/* <span class="built_in">enable</span> cycle counter */</span><br><span class="line">	en = (<span class="number">1</span>&lt;&lt;<span class="number">31</span>);</span><br><span class="line">	__asm__ volatile(<span class="string">"mcr	p15, 0, %0, c9, c12, 1"</span> :: <span class="string">"r"</span> (en));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="platform_early_init">platform_early_init</h3><p>每个平台的初始化不一样,我使用的msm8916,路径为:\bootable\bootloader\lk\platform\msm8916\platform.c,如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void platform_early_init(void)</span><br><span class="line">&#123;</span><br><span class="line">	board_init(); //主板初始化</span><br><span class="line">	platform_clock_init(); //时钟初始化</span><br><span class="line">	qgic_init();</span><br><span class="line">	qtimer_init(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="bootstrap2">bootstrap2</h3><p>此函数由kmain中创建的线程调用，路径为:bootable\bootloader\lk\kernel\main.c。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static int bootstrap2(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">	arch_init(); //架构初始化</span><br><span class="line">	bio_init();</span><br><span class="line">	fs_init();</span><br><span class="line">	platform_init(); //平台初始化, 主要初始化系统时钟,超频等</span><br><span class="line">	target_init(); //目标设备初始化,主要初始化Flash,整合分区表等</span><br><span class="line">	apps_init(); // 应用功能初始化,调用aboot_init,加载kernel等</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="aboot_init">aboot_init</h3><p>此函数由上apps_init函数调用，路径: bootable\bootloader\lk\app\aboot\aboot.c.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">/* Setup page size information <span class="keyword">for</span> nv storage */</span><br><span class="line">	<span class="keyword">if</span> (target_is_emmc_boot())</span><br><span class="line">	&#123;</span><br><span class="line">		page_size = mmc_page_size();</span><br><span class="line">		page_mask = page_size - <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		page_size = flash_page_size();</span><br><span class="line">		page_mask = page_size - <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">read</span>_device_info(&amp;device); //读取设备信息</span><br><span class="line">	target_display_init(device.display_panel); // splash屏初始化</span><br><span class="line">    target_serialno((unsigned char *) sn_buf); //设置串口号</span><br><span class="line">	memset(display_panel_buf, <span class="string">'\0'</span>, MAX_PANEL_BUF_SIZE); //初始化显存</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (is_user_force_reset()) // 检查关机原因,如果强制重启则正常启动</span><br><span class="line">		goto normal_boot;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (keys_get_state(KEY_VOLUMEUP) &amp;&amp; keys_get_state(KEY_VOLUMEDOWN)) // 如果按下音量上下键</span><br><span class="line">	&#123;</span><br><span class="line">		reboot_device(DLOAD); //重启进入紧急下载	</span><br><span class="line">		<span class="keyword">if</span> (!pm8x41_ponpon_pwrkey()) &#123;//如果按下power键和音量键,进入fastboot模式,这很可能为自定义,Android源码没有</span><br><span class="line">		boot_into_fastboot = <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">    /*检查重启模式,并进入相应模式*/</span><br><span class="line">	reboot_mode = check_reboot_mode();</span><br><span class="line">	hard_reboot_mode = check_hard_reboot_mode();</span><br><span class="line">	<span class="keyword">if</span> (reboot_mode == RECOVERY_MODE ||</span><br><span class="line">		hard_reboot_mode == RECOVERY_HARD_RESET_MODE) &#123;</span><br><span class="line">		boot_into_recovery = <span class="number">1</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span>(reboot_mode == FASTBOOT_MODE ||</span><br><span class="line">		hard_reboot_mode == FASTBOOT_HARD_RESET_MODE) &#123;</span><br><span class="line">		boot_into_fastboot = <span class="literal">true</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span>(reboot_mode == ALARM_BOOT ||</span><br><span class="line">		hard_reboot_mode == RTC_HARD_RESET_MODE) &#123;</span><br><span class="line">		boot_reason_alarm = <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">normal_boot:</span><br><span class="line">	<span class="keyword">if</span> (!boot_into_fastboot)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (target_is_emmc_boot())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(emmc_recovery_init()) //emmc_recovery初始化</span><br><span class="line">			<span class="built_in">set</span>_tamper_fuse_cmd();</span><br><span class="line">			<span class="built_in">set</span>_tamper_flag(device.is_tampered);</span><br><span class="line">			boot_linux_from_mmc();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">		&#123;</span><br><span class="line">			recovery_init();  // recovery模式初始化</span><br><span class="line">			<span class="built_in">set</span>_tamper_flag(device.is_tampered);</span><br><span class="line">       &#125;</span><br><span class="line">		boot_linux_from_flash(); //从Flash中加载启动内核</span><br><span class="line">	&#125;</span><br><span class="line">	/*不应该执行到这儿,只有没能正常启动时才会执行到这*/</span><br><span class="line">	aboot_fastboot_register_commands(); // 注册fastboot命令,</span><br><span class="line">	partition_dump(); //dump(即保存)分区表调试信息</span><br><span class="line">	fastboot_init(target_get_scratch_address(), target_get_max_flash_size()); //初始化并进入fastboot</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="boot_linux_from_flash">boot_linux_from_flash</h3><p>路径: bootable\bootloader\lk\app\aboot\aboot.c。此函数实现内核的加载，boot镜像boot.img由如下几部分构成：kernel头、kernel、ramdisk(虚拟磁盘)、second stage（可以没有）。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (target_is_emmc_boot()) &#123;  // 如果目标设备是emmc boot(内嵌boot)</span><br><span class="line">		hdr = (struct boot_img_hdr *)EMMC_BOOT_IMG_HEADER_ADDR; // 获取emmc boot镜像首地址</span><br><span class="line">		goto <span class="built_in">continue</span>_boot; // 继续启动</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ptable = flash_get_ptable(); // 获取分区表</span><br><span class="line">	<span class="keyword">if</span>(!boot_into_recovery) //非recovery模式</span><br><span class="line">	&#123;</span><br><span class="line">	    ptn = ptable_find(ptable, <span class="string">"boot"</span>); //获取boot分区</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">	    ptn = ptable_find(ptable, <span class="string">"recovery"</span>); // 获取recovery分区</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (flash_<span class="built_in">read</span>(ptn, offset, buf, page_size)) //获取boot镜像</span><br><span class="line">	<span class="keyword">if</span> (memcmp(hdr-&gt;magic, BOOT_MAGIC, BOOT_MAGIC_SIZE)) //校验boot头</span><br><span class="line">	<span class="keyword">if</span> (hdr-&gt;page_size != page_size) //校验boot页大小</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * Update the kernel/ramdisk/tags address <span class="keyword">if</span> the boot image header</span><br><span class="line">	 * has default values, these default values come from mkbootimg when</span><br><span class="line">	 * the boot image is flashed using fastboot flash:raw</span><br><span class="line">	 */</span><br><span class="line">	update_ker_tags_rdisk_addr(hdr); //读取boot image头，如有默认值则更新kernel、ramdisk、tag地址</span><br><span class="line"></span><br><span class="line">	/* Get virtual addresses since the hdr saves physical addresses. */</span><br><span class="line">	/* 根据物理地址获取虚拟地址 */</span><br><span class="line">	hdr-&gt;kernel_addr = VA((addr_t)(hdr-&gt;kernel_addr));</span><br><span class="line">	hdr-&gt;ramdisk_addr = VA((addr_t)(hdr-&gt;ramdisk_addr));</span><br><span class="line">	hdr-&gt;tags_addr = VA((addr_t)(hdr-&gt;tags_addr));</span><br><span class="line"></span><br><span class="line">	kernel_actual  = ROUND_TO_PAGE(hdr-&gt;kernel_size,  page_mask); //获取kernel实际地址</span><br><span class="line">	ramdisk_actual = ROUND_TO_PAGE(hdr-&gt;ramdisk_size, page_mask); // 获取ramdisk实际地址</span><br><span class="line"></span><br><span class="line">	/* Check <span class="keyword">if</span> the addresses <span class="keyword">in</span> the header are valid. */</span><br><span class="line">	/* 检查镜像头中的地址有效性*/</span><br><span class="line">	<span class="keyword">if</span> (check_aboot_addr_range_overlap(hdr-&gt;kernel_addr, kernel_actual) ||</span><br><span class="line">		check_aboot_addr_range_overlap(hdr-&gt;ramdisk_addr, ramdisk_actual))</span><br><span class="line"><span class="comment">#ifndef DEVICE_TREE // 设备树,即dts\dtsi文件</span></span><br><span class="line">		<span class="keyword">if</span> (check_aboot_addr_range_overlap(hdr-&gt;tags_addr, MAX_TAGS_SIZE)) //检查设备树地址是否与aboot地址重合</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"></span><br><span class="line">	/* Authenticate Kernel */</span><br><span class="line">	/* 鉴定内核 */</span><br><span class="line">	<span class="keyword">if</span>(target_use_signed_kernel() &amp;&amp; (!device.is_unlocked)) //如果用签名kernel并且设备未被锁</span><br><span class="line">	&#123;</span><br><span class="line">		image_addr = (unsigned char *)target_get_scratch_address();</span><br><span class="line">		offset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#if DEVICE_TREE</span></span><br><span class="line">		dt_actual = ROUND_TO_PAGE(hdr-&gt;dt_size, page_mask);</span><br><span class="line">		imagesize_actual = (page_size + kernel_actual + ramdisk_actual + dt_actual);//获取镜像实际地址</span><br><span class="line">		<span class="keyword">if</span> (check_aboot_addr_range_overlap(hdr-&gt;tags_addr, hdr-&gt;dt_size)) //检查设备树地址是否与aboot地址重合</span><br><span class="line"><span class="comment">#else</span></span><br><span class="line">		imagesize_actual = (page_size + kernel_actual + ramdisk_actual);</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">		bs_<span class="built_in">set</span>_timestamp(BS_KERNEL_LOAD_START); // 开始加载boot镜像</span><br><span class="line"></span><br><span class="line">		/* Read image without signature */</span><br><span class="line">		/* 读取没有签名的镜像*/</span><br><span class="line">		<span class="keyword">if</span> (flash_<span class="built_in">read</span>(ptn, offset, (void *)image_addr, imagesize_actual))</span><br><span class="line">		bs_<span class="built_in">set</span>_timestamp(BS_KERNEL_LOAD_DONE); //boot镜像加载完成</span><br><span class="line"></span><br><span class="line">		offset = imagesize_actual;</span><br><span class="line">		/* Read signature */</span><br><span class="line">		/* 获取boot镜像签名 */</span><br><span class="line">		<span class="keyword">if</span> (flash_<span class="built_in">read</span>(ptn, offset, (void *)(image_addr + offset), page_size))</span><br><span class="line">		verify_signed_bootimg(image_addr, imagesize_actual);</span><br><span class="line"></span><br><span class="line">		/* Move kernel and ramdisk to correct address */</span><br><span class="line">		/* 移动kernel和ramdisk到正确地址*/</span><br><span class="line">		memmove((void*) hdr-&gt;kernel_addr, (char *)(image_addr + page_size), hdr-&gt;kernel_size);</span><br><span class="line">		memmove((void*) hdr-&gt;ramdisk_addr, (char *)(image_addr + page_size + kernel_actual), hdr-&gt;ramdisk_size);</span><br><span class="line"><span class="comment">#if DEVICE_TREE</span></span><br><span class="line">		/* Validate and Read device device tree <span class="keyword">in</span> the <span class="string">"tags_add */</span><br><span class="line">		/* 校验并获取设备树*/</span><br><span class="line">		if (check_aboot_addr_range_overlap(hdr-&gt;tags_addr, dt_entry.size))</span><br><span class="line">		memmove((void*) hdr-&gt;tags_addr, (char *)(image_addr + page_size + kernel_actual + ramdisk_actual), hdr-&gt;dt_size);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">		/* Make sure everything from scratch address is read before next step!*/</span><br><span class="line">		if(device.is_tampered)</span><br><span class="line">		&#123;</span><br><span class="line">			write_device_info_flash(&amp;device);</span><br><span class="line">		&#125;</span><br><span class="line">#if USE_PCOM_SECBOOT</span><br><span class="line">		set_tamper_flag(device.is_tampered);</span><br><span class="line">#endif</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		offset = page_size;</span><br><span class="line"></span><br><span class="line">		kernel_actual = ROUND_TO_PAGE(hdr-&gt;kernel_size, page_mask);</span><br><span class="line">		ramdisk_actual = ROUND_TO_PAGE(hdr-&gt;ramdisk_size, page_mask);</span><br><span class="line">		second_actual = ROUND_TO_PAGE(hdr-&gt;second_size, page_mask);</span><br><span class="line"></span><br><span class="line">		bs_set_timestamp(BS_KERNEL_LOAD_START); // 开始加载boot镜像</span><br><span class="line"></span><br><span class="line">		if (flash_read(ptn, offset, (void *)hdr-&gt;kernel_addr, kernel_actual)) // 获取boot镜像</span><br><span class="line">		offset += kernel_actual;</span><br><span class="line">		if (flash_read(ptn, offset, (void *)hdr-&gt;ramdisk_addr, ramdisk_actual)) //获取ramdisk镜像</span><br><span class="line">		offset += ramdisk_actual;</span><br><span class="line">		bs_set_timestamp(BS_KERNEL_LOAD_DONE); // 结束加载</span><br><span class="line"></span><br><span class="line">		if(hdr-&gt;second_size != 0) &#123;</span><br><span class="line">			offset += second_actual;</span><br><span class="line">			/* Second image loading not implemented. */</span><br><span class="line">			ASSERT(0); //跳过第二镜像</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">#if DEVICE_TREE</span><br><span class="line">		if(hdr-&gt;dt_size != 0) &#123; // 如果设备文件存在</span><br><span class="line"></span><br><span class="line">			/* Read the device tree table into buffer */			</span><br><span class="line">			if(flash_read(ptn, offset, (void *) dt_buf, page_size))  // 读取设备树分区</span><br><span class="line">			table = (struct dt_table*) dt_buf;</span><br><span class="line"></span><br><span class="line">			if (dev_tree_validate(table, hdr-&gt;page_size, &amp;dt_hdr_size) != 0) //校验设备树分区</span><br><span class="line"></span><br><span class="line">			table = (struct dt_table*) memalign(CACHE_LINE, dt_hdr_size); // 获取内存地址</span><br><span class="line"></span><br><span class="line">			/* Read the entire device tree table into buffer */</span><br><span class="line">			if(flash_read(ptn, offset, (void *)table, dt_hdr_size)) // 读取设备树分区</span><br><span class="line"></span><br><span class="line">			/* Find index of device tree within device tree table */</span><br><span class="line">			if(dev_tree_get_entry_info(table, &amp;dt_entry) != 0) //获取设备树地址</span><br><span class="line"></span><br><span class="line">			/* Validate and Read device device tree in the "</span>tags_add */</span><br><span class="line">			<span class="keyword">if</span> (check_aboot_addr_range_overlap(hdr-&gt;tags_addr, dt_entry.size)) // 校验设备树地址是否与aboot地址重合</span><br><span class="line"></span><br><span class="line">			/* Read device device tree <span class="keyword">in</span> the <span class="string">"tags_add */</span><br><span class="line">			if(flash_read(ptn, offset + dt_entry.offset, (void *)hdr-&gt;tags_addr, dt_entry.size)) // 获取设备树</span><br><span class="line">		&#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">continue_boot:</span><br><span class="line"></span><br><span class="line">	/* TODO: create/pass atags to kernel */</span><br><span class="line"></span><br><span class="line">	boot_linux((void *)hdr-&gt;kernel_addr, (void *)hdr-&gt;tags_addr,</span><br><span class="line">		   (const char *)hdr-&gt;cmdline, board_machtype(),</span><br><span class="line">		   (void *)hdr-&gt;ramdisk_addr, hdr-&gt;ramdisk_size); //启动内核</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>因为时间有限,并没有详细去跟代码。很多细节都是大概扫了一下函数内容或者根据注释得出结果，如有错误,欢迎指出,共同学习,共同进步。</p>
</blockquote>
<h1 id="附">附</h1><p>boot.img的头格式定义在：bootable\bootloader\lk\app\nandwrite\bootimg.h。如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> boot_img_hdr</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> magic[BOOT_MAGIC_SIZE];</span><br><span class="line">    <span class="keyword">unsigned</span> kernel_size;  <span class="comment">/* size in bytes */</span></span><br><span class="line">    <span class="keyword">unsigned</span> kernel_addr;  <span class="comment">/* physical load addr */</span></span><br><span class="line">    <span class="keyword">unsigned</span> ramdisk_size; <span class="comment">/* size in bytes */</span></span><br><span class="line">    <span class="keyword">unsigned</span> ramdisk_addr; <span class="comment">/* physical load addr */</span></span><br><span class="line">    <span class="keyword">unsigned</span> second_size;  <span class="comment">/* size in bytes */</span></span><br><span class="line">    <span class="keyword">unsigned</span> second_addr;  <span class="comment">/* physical load addr */</span></span><br><span class="line">    <span class="keyword">unsigned</span> tags_addr;    <span class="comment">/* physical addr for kernel tags */</span></span><br><span class="line">    <span class="keyword">unsigned</span> page_size;    <span class="comment">/* flash page size we assume */</span></span><br><span class="line">    <span class="keyword">unsigned</span> unused[<span class="number">2</span>];    <span class="comment">/* future expansion: should be 0 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> name[BOOT_NAME_SIZE]; <span class="comment">/* asciiz product name */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> cmdline[BOOT_ARGS_SIZE];</span><br><span class="line">    <span class="keyword">unsigned</span> id[<span class="number">8</span>]; <span class="comment">/* timestamp / checksum / sha1 / etc */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>当我们将编译生成的boot.img用文本编辑软件打开后，能看到boot_im_hdr格式定义的头，如下：<br>　　<img src="http://7xjdax.com1.z0.glb.clouddn.com/blogboot_img.png" alt="boot.img"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>记得当初学Linux时候，bootloader 代码相对来说还比较简单，主要几个汇编文件加上几个C文件，编译一个uboot就ok了。做Android驱动后，发现Android专门做了一个目录bootable来实现boot等相关功能。功能也比较多，所以就准备来研究一下这一部分。今天就先研究一下LK，LK全称为Little Kernel，是AP模块bootloader中实现的一个微型系统。</p>
<h2 id="boot架构">boot架构</h2>]]>
    
    </summary>
    
      <category term="Qualcomm" scheme="http://huaqianlee.me/tags/Qualcomm/"/>
    
      <category term="源码分析" scheme="http://huaqianlee.me/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="Android" scheme="http://huaqianlee.me/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android中adb(Android Debug Bridge)命令的用法]]></title>
    <link href="http://huaqianlee.me/2015/07/19/Android/Android%E4%B8%ADadb-Android-Debug-Bridge-%E5%91%BD%E4%BB%A4%E7%9A%84%E7%94%A8%E6%B3%95/"/>
    <id>http://huaqianlee.me/2015/07/19/Android/Android中adb-Android-Debug-Bridge-命令的用法/</id>
    <published>2015-07-19T11:29:58.000Z</published>
    <updated>2015-08-21T16:01:03.241Z</updated>
    <content type="html"><![CDATA[<p>　　昨天写Android日志系统相关博客时发觉自己对adb命令认知十分不够，所以特意去<a href="http://developer.android.com/tools/help/adb.html" target="_blank" rel="external">http://developer.android.com/tools/help/adb.html</a>学习了一下,今天准备按照自己的理解加以修改总结并整理出一篇博文。</p>
<h2 id="概览">概览</h2><p>　　adb是Android Debug Bridge的简写，按字面意思理解就是在开发者和Android之间搭建的一个debug桥。adb是一个连接仿真实例或者Android设备的命令行工具，是一个客服端-服务器模式的程序，包括如下三部分：<br>　<br>　　1. 一个运行在开发用的Android手机或者仿真器上面的client，我们可以通过adb命令调用client。其他像ADT插件和DDMS也会创建client。<br>　<br>　　2. 一个运行在开发用的Android手机或者仿真器后台的server，这个server负责管理本设备上运行的client和daemon(守护进程)。<br>　<br>　　3. 一个在每个仿真器或者Android设备后台运行的daemon。</p>
<blockquote>
<p>adb tool 可以再<sdk>/platform-tools/中找到　</sdk></p>
</blockquote>
<a id="more"></a>
<h2 id="adb工具的构成关系">adb工具的构成关系</h2><p>　　当启动adb client时，client会检查是否有server在运行，若无则启动一个server进程。server进程启动后，会绑定到TCP端口号为5037的端口，然后监听从adb clients发送来的命令（所有adb clients 使用同一端口5037与server通信）。然后，server通过扫描手机或仿真器用到的5555到5585之间的奇数端口号，在所有运行的实例之间建立连接。server在发现adb daemon的地方为那个端口建立连接。每个仿真器或者设备需给console连接提供一个偶数端口号，为adb连接提供一个奇数端口号。例如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Emulator <span class="number">1</span>, console: <span class="number">5554</span></span><br><span class="line">Emulator <span class="number">1</span>, adb: <span class="number">5555</span></span><br><span class="line">Emulator <span class="number">2</span>, console: <span class="number">5556</span></span><br><span class="line">Emulator <span class="number">2</span>, adb: <span class="number">5557</span></span><br><span class="line">and so on...</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>当server为所有仿真器创建了连接后,我们可以通过adb 命令进入这些实例,而且可以从任何client(或者script脚本)控制所有的仿真器.　</p>
</blockquote>
<h2 id="adb调试">adb调试</h2><p>　　首先需要同USB将电脑和设备相连,然后在开发者模式中打开USB debugging。4.2以上的系统默认都是隐藏了开发者模式，所以需要去到<strong>Setting&gt;About phone&gt;</strong>菜单下点击<strong>Build number</strong>七次以显示开发者模式,然后到开发者模式菜单下打开USB debugging。</p>
<h2 id="语法">语法</h2><p>　　我们能通过设备的命令行(shell终端)或者script脚本发出adb命令。用法如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb [<span class="operator">-d</span>|<span class="operator">-e</span>|<span class="operator">-s</span> &lt;serialNumber&gt;] &lt;<span class="built_in">command</span>&gt;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>如果仅仅一个仿真器或设备被连接,这adb命令将自己发送本机.如果有多个的话,需要用-d -s 或 -e来指明目标设备.　</p>
</blockquote>
<h2 id="adb命令详解">adb命令详解</h2><p>　</p>
<h4 id="目标设备">目标设备</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">-d</span>      <span class="comment">#指向连接的USB设备,如果USB设备超过一个则返回错误</span></span><br><span class="line"><span class="operator">-e</span>      <span class="comment">#指向运行的仿真器,如果超过一个仿真器则返回错误</span></span><br><span class="line"><span class="operator">-s</span>&lt;serialNumber&gt;  <span class="comment">#指向指定的仿真器或设备,如emulator-5556,详见下查询仿真器或设备</span></span><br></pre></td></tr></table></figure>
<p>　</p>
<h4 id="通用">通用</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">devices   <span class="comment">#打印所有连接的仿真器或设备,见下查询仿真器或设备</span></span><br><span class="line"><span class="built_in">help</span>    <span class="comment"># 打印所有adb命令</span></span><br><span class="line">version   <span class="comment">#打印adb工具的版本号</span></span><br></pre></td></tr></table></figure>
<p>　</p>
<h4 id="调试">调试</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">logcat [option] [filter-specs]    <span class="comment">#打印log</span></span><br><span class="line">bugreport      <span class="comment">#打印dumpsys,dumpstate及logcat日志</span></span><br><span class="line">jdwp       <span class="comment">#打印设备上的可用JDWP进程,可通过jdwp:&lt;pid&gt;连接指定JDWP进程,如:</span></span><br><span class="line">                adb forward tcp:<span class="number">8000</span> jdwp:<span class="number">472</span></span><br><span class="line">                jdb -attach localhost:<span class="number">8000</span>|</span><br></pre></td></tr></table></figure>
<p>　</p>
<h4 id="数据">数据</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">install &lt;apk&gt;          <span class="comment">#安装apk到仿真器或设备</span></span><br><span class="line">pull &lt;remote&gt; &lt;<span class="built_in">local</span>&gt;   <span class="comment">#拷贝指定文件到PC</span></span><br><span class="line">push &lt;<span class="built_in">local</span>&gt; &lt;remote&gt;   <span class="comment">#拷贝指定文件到设备</span></span><br></pre></td></tr></table></figure>
<p>　</p>
<h4 id="端口和网络">端口和网络</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">forward &lt;<span class="built_in">local</span>&gt; &lt;remote&gt;    <span class="comment">#指定socket连接的PC端口号,仿真器或设备端口号,如下:</span></span><br><span class="line">                                tcp:&lt;portnum&gt;</span><br><span class="line">                                <span class="built_in">local</span>:&lt;UNIX domain socket name&gt;</span><br><span class="line">                                dev:&lt;character device name&gt;</span><br><span class="line">                                jdwp:&lt;pid&gt;</span><br><span class="line">ppp &lt;tty&gt; [parm]...  <span class="comment">#通过USB运行PPP,不应该无故打开PPP连接</span></span><br></pre></td></tr></table></figure>
<p>　</p>
<h4 id="脚本语言">脚本语言</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">get-serialno   <span class="comment">#打印adb实体序列号,见下查询仿真器或设备</span></span><br><span class="line">get-state    <span class="comment">#打印仿真器或设备adb状态</span></span><br><span class="line"><span class="built_in">wait</span>-for-device     <span class="comment">#阻塞程序直到设备online</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#可以在后面添加其他命令,这样等设备以上线就执行,如下</span></span><br><span class="line">adb <span class="built_in">wait</span>-for-device shell getprop <span class="comment"># 一连上就getprop</span></span><br><span class="line">adb <span class="built_in">wait</span>-for-device install &lt;app&gt;.apk <span class="comment">#一连上就安装app</span></span><br></pre></td></tr></table></figure>
<p>　</p>
<h4 id="Server">Server</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">start-server  <span class="comment">#检查是否有server运行,若无,则启动</span></span><br><span class="line"><span class="built_in">kill</span>-server   <span class="comment">#终止server进程</span></span><br></pre></td></tr></table></figure>
<p>　</p>
<h4 id="Shell">Shell</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shell <span class="comment">#为仿真器或者设备打开一个远程shell终端,exit退出</span></span><br><span class="line">shell [shellCommand] <span class="comment">#打开一个远程终端,执行某指令后退出</span></span><br></pre></td></tr></table></figure>
<h3 id="查询仿真器或者设备">查询仿真器或者设备</h3><p>　　在执行adb命令前,我们可以通过命令去查看仿真器或设备的连接清单，命令如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb devices</span><br></pre></td></tr></table></figure></p>
<p>　　执行这个命令后，adb将打印每个实例的状态信息：</p>
<ul>
<li>Serial number ：adb通过仿真器或设备的console端口号创建的一个独一无二的字符串，格式为“type-consolePort”，如：emulator-5554
　</li>
<li>State ： 实例的连接状态，如下：　<ul>
<li>offline ：未连接或没回应</li>
<li>device ：实例连接到adb server，不过并不意味着Android完全启动可操作的，因为文件系统启动过程中，adb也可连接</li>
<li>no device ：未连接</li>
</ul>
</li>
</ul>
<p>　每个实例的输出如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[serialNumber] [state]</span><br><span class="line"></span><br><span class="line"><span class="comment">#eg</span></span><br><span class="line">adb devices</span><br><span class="line">List of devices attached</span><br><span class="line">emulator-<span class="number">5554</span>  device</span><br><span class="line">emulator-<span class="number">5556</span>  device</span><br><span class="line">emulator-<span class="number">5558</span>  device</span><br></pre></td></tr></table></figure></p>
<h3 id="发送命令到指定仿真器或设备">发送命令到指定仿真器或设备</h3><p>　　如果有多个仿真器或者设备同时运行，我们必须通过指定一个目标，否则将报错。我们可以通过-s来指定，用法如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">adb <span class="operator">-s</span> &lt;serialNumber&gt; &lt;<span class="built_in">command</span>&gt;  <span class="comment">#serialNumber可以用adb devices查看</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#eg</span></span><br><span class="line">adb <span class="operator">-s</span> emulator-<span class="number">5556</span> install helloWorld.apk</span><br></pre></td></tr></table></figure></p>
<p>　　如果有多个实例有效，只有一个仿真器，我们可以通过-e来指定仿真器。反之，若只有一个Android 设备，我们可以同-d来指定。</p>
<h3 id="安装app">安装app</h3><p>　　adb工具提供了从pc拷贝apk并安装到指定仿真器或设备的命令，不过必须指定.apk文件的路径，如下<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb install &lt;path_to_apk&gt;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>Android studio/Eclipse也是通过adb安装apk的，不过其ADT插件已经封装了这个过程</p>
</blockquote>
<h3 id="端口转发">端口转发</h3><p>　　我们可以用forward命令设置任意端口为forwarding端口，转发指定主机端口到仿真器或设备上的一个不同端口。也能设置转发到抽象的UNIX域sockets，如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">adb forward tcp:<span class="number">6100</span> tcp:<span class="number">7100</span> <span class="comment">#设置主机端口6100转发到目标端口7100</span></span><br><span class="line"></span><br><span class="line">adb forward tcp:<span class="number">6100</span> <span class="built_in">local</span>:logd</span><br></pre></td></tr></table></figure></p>
<h3 id="导入导出文件">导入导出文件</h3><p> 　　我们可以通过pull命令从仿真器或设备导出任意路径的文件，通过push导入文件到仿真器或设备的任意路径，如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#remote 仿真器或设备文件路径 local PC文件路径</span></span><br><span class="line">adb pull &lt;remote&gt; &lt;<span class="built_in">local</span>&gt; <span class="comment">#导出文件</span></span><br><span class="line">adb push &lt;<span class="built_in">local</span>&gt; &lt;remote&gt; <span class="comment">#导入文件</span></span><br></pre></td></tr></table></figure></p>
<h2 id="通过无线使用adb">通过无线使用adb</h2><p>　　虽然我们通常连接USB来使用adb，但是我们也能通过WiFi来使用。</p>
<ol>
<li>让Android设备与PC处于同一WiFi网络环境，不过并不是所有的接入点都能成功，我们需要防火墙配置正确来支持adb。
　</li>
<li>通过USB连接设备与PC。
　</li>
<li><p>确定PC上adb运行在USB模式</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ adb usb</span><br><span class="line">restarting <span class="keyword">in</span> USB mode</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过USB连接到设备</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ adb devices</span><br><span class="line">List of devices attached</span><br><span class="line"><span class="comment">######## device</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>重启PC adb,运行在tcpip模式</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ adb tcpip <span class="number">5555</span></span><br><span class="line">restarting <span class="keyword">in</span> TCP mode port: <span class="number">5555</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>找到Android设备的ip地址, Settings -&gt; About tablet -&gt; Status -&gt; IP address。
　</p>
</li>
<li><p>连接设备</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ adb connect <span class="comment">#.#.#.#</span></span><br><span class="line">connected to <span class="comment">#.#.#.#:5555</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>移除USB线，确认设备连接</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ adb devices</span><br><span class="line">List of devices attached</span><br><span class="line"><span class="comment">#.#.#.#:5555 device</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>如果连接丢失：</p>
<ol>
<li>确认PC机与Android设备是否处于同一WiFi网络环境。</li>
<li>通过adb connect重现连接。</li>
<li>重启adb host<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adb <span class="built_in">kill</span>-server</span><br><span class="line">adb start-server</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="其他命令">其他命令</h2><p>　　虽然官方文档已经介绍得挺详细了，但还是有一些命令没介绍到，如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">adb uninstall &lt;package name&gt; <span class="comment">#卸载指定app，参数为包名</span></span><br><span class="line">adb uninstall -k &lt;package name&gt;   <span class="comment">#卸载指定app，保留配置文件和缓存</span></span><br><span class="line">adb shell dumpsys activity <span class="comment">#列出activity栈(back stack)和任务(task)及其他组件信息和进程信息</span></span><br><span class="line">adb shell dumpsys packages <span class="comment">#(若出错，则dumpsy)列出一些系统信息和所有应用的信息。包括Features，Activity Resolver Table等。</span></span><br><span class="line">adb shell pm list permissions <span class="comment">#列出目标实例的所有权限</span></span><br><span class="line">adb shell pm list packages  <span class="comment">#列出目标设备上安装的所有app包名</span></span><br><span class="line">adb shell pm list features  <span class="comment">#列出目标设备上的所有feature</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#使用adb命令启动一个Activity</span></span><br><span class="line">adb shell am start PACKAGE_NAME/ACTIVITY_IN_PACKAGE  </span><br><span class="line">adb shell am start PACKAGE_NAME/FULLY_QUALIFIED_ACTIVITY    </span><br><span class="line"><span class="comment">#eg </span></span><br><span class="line">adb shell am start -n me.huaqianlee.example/.MainActivity  </span><br><span class="line">adb shell am start -n me.huaqianlee.example/me.huaqianlee.example.MainActivity</span><br><span class="line"></span><br><span class="line">adb shell screencap -p | perl -pe <span class="string">'s/\x0D\x0A/\x0A/g'</span> &gt; screen.png <span class="comment">#屏幕截图, 并使用perl命令保存截图</span></span><br><span class="line"></span><br><span class="line">adb shell input keyevent <span class="number">82</span> <span class="comment">#解锁屏幕</span></span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>　　昨天写Android日志系统相关博客时发觉自己对adb命令认知十分不够，所以特意去<a href="http://developer.android.com/tools/help/adb.html">http://developer.android.com/tools/help/adb.html</a>学习了一下,今天准备按照自己的理解加以修改总结并整理出一篇博文。</p>
<h2 id="概览">概览</h2><p>　　adb是Android Debug Bridge的简写，按字面意思理解就是在开发者和Android之间搭建的一个debug桥。adb是一个连接仿真实例或者Android设备的命令行工具，是一个客服端-服务器模式的程序，包括如下三部分：<br>　<br>　　1. 一个运行在开发用的Android手机或者仿真器上面的client，我们可以通过adb命令调用client。其他像ADT插件和DDMS也会创建client。<br>　<br>　　2. 一个运行在开发用的Android手机或者仿真器后台的server，这个server负责管理本设备上运行的client和daemon(守护进程)。<br>　<br>　　3. 一个在每个仿真器或者Android设备后台运行的daemon。</p>
<blockquote>
<p>adb tool 可以再<sdk>/platform-tools/中找到　</p>
</blockquote>]]>
    
    </summary>
    
      <category term="Tools" scheme="http://huaqianlee.me/tags/Tools/"/>
    
      <category term="译文" scheme="http://huaqianlee.me/tags/%E8%AF%91%E6%96%87/"/>
    
      <category term="Android" scheme="http://huaqianlee.me/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[怎么抓取Android日志文件]]></title>
    <link href="http://huaqianlee.me/2015/07/19/Android/%E6%80%8E%E4%B9%88%E6%8A%93%E5%8F%96Android%E6%B5%8B%E8%AF%95%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6-How-to-get-android-log-file/"/>
    <id>http://huaqianlee.me/2015/07/19/Android/怎么抓取Android测试日志文件-How-to-get-android-log-file/</id>
    <published>2015-07-19T03:43:04.000Z</published>
    <updated>2015-09-24T16:57:22.695Z</updated>
    <content type="html"><![CDATA[<p>　　<a href="http://huaqianlee.me/2015/07/18/Android/Android-Logging-system-Android%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F%E8%AF%A6%E8%A7%A3/" target="_blank" rel="external">Android日志系统详解</a><br>　　<a href="http://huaqianlee.me/2015/07/18/Android/%E6%80%8E%E4%B9%88%E7%94%A8Android%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F%E6%9B%B4%E5%A5%BD%E5%9C%B0%E5%8E%BB%E8%B0%83%E8%AF%95-How-to-debug-with-Android-logging/" target="_blank" rel="external">How to debug with Android logging</a><br>　　<a href="http://huaqianlee.me/2015/07/19/Android/%E6%80%8E%E4%B9%88%E6%8A%93%E5%8F%96Android%E6%B5%8B%E8%AF%95%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6-How-to-get-android-log-file/" target="_blank" rel="external">怎么抓取Android日志文件</a></p>
<p>　　前两篇blog分别介绍了Android logging系统及编程时怎么应用，关于kernel中的log系统，前面只是大概提及了一下，下次再详细分析。相信大家都知道调试时需要打开USB调试模式，接下来就分析一下怎么抓取日志文件。</p>
<h2 id="logcat命令详解">logcat命令详解</h2><p>　　logcat是最常用的命令之一，其语法如下；<br><a id="more"></a><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">shell@android:/ $ logcat --help</span><br><span class="line">logcat --help</span><br><span class="line">Usage: logcat [options] [filterspecs]</span><br><span class="line">options include:</span><br><span class="line">  <span class="operator">-s</span>              Set default filter to silent.</span><br><span class="line">                  Like specifying filterspec <span class="string">'*:s'</span></span><br><span class="line">  <span class="operator">-f</span> &lt;filename&gt;   Log to file. Default to stdout</span><br><span class="line">  -r [&lt;kbytes&gt;]   Rotate <span class="built_in">log</span> every kbytes. (<span class="number">16</span> <span class="keyword">if</span> unspecified). Requires <span class="operator">-f</span></span><br><span class="line">  -n &lt;count&gt;      Sets max number of rotated logs to &lt;count&gt;, default <span class="number">4</span></span><br><span class="line">  -v &lt;format&gt;     Sets the <span class="built_in">log</span> <span class="built_in">print</span> format, <span class="built_in">where</span> &lt;format&gt; is one of:</span><br><span class="line"></span><br><span class="line">                  brief process tag thread raw time threadtime long</span><br><span class="line"></span><br><span class="line">  -c              clear (flush) the entire <span class="built_in">log</span> and <span class="built_in">exit</span></span><br><span class="line">  <span class="operator">-d</span>              dump the <span class="built_in">log</span> and <span class="keyword">then</span> <span class="built_in">exit</span> (don<span class="string">'t block)</span><br><span class="line">  -t &lt;count&gt;      print only the most recent &lt;count&gt; lines (implies -d)</span><br><span class="line">  -g              get the size of the log'</span>s ring buffer and <span class="built_in">exit</span></span><br><span class="line">  -b &lt;buffer&gt;     Request alternate ring buffer, <span class="string">'main'</span>, <span class="string">'system'</span>, <span class="string">'radio'</span></span><br><span class="line">                  or <span class="string">'events'</span>. Multiple -b parameters are allowed and the</span><br><span class="line">                  results are interleaved. The default is -b main -b system.</span><br><span class="line">  -B              output the <span class="built_in">log</span> <span class="keyword">in</span> binary</span><br><span class="line"></span><br><span class="line">filterspecs are a series of  &lt;tag&gt;[:priority]</span><br><span class="line"></span><br><span class="line"><span class="built_in">where</span> &lt;tag&gt; is a <span class="built_in">log</span> component tag (or * <span class="keyword">for</span> all) and priority is:</span><br><span class="line">  V    Verbose</span><br><span class="line">  D    Debug</span><br><span class="line">  I    Info</span><br><span class="line">  W    Warn</span><br><span class="line">  E    Error</span><br><span class="line">  A    Assert </span><br><span class="line"></span><br><span class="line"><span class="string">'*'</span> means <span class="string">'*:d'</span> and &lt;tag&gt; by itself means &lt;tag&gt;:v</span><br><span class="line"></span><br><span class="line">If not specified on the commandline, filterspec is <span class="built_in">set</span> from ANDROID_LOG_TAGS.</span><br><span class="line">If no filterspec is found, filter defaults to <span class="string">'*:I'</span></span><br><span class="line"></span><br><span class="line">If not specified with -v, format is <span class="built_in">set</span> from ANDROID_PRINTF_LOG</span><br><span class="line">or defaults to <span class="string">"brief"</span></span><br></pre></td></tr></table></figure></p>
<p>部分重要参数详解如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[filterspecs]  以&lt;tag&gt;[:priority]序列形式显示指定priority及其以上，指定tag的日志，未指定tag的部分则按默认输出日志</span><br><span class="line"></span><br><span class="line">-b &lt;buffer&gt;</span><br><span class="line">    用于指定要操作的日志缓冲区:system,events,radio,main.系统默认的是system和main 。该选项可以出现多次，以指定多个日志缓冲区。例:</span><br><span class="line">  adb logcat -b system -b main -b events -b radio <span class="operator">-s</span> MyActivity:i</span><br><span class="line">     日志输出会指明当前查看的日志缓冲区如：</span><br><span class="line">     --------- beginning of /dev/<span class="built_in">log</span>/radio</span><br><span class="line">     --------- beginning of /dev/<span class="built_in">log</span>/events</span><br><span class="line">     --------- beginning of /dev/<span class="built_in">log</span>/system</span><br><span class="line">     --------- beginning of /dev/<span class="built_in">log</span>/main</span><br><span class="line"></span><br><span class="line">-v &lt;format&gt;  设置<span class="built_in">log</span>打印格式</span><br><span class="line">    brief — 显示prority/tag,产生日志的进程ID,和日志消息(默认格式)。</span><br><span class="line">    process — 显示priority,产生日志的进程ID,和日志消息</span><br><span class="line">    tag — 显示prority/tag,和消息</span><br><span class="line">    thread — 显示priority,线程ID和日志消息</span><br><span class="line">    raw — 只显示消息</span><br><span class="line">    time — 显示日期时间,priority/tag,产生日志的进程Id,和日志消息</span><br><span class="line">    long — 显示所有信息,日志消息另起一行显示,且每个日志间空一行</span><br></pre></td></tr></table></figure></p>
<h2 id="log文件抓取方式">log文件抓取方式</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#实时打印</span></span><br><span class="line">logcat main <span class="comment"># APP日志</span></span><br><span class="line">logcat radio <span class="comment"># 射频通话部分日志</span></span><br><span class="line">logcat events <span class="comment"># 系统事件日志</span></span><br><span class="line">logcat system <span class="comment"># 系统日志</span></span><br><span class="line">tcpdump <span class="comment"># 网络通信方面log抓取</span></span><br><span class="line">QXDM  <span class="comment">#高通平台有,主要是Modem射频网络相关的log,同radio但更强大,没怎么接触,不熟悉</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#状态信息</span></span><br><span class="line">adb shell cat /proc/kmsg <span class="comment"># kernel日志,每cat一次清零</span></span><br><span class="line">adb shell dmesg <span class="comment"># kernel日志,开机信息.(var/log/demsg)</span></span><br><span class="line">adb shell dumpstate <span class="comment"># 系统状态信息,比较全面,如:内存,CPU,log缓存等。可以帮助我们确定是否有内存耗光之类的问题</span></span><br><span class="line">adb shell dumpsys <span class="comment"># 系统service相关信息</span></span><br><span class="line">adb bugreport <span class="comment"># 包括上面所有状态信息</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Shell，Linux，Dos都支持通过“adb shell logcat &gt; filename.txt”的形式将打印信息写入到文件　</p>
</blockquote>
<p>　　dumpstate会打印很多有用的信息,我们也可以执行单独命令打印想要的部分信息,如通过“/system/bin/top -n 1 -d 1 -m 30 -t”获取CPU信息，但我现在对这个用得还不多,不是很熟悉,就不多说了,贴部分内容以供参考.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">Build: JZO54K</span><br><span class="line"></span><br><span class="line">Build fingerprint: <span class="string">'Xiaomi/mione_plus/mione_plus:4.1.2/JZO54K/4.12.5:user/release-keys'</span></span><br><span class="line"></span><br><span class="line">Bootloader: unknown</span><br><span class="line"></span><br><span class="line">Radio: msm</span><br><span class="line"></span><br><span class="line">Network: (unknown)</span><br><span class="line"></span><br><span class="line">Kernel: Linux version <span class="number">3.4</span>.<span class="number">0</span>-perf-g1ccebb5-<span class="number">00148</span>-g5f2009a (builder@taishan) (gcc version <span class="number">4.6</span>.x-google <span class="number">20120106</span> (prerelease) (GCC) ) <span class="comment">#1 SMP PREEMPT Fri Dec 27 16:52:36 CST 2013</span></span><br><span class="line"></span><br><span class="line">Command line: console=ttyHSL0,<span class="number">115200</span>,n8 androidboot.hardware=qcom kgsl.mmutype=gpummu vmalloc=<span class="number">400</span>M androidboot.emmc=<span class="literal">true</span> androidboot.serialno=d02b34a3 syspart=system1 androidboot.baseband=msm</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">------ UPTIME (uptime) ------</span><br><span class="line"></span><br><span class="line">up time: <span class="number">05</span>:<span class="number">07</span>:<span class="number">48</span>, idle time: <span class="number">09</span>:<span class="number">38</span>:<span class="number">57</span>, sleep time: <span class="number">00</span>:<span class="number">10</span>:<span class="number">10</span></span><br><span class="line"></span><br><span class="line">[uptime: <span class="number">0.1</span>s elapsed]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">------ MEMORY INFO (/proc/meminfo) ------</span><br><span class="line"></span><br><span class="line">MemTotal:         <span class="number">508016</span> kB</span><br><span class="line"></span><br><span class="line">MemFree:           <span class="number">36688</span> kB</span><br><span class="line"></span><br><span class="line">Buffers:           <span class="number">12100</span> kB</span><br><span class="line"></span><br><span class="line">Cached:            <span class="number">84336</span> kB</span><br><span class="line"></span><br><span class="line">SwapCached:            <span class="number">0</span> kB</span><br><span class="line"></span><br><span class="line">Active:           <span class="number">327208</span> kB</span><br><span class="line"></span><br><span class="line">Inactive:          <span class="number">62316</span> kB</span><br><span class="line"></span><br><span class="line">Active(anon):     <span class="number">294644</span> kB</span><br></pre></td></tr></table></figure></p>
<h2 id="后记">后记</h2><p>　　写这篇blog主要是因为前两篇有些内容没有表达出来，而在强迫症驱使下完成的。因为自己现在经验尚浅，可能有很多不完善和错误的地方，欢迎大家指出。另，如果想通过logcat直接打印kernel日志的话,可以参考<a href="http://blog.csdn.net/ryfjx6/article/details/7096018" target="_blank" rel="external">http://blog.csdn.net/ryfjx6/article/details/7096018</a>。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>　　<a href="http://huaqianlee.me/2015/07/18/Android/Android-Logging-system-Android%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F%E8%AF%A6%E8%A7%A3/">Android日志系统详解</a><br>　　<a href="http://huaqianlee.me/2015/07/18/Android/%E6%80%8E%E4%B9%88%E7%94%A8Android%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F%E6%9B%B4%E5%A5%BD%E5%9C%B0%E5%8E%BB%E8%B0%83%E8%AF%95-How-to-debug-with-Android-logging/">How to debug with Android logging</a><br>　　<a href="http://huaqianlee.me/2015/07/19/Android/%E6%80%8E%E4%B9%88%E6%8A%93%E5%8F%96Android%E6%B5%8B%E8%AF%95%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6-How-to-get-android-log-file/">怎么抓取Android日志文件</a></p>
<p>　　前两篇blog分别介绍了Android logging系统及编程时怎么应用，关于kernel中的log系统，前面只是大概提及了一下，下次再详细分析。相信大家都知道调试时需要打开USB调试模式，接下来就分析一下怎么抓取日志文件。</p>
<h2 id="logcat命令详解">logcat命令详解</h2><p>　　logcat是最常用的命令之一，其语法如下；<br>]]>
    
    </summary>
    
      <category term="Log" scheme="http://huaqianlee.me/tags/Log/"/>
    
      <category term="Android" scheme="http://huaqianlee.me/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[How to debug with Android logging]]></title>
    <link href="http://huaqianlee.me/2015/07/18/Android/%E6%80%8E%E4%B9%88%E7%94%A8Android%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F%E6%9B%B4%E5%A5%BD%E5%9C%B0%E5%8E%BB%E8%B0%83%E8%AF%95-How-to-debug-with-Android-logging/"/>
    <id>http://huaqianlee.me/2015/07/18/Android/怎么用Android日志系统更好地去调试-How-to-debug-with-Android-logging/</id>
    <published>2015-07-18T07:43:04.000Z</published>
    <updated>2015-09-24T16:59:31.787Z</updated>
    <content type="html"><![CDATA[<p>　　<a href="http://huaqianlee.me/2015/07/18/Android/Android-Logging-system-Android%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F%E8%AF%A6%E8%A7%A3/" target="_blank" rel="external">Android日志系统详解</a><br>　　<a href="http://huaqianlee.me/2015/07/18/Android/%E6%80%8E%E4%B9%88%E7%94%A8Android%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F%E6%9B%B4%E5%A5%BD%E5%9C%B0%E5%8E%BB%E8%B0%83%E8%AF%95-How-to-debug-with-Android-logging/" target="_blank" rel="external">How to debug with Android logging</a><br>　　<a href="http://huaqianlee.me/2015/07/19/Android/%E6%80%8E%E4%B9%88%E6%8A%93%E5%8F%96Android%E6%B5%8B%E8%AF%95%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6-How-to-get-android-log-file/" target="_blank" rel="external">怎么抓取Android日志文件</a></p>
<p>　　Android logging system为logging系统提供了一个Java类android.util.Log，也提供了一个c/c++的log库，在kernel中有四个设备节点，详细见：<a href="http://huaqianlee.me/2015/07/18/Android/Android-Logging-system-Android%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F%E8%AF%A6%E8%A7%A3/" target="_blank" rel="external">Android日志系统详解</a>。其系统架构如下：<br>　　　<img src="http://7xjdax.com1.z0.glb.clouddn.com/blogaplogd.jpg" alt="image by simon"></p>
<blockquote>
<p>此图与4.0以上的系统有些差异,新版Android增加了log_system</p>
</blockquote>
<a id="more"></a>
<h2 id="Java日志接口">Java日志接口</h2><p>　　此接口一般应用于编写APP时。</p>
<h3 id="Logging类">Logging类</h3><p>类名：android.util.Log，路径：frameworks/base/core/java/android/util/Log.java。主要方法如下：<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Log</span>.v();</span><br><span class="line"><span class="keyword">Log</span>.<span class="literal">d</span>();</span><br><span class="line"><span class="keyword">Log</span>.<span class="literal">i</span>();</span><br><span class="line"><span class="keyword">Log</span>.<span class="literal">w</span>();</span><br><span class="line"><span class="keyword">Log</span>.<span class="literal">e</span>();</span><br><span class="line"><span class="keyword">Log</span>.a();</span><br></pre></td></tr></table></figure></p>
<p>Log信息显示等级从高到底分别为：ERROR，WARN，INFO，DEBUG，VERBOSE。VERBOSE除了开发期间，是不应该被编译进APP的，DEBUG应该编译但在runtime被忽略，ERROR，WARN和INFO logs则一直被保留。更加详细的内容见 ：<a href="http://developer.android.com/reference/android/util/Log.html" target="_blank" rel="external">Log.html</a>。</p>
<blockquote>
<p>一个好的习惯是在自己的类中定义一个TAG常量，如：private static final String TAG = “MyActivity”;然后通过Log.i(TAG，”I am “+name);　</p>
</blockquote>
<h3 id="Demo">Demo</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">package me.huaqianlee.demo;</span><br><span class="line">import android.app.Activity;</span><br><span class="line">import android.os.Bundle;</span><br><span class="line">import android.widget.TextView;</span><br><span class="line">import android.util.Log; </span><br><span class="line"></span><br><span class="line">private static final String TAG = <span class="string">"MyActivity"</span>;</span><br><span class="line"></span><br><span class="line">public class Demo extends Activity &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line"></span><br><span class="line">        TextView tv = new TextView(this);</span><br><span class="line">        tv.setText(<span class="string">"Hello, I am andy lee!"</span>);</span><br><span class="line">        <span class="built_in">set</span>ContentView(tv);</span><br><span class="line"></span><br><span class="line">        Log.i(TAG, <span class="string">"this is a log.i message"</span>);</span><br><span class="line">        Log.v(TAG, <span class="string">"this  is a log.v message"</span>);</span><br><span class="line">        Log.d(TAG, <span class="string">"this  is a log.d message"</span>);</span><br><span class="line">        Log.w(TAG, <span class="string">"this  is a log.w message"</span>);</span><br><span class="line">        Log.e(TAG, <span class="string">"this  is a log.e message"</span>);</span><br><span class="line">        Log.a(TAG, <span class="string">"this  is a log.a message"</span>);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="C/C++日志接口">C/C++日志接口</h2><p>　　此接口一般应用于JNI和HAL层。</p>
<h3 id="Logging代码">Logging代码</h3><p>　　Log信息的等级同上，关键代码如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;cutils/log.h&gt; //路径：system/core/include/cutils/log.h</span></span><br><span class="line">/*公共日志宏*/</span><br><span class="line">ALOGV </span><br><span class="line">ALOGD </span><br><span class="line">ALOGI </span><br><span class="line">ALOGW </span><br><span class="line">ALOGE</span><br><span class="line"></span><br><span class="line">/*条件日志宏*/</span><br><span class="line">ALOGV_IF </span><br><span class="line">ALOGD_IF  </span><br><span class="line">ALOGI_IF  </span><br><span class="line">ALOGW_IF  </span><br><span class="line">ALOGE_IF </span><br><span class="line"></span><br><span class="line">// 在system/core/include/<span class="built_in">log</span>/log.h(被cutils/log.h包含)中定义如下：</span><br><span class="line"><span class="comment">#define CONDITION(cond)     (__builtin_expect((cond)!=0, 0))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#ifndef ALOGV_IF</span></span><br><span class="line"><span class="comment">#if LOG_NDEBUG</span></span><br><span class="line"><span class="comment">#define ALOGV_IF(cond, ...)   ((void)0)</span></span><br><span class="line"><span class="comment">#else</span></span><br><span class="line"><span class="comment">#define ALOGV_IF(cond, ...) \</span></span><br><span class="line">    ( (CONDITION(cond)) \</span><br><span class="line">    ? ((void)ALOG(LOG_VERBOSE, LOG_TAG, __VA_ARGS__)) \</span><br><span class="line">    : (void)<span class="number">0</span> )</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">#endif</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<ol>
<li>应该首先在c文件中定义LOG_TAG。</li>
<li>在Android.mk中添加：LOCAL_SHARED_LIBRARIES := liblog libcutils</li>
</ol>
</blockquote>
<h3 id="Demo-1">Demo</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt; </span></span><br><span class="line"><span class="comment">#include &lt;cutils/log.h&gt; /* log header file*/</span></span><br><span class="line"><span class="comment">#include &lt;cutils/properties.h&gt;</span></span><br><span class="line"></span><br><span class="line">/* define <span class="built_in">log</span> tag */</span><br><span class="line"><span class="comment">#ifdef LOG_TAG</span></span><br><span class="line"><span class="comment">#undef LOG_TAG</span></span><br><span class="line"><span class="comment">#define LOG_TAG "app"</span></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">int <span class="function"><span class="title">main</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">    ALOGV(<span class="string">"Verbose: _app"</span>);</span><br><span class="line">    ALOGD(<span class="string">"Debug: _app"</span>);</span><br><span class="line">    ALOGI(<span class="string">"Info: _app"</span>);</span><br><span class="line">    ALOGW(<span class="string">"Warn: _app"</span>);</span><br><span class="line">    ALOGE(<span class="string">"Error: _app"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"I am andy lee！\n"</span>);</span><br><span class="line">    <span class="built_in">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Android上的log格式">Android上的log格式</h2><p>　　　Log信息的格式及详解如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">tv_sec   tv_nsec     priority     pid    tid     tag     messageLen       Message</span><br><span class="line"></span><br><span class="line">tag: 标签</span><br><span class="line">tv_sec &amp; tv_nsec: 日志的时间戳</span><br><span class="line">pid: 打印日志的进程ID</span><br><span class="line">tid: 打印日志的线程ID</span><br><span class="line">Priority： 日志等级（或优先级），取值如下</span><br><span class="line">  V — Verbose (lowest priority)</span><br><span class="line">  D — Debug</span><br><span class="line">  I — Info</span><br><span class="line">  W — Warning</span><br><span class="line">  E — Error</span><br><span class="line">  A — Assert</span><br></pre></td></tr></table></figure></p>
<h2 id="Reference">Reference</h2><p><a href="http://log4think.com/debug-android-logging/" target="_blank" rel="external">http://log4think.com/debug-android-logging/</a><br><a href="http://developer.android.com/reference/android/util/Log.html" target="_blank" rel="external">http://developer.android.com/reference/android/util/Log.html</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>　　<a href="http://huaqianlee.me/2015/07/18/Android/Android-Logging-system-Android%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F%E8%AF%A6%E8%A7%A3/">Android日志系统详解</a><br>　　<a href="http://huaqianlee.me/2015/07/18/Android/%E6%80%8E%E4%B9%88%E7%94%A8Android%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F%E6%9B%B4%E5%A5%BD%E5%9C%B0%E5%8E%BB%E8%B0%83%E8%AF%95-How-to-debug-with-Android-logging/">How to debug with Android logging</a><br>　　<a href="http://huaqianlee.me/2015/07/19/Android/%E6%80%8E%E4%B9%88%E6%8A%93%E5%8F%96Android%E6%B5%8B%E8%AF%95%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6-How-to-get-android-log-file/">怎么抓取Android日志文件</a></p>
<p>　　Android logging system为logging系统提供了一个Java类android.util.Log，也提供了一个c/c++的log库，在kernel中有四个设备节点，详细见：<a href="http://huaqianlee.me/2015/07/18/Android/Android-Logging-system-Android%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F%E8%AF%A6%E8%A7%A3/">Android日志系统详解</a>。其系统架构如下：<br>　　　<img src="http://7xjdax.com1.z0.glb.clouddn.com/blogaplogd.jpg" alt="image by simon"></p>
<blockquote>
<p>此图与4.0以上的系统有些差异,新版Android增加了log_system</p>
</blockquote>]]>
    
    </summary>
    
      <category term="Log" scheme="http://huaqianlee.me/tags/Log/"/>
    
      <category term="Android" scheme="http://huaqianlee.me/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android日志系统(logging system)详解]]></title>
    <link href="http://huaqianlee.me/2015/07/18/Android/Android-Logging-system-Android%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F%E8%AF%A6%E8%A7%A3/"/>
    <id>http://huaqianlee.me/2015/07/18/Android/Android-Logging-system-Android日志系统详解/</id>
    <published>2015-07-18T05:43:04.000Z</published>
    <updated>2015-09-24T17:08:05.306Z</updated>
    <content type="html"><![CDATA[<p>　　<a href="http://huaqianlee.me/2015/07/18/Android/Android-Logging-system-Android%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F%E8%AF%A6%E8%A7%A3/" target="_blank" rel="external">Android日志系统详解</a><br>　　<a href="http://huaqianlee.me/2015/07/18/Android/%E6%80%8E%E4%B9%88%E7%94%A8Android%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F%E6%9B%B4%E5%A5%BD%E5%9C%B0%E5%8E%BB%E8%B0%83%E8%AF%95-How-to-debug-with-Android-logging/" target="_blank" rel="external">How to debug with Android logging</a><br>　　<a href="http://huaqianlee.me/2015/07/19/Android/%E6%80%8E%E4%B9%88%E6%8A%93%E5%8F%96Android%E6%B5%8B%E8%AF%95%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6-How-to-get-android-log-file/" target="_blank" rel="external">怎么抓取Android日志文件</a></p>
<p>　　不管是做Android应用还是做Android中间层和底层，Logging系统都是必须要了解的；因为Android不像单片机程序UCOS那么简单,可以很方便的单步调试。所以，就准备用一篇blog来分析一下logging system。</p>
<h2 id="概览">概览</h2><p>　　Android提供了一个灵活的logging系统，允许应用程序和系统组件等整个系统记录logging信息，它是独立于Linux Kernel的一个logging系统，kernel是通过”pr_info”、”printk”等存储，通过“dmesg”或“cat  /proc/kmsg”获取。不过，Android logging 系统也是将信息存在内核缓存区。其结构如下：　<br>　<br>　　　　<img src="http://7xjdax.com1.z0.glb.clouddn.com/blogAndroid-logging-system.png" alt="image by Tetsuyuki Kobabayshi"><br><a id="more"></a>　<br>Logging system由如下几部分组成：</p>
<ul>
<li>实现loging信息存储的kernel驱动和缓存区</li>
<li>C，C++和Java 类添加与读取log</li>
<li>一个单独浏览log信息的程序（logcat）</li>
<li>能够查看和过滤来自主机的log信息（通过Android Studio 或者 DDMS）</li>
</ul>
<p>其在kernel中为系统的不同部分提供了四个不同log缓存区，可以通过/dev/log查看这些不同的设备节点，如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/dev/<span class="built_in">log</span>/mian ： 主应用程序<span class="built_in">log</span>，除了下三个外，其他用户空间<span class="built_in">log</span>将写入此节点，包括System.out.print及System.erro.print等</span><br><span class="line">/dev/<span class="built_in">log</span>/events ： 系统事件信息，二进制<span class="built_in">log</span>信息将写入此节点，需要程序解析</span><br><span class="line">/dev/<span class="built_in">log</span>/radio ： 射频通话相关信息，tag 为<span class="string">"HTC_RIL"</span> <span class="string">"RILJ"</span> <span class="string">"RILC"</span> <span class="string">"RILD"</span> <span class="string">"RIL"</span> <span class="string">"AT"</span> <span class="string">"GSM"</span> <span class="string">"STK"</span>的<span class="built_in">log</span>信息将写入此节点</span><br><span class="line">/dev/<span class="built_in">log</span>/system ： 低等级系统信息和debugging,为了防止mian缓存区溢出,而从中分离出来</span><br></pre></td></tr></table></figure></p>
<p>log中的每条信息主要由四部分组成，如下：</p>
<ul>
<li>Tag</li>
<li>时间戳</li>
<li>log信息level(或者event的优先级)</li>
<li>log信息</li>
</ul>
<h2 id="Android_logger">Android logger</h2><p>　　logging的kernel driver部分被称作”logger”，其为系统日志提供支持，代码路径: kernel/drivers/staging/android/logger.c，此文件对4种logging缓存区加以支持。</p>
<h3 id="驱动">驱动</h3><p>　　Log的读写是通过正常Linux文件读写方式完成的，write path被很好的优化过，所以能很快的open()、write()及close()，这样就避免了logging在系统中有太多的开销，影响速度。
　</p>
<h5 id="Reading">Reading</h5><p>　　在用户空间，一个正常的read操作通常读取从log读取一个条目，每read一次返回一个log条目或者阻塞等待下一个log条目。设备可以打开非阻塞模式。每一个read请求应该至少请求LOGGER_ENTRY_MAX_LEN (4096)长度的数据。
　</p>
<h4 id="Writing">Writing</h4><p>　　当系统写数据到log时，driver将为每一个log条目保存pid（进程ID），tgid（线程组ID），timestamp（时间戳），这些信息将出现在用户空间的level，tag和message中。
　</p>
<h4 id="Ioctl">Ioctl</h4><p>　　Ioctl函数支持如下cmd：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- LOGGER_GET_LOG_BUF_SIZE ： <span class="built_in">log</span>条目缓存区的大小</span><br><span class="line">- LOGGER_GET_LOG_LEN ： <span class="built_in">log</span>数据的长度</span><br><span class="line">- LOGGER_GET_NEXT_ENTRY_LEN： 下一<span class="built_in">log</span>条目的大小</span><br><span class="line">- LOGGER_FLUSH_LOG ： 清除<span class="built_in">log</span>数据</span><br><span class="line">- LOGGER_GET_VERSION ： 获得logger版本</span><br><span class="line">- LOGGER_GET_VERSION ： 设置logger版本</span><br></pre></td></tr></table></figure>
<h3 id="设备节点">设备节点</h3><p>　　当一个用户空间执行的程序用合适的主设备号和次设备号打开设备节点后，设备节点就处于活动状态，这些设备节点如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root@msm8916_32:/ <span class="comment"># ls -al dev/log</span></span><br><span class="line">ls -al dev/<span class="built_in">log</span></span><br><span class="line">crw-rw-rw- root     <span class="built_in">log</span>       <span class="number">10</span>,  <span class="number">61</span> <span class="number">1970</span>-<span class="number">01</span>-<span class="number">09</span> <span class="number">02</span>:<span class="number">14</span> events</span><br><span class="line">crw-rw-rw- root     <span class="built_in">log</span>       <span class="number">10</span>,  <span class="number">62</span> <span class="number">1970</span>-<span class="number">01</span>-<span class="number">09</span> <span class="number">02</span>:<span class="number">14</span> main</span><br><span class="line">crw-rw-rw- root     <span class="built_in">log</span>       <span class="number">10</span>,  <span class="number">60</span> <span class="number">1970</span>-<span class="number">01</span>-<span class="number">09</span> <span class="number">02</span>:<span class="number">14</span> radio</span><br><span class="line">crw-rw-rw- root     <span class="built_in">log</span>       <span class="number">10</span>,  <span class="number">59</span> <span class="number">1970</span>-<span class="number">01</span>-<span class="number">09</span> <span class="number">02</span>:<span class="number">14</span> system</span><br></pre></td></tr></table></figure></p>
<h2 id="系统和应用程序logging">系统和应用程序logging</h2><p>　　所有的log信息在Java类中定义并做相应处理，最终一个格式化的消息通过C/C++库传递到内核驱动程序,然后再将消息存储在适当的缓冲区中。</p>
<h3 id="App_log">App  log</h3><p>　　App通过导入android.util.Log包来引入Log类，然后通过log方法写不同优先级的相关信息到log。Java类定义传递到log方法的tag为字符串常量，log方法通过这些字符串来获知信息的重要性，这样，当我们用log查看工具（如logcat）时，就可以过滤tag或者优先级来获取我们想要的信息。如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">root@msm8916_32:/ <span class="comment"># logcat</span></span><br><span class="line">logcat</span><br><span class="line">--------- beginning of system</span><br><span class="line">I/Vold    (  <span class="number">265</span>): Vold <span class="number">2.1</span> (the revenge) firing up</span><br><span class="line">D/Vold    (  <span class="number">265</span>): Volume sdcard1 state changing -<span class="number">1</span> (Initializing) -&gt; <span class="number">0</span> (No-Media)</span><br><span class="line">D/Vold    (  <span class="number">265</span>): Volume uicc0 state changing -<span class="number">1</span> (Initializing) -&gt; <span class="number">0</span> (No-Media)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">D/Vold    (  <span class="number">265</span>): Volume usbotg state changing -<span class="number">1</span> (Initializing) -&gt; <span class="number">0</span> (No-Media)</span><br><span class="line"></span><br><span class="line">D/Vold    (  <span class="number">265</span>): Volume uicc1 state changing -<span class="number">1</span> (Initializing) -&gt; <span class="number">0</span> (No-Media)</span><br><span class="line">I/Cryptfs (  <span class="number">265</span>): Check <span class="keyword">if</span> PFE is activated on Boot</span><br><span class="line">E/Cryptfs (  <span class="number">265</span>): Bad magic <span class="keyword">for</span> real block device /dev/block/bootdevice/by-name/userdata</span><br><span class="line">E/Cryptfs (  <span class="number">265</span>): Error getting crypt footer and key</span><br><span class="line">I/irsc_util(  <span class="number">316</span>): irsc tool created:<span class="number">0</span>xb70ff688</span><br><span class="line">I/irsc_util(  <span class="number">316</span>): Starting irsc tool</span><br><span class="line">I/irsc_util(  <span class="number">316</span>): Trying to open sec config file</span><br></pre></td></tr></table></figure></p>
<h3 id="Event_log">Event log</h3><p>　　Event logs是在android.util.EventLog.class中创建二进制log信息。Log条目由二进制tag代码和二进制参数构成。Event logs 文件存储在system/etc/event-log-tags中，通过cat system/etc/event-log-tags能查看其信息。如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">root@msm8916_32:/ <span class="comment"># cat system/etc/event-log-tags</span></span><br><span class="line">cat system/etc/event-log-tags</span><br><span class="line"><span class="number">42</span> answer (to life the universe etc|<span class="number">3</span>)</span><br><span class="line"><span class="number">314</span> pi</span><br><span class="line"><span class="number">1003</span> auditd (avc|<span class="number">3</span>)</span><br><span class="line"><span class="number">2718</span> e</span><br><span class="line"><span class="number">2719</span> configuration_changed (config mask|<span class="number">1</span>|<span class="number">5</span>)</span><br><span class="line"><span class="number">2720</span> sync (id|<span class="number">3</span>),(event|<span class="number">1</span>|<span class="number">5</span>),(<span class="built_in">source</span>|<span class="number">1</span>|<span class="number">5</span>),(account|<span class="number">1</span>|<span class="number">5</span>)</span><br><span class="line"><span class="number">2721</span> cpu (total|<span class="number">1</span>|<span class="number">6</span>),(user|<span class="number">1</span>|<span class="number">6</span>),(system|<span class="number">1</span>|<span class="number">6</span>),(iowait|<span class="number">1</span>|<span class="number">6</span>),(irq|<span class="number">1</span>|<span class="number">6</span>),(softirq|<span class="number">1</span>|<span class="number">6</span>)</span><br><span class="line"><span class="number">2722</span> battery_level (level|<span class="number">1</span>|<span class="number">6</span>),(voltage|<span class="number">1</span>|<span class="number">1</span>),(temperature|<span class="number">1</span>|<span class="number">1</span>)</span><br><span class="line"><span class="number">2723</span> battery_status (status|<span class="number">1</span>|<span class="number">5</span>),(health|<span class="number">1</span>|<span class="number">5</span>),(present|<span class="number">1</span>|<span class="number">5</span>),(plugged|<span class="number">1</span>|<span class="number">5</span>),(technology|<span class="number">3</span>)</span><br><span class="line"><span class="number">2724</span> power_sleep_requested (wakeLocksCleared|<span class="number">1</span>|<span class="number">1</span>)</span><br><span class="line"><span class="number">2725</span> power_screen_broadcast_send (wakelockCount|<span class="number">1</span>|<span class="number">1</span>)</span><br><span class="line"><span class="number">2726</span> power_screen_broadcast_<span class="keyword">done</span> (on|<span class="number">1</span>|<span class="number">5</span>),(broadcastDuration|<span class="number">2</span>|<span class="number">3</span>),(wakelockCount|<span class="number">1</span>|<span class="number">1</span>)</span><br><span class="line"><span class="number">2727</span> power_screen_broadcast_stop (<span class="built_in">which</span>|<span class="number">1</span>|<span class="number">5</span>),(wakelockCount|<span class="number">1</span>|<span class="number">1</span>)</span><br><span class="line"><span class="number">2728</span> power_screen_state (offOrOn|<span class="number">1</span>|<span class="number">5</span>),(becauseOfUser|<span class="number">1</span>|<span class="number">5</span>),(totalTouchDownTime|<span class="number">2</span>|<span class="number">3</span>),(touchCycles|<span class="number">1</span>|<span class="number">1</span>)</span><br><span class="line"><span class="number">2729</span> power_partial_wake_state (releasedorAcquired|<span class="number">1</span>|<span class="number">5</span>),(tag|<span class="number">3</span>)</span><br><span class="line"><span class="number">2730</span> battery_discharge (duration|<span class="number">2</span>|<span class="number">3</span>),(minLevel|<span class="number">1</span>|<span class="number">6</span>),(maxLevel|<span class="number">1</span>|<span class="number">6</span>)</span><br><span class="line"><span class="number">2740</span> location_controller</span><br></pre></td></tr></table></figure></p>
<h3 id="System_log">System log</h3><p>　　framework层的许多类通过使用system log 来与app的log信息区分开来。System log在android.util.Slog.clash中实现。</p>
<h3 id="log命令行工具">log命令行工具</h3><p>　　log命令行工具能用来给任意程序穿件log条目，此工具是内建与toolbox的多功能程序。在adb shell中输入log则会提示其用法，如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\Administrator&gt;adb shell</span><br><span class="line">root@msm8916_32:/ <span class="comment"># log</span></span><br><span class="line"><span class="built_in">log</span></span><br><span class="line">USAGE: <span class="built_in">log</span> [-p priorityChar] [-t tag] message</span><br><span class="line">        priorityChar should be one of:</span><br><span class="line">                v,d,i,w,e</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>toolbox: 具有管理内存、备份和数据清除功能的一个系统文件，用来对手机性能进行设置，需要root权限，能被软件调用。　</p>
</blockquote>
<h3 id="logwrapper">logwrapper</h3><p>　　logwrapper工具是用来捕捉stdout信息的，当需要从本地应用捕捉stdout信息到log时，它将十分有用。源码路径：system/core/logwrapper/logwrapper.c；用法如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">root@msm8916_32:/ <span class="comment"># logwrapper</span></span><br><span class="line">logwrapper</span><br><span class="line">Usage: logwrapper [<span class="operator">-a</span>] [<span class="operator">-d</span>] [-k] BINARY [ARGS ...]</span><br><span class="line"></span><br><span class="line">Forks and executes BINARY ARGS, redirecting stdout and stderr to</span><br><span class="line">the Android logging system. Tag is <span class="built_in">set</span> to BINARY, priority is</span><br><span class="line">always LOG_INFO.</span><br><span class="line"></span><br><span class="line"><span class="operator">-a</span>: Causes logwrapper to <span class="keyword">do</span> abbreviated logging.</span><br><span class="line">    This logs up to the first <span class="number">4</span>K and last <span class="number">4</span>K of the <span class="built_in">command</span></span><br><span class="line">    being run, and logs the output when the <span class="built_in">command</span> exits</span><br><span class="line"><span class="operator">-d</span>: Causes logwrapper to SIGSEGV when BINARY terminates</span><br><span class="line">    fault address is <span class="built_in">set</span> to the status of <span class="built_in">wait</span>()</span><br><span class="line">-k: Causes logwrapper to <span class="built_in">log</span> to the kernel <span class="built_in">log</span> instead of</span><br><span class="line">    the Android system <span class="built_in">log</span></span><br></pre></td></tr></table></figure></p>
<h3 id="Logcat命令">Logcat命令</h3><p>　　我们可以通过logcat命令查看log，这个命令文件在文件系统的system/bin目录下，所以我们可以到文件系统中执行logcat，或者直接adb logcat，都能查看log。adb用法可以查看<a href="http://developer.android.com/guide/developing/tools/adb.html" target="_blank" rel="external">adb.html</a>(需翻墙，等什么时候有空以中文形式移到blog来)。</p>
<ul>
<li>每一个有tag和优先级的log信息</li>
<li>可以通过tag和log等级过滤log信息</li>
<li>可以通过系统属性指定程序将stdout和stderr内容写入日志</li>
</ul>
<h2 id="在启动阶段默认打开Logcat">在启动阶段默认打开Logcat</h2><p>　　Android logging和kernel logging是完全不同的两种日志系统，另补充一点，kernel日志支持直接在用户空间向/dev/kmsg写入log条目。<a href="http://groups.google.com/group/android-kernel/browse_thread/thread/87d929863ce7c29e/f8b0da9ed6376b2f?pli=1" target="_blank" rel="external">groups.google.com</a>中介绍了如何在启动阶段launch Logcat，如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">it can be launched via init.rc as below.. </span><br><span class="line"></span><br><span class="line">service logcat /system/bin/logcat <span class="operator">-f</span> /dev/kmsg </span><br><span class="line">       oneshot</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>不推荐这样做，这样会增加打印开销，使系统卡顿　</p>
</blockquote>
<h2 id="Reference">Reference　　</h2><p><a href="http://elinux.org/Android_Logging_System" target="_blank" rel="external">http://elinux.org/Android_Logging_System</a> (大部分内容译自此文档)<br><a href="http://developer.android.com/guide/developing/tools/adb.html" target="_blank" rel="external">http://developer.android.com/guide/developing/tools/adb.html</a><br><a href="http://groups.google.com/group/android-kernel/browse_thread/thread/87d929863ce7c29e/f8b0da9ed6376b2f?pli=1" target="_blank" rel="external">http://groups.google.com/group/android-kernel/browse_thread/thread/87d929863ce7c29e/f8b0da9ed6376b2f?pli=1</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>　　<a href="http://huaqianlee.me/2015/07/18/Android/Android-Logging-system-Android%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F%E8%AF%A6%E8%A7%A3/">Android日志系统详解</a><br>　　<a href="http://huaqianlee.me/2015/07/18/Android/%E6%80%8E%E4%B9%88%E7%94%A8Android%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F%E6%9B%B4%E5%A5%BD%E5%9C%B0%E5%8E%BB%E8%B0%83%E8%AF%95-How-to-debug-with-Android-logging/">How to debug with Android logging</a><br>　　<a href="http://huaqianlee.me/2015/07/19/Android/%E6%80%8E%E4%B9%88%E6%8A%93%E5%8F%96Android%E6%B5%8B%E8%AF%95%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6-How-to-get-android-log-file/">怎么抓取Android日志文件</a></p>
<p>　　不管是做Android应用还是做Android中间层和底层，Logging系统都是必须要了解的；因为Android不像单片机程序UCOS那么简单,可以很方便的单步调试。所以，就准备用一篇blog来分析一下logging system。</p>
<h2 id="概览">概览</h2><p>　　Android提供了一个灵活的logging系统，允许应用程序和系统组件等整个系统记录logging信息，它是独立于Linux Kernel的一个logging系统，kernel是通过”pr_info”、”printk”等存储，通过“dmesg”或“cat  /proc/kmsg”获取。不过，Android logging 系统也是将信息存在内核缓存区。其结构如下：　<br>　<br>　　　　<img src="http://7xjdax.com1.z0.glb.clouddn.com/blogAndroid-logging-system.png" alt="image by Tetsuyuki Kobabayshi"><br>]]>
    
    </summary>
    
      <category term="Log" scheme="http://huaqianlee.me/tags/Log/"/>
    
      <category term="译文" scheme="http://huaqianlee.me/tags/%E8%AF%91%E6%96%87/"/>
    
      <category term="Android" scheme="http://huaqianlee.me/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android编译过程详解之三]]></title>
    <link href="http://huaqianlee.me/2015/07/12/Android/Android%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3%E4%B9%8B%E4%B8%89/"/>
    <id>http://huaqianlee.me/2015/07/12/Android/Android编译过程详解之三/</id>
    <published>2015-07-12T08:43:04.000Z</published>
    <updated>2015-10-27T06:39:45.041Z</updated>
    <content type="html"><![CDATA[<p>　　<a href="http://huaqianlee.me/2015/07/11/Android/Android%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3%E4%B9%8B%E4%B8%80/" target="_blank" rel="external">Android编译过程详解之一</a><br>　　<a href="http://huaqianlee.me/2015/07/12/Android/Android%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3%E4%B9%8B%E4%BA%8C/" target="_blank" rel="external">Android编译过程详解之二</a><br>　　<a href="http://huaqianlee.me/2015/07/12/Android/Android%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3%E4%B9%8B%E4%B8%89/" target="_blank" rel="external">Android编译过程详解之三</a><br>　　<a href="http://huaqianlee.me/2015/07/12/Android/About-ActivityNotFoundException-Unable-to-find-explicit-activity-class-Android-mk%E8%A7%A3%E6%9E%90/" target="_blank" rel="external">Android.mk解析</a></p>
<p>　　前两个篇基本完全涉及到了整个编译过程，接下来着重分析一下和公司产品相关的mk文件。有两个路径前面没有怎么提到过，如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">build/target/product <span class="comment"># 当前产品配置的mk文件，如：需要包含哪些apk在此产品中</span></span><br><span class="line">build/target/board  <span class="comment"># 硬件芯片配置的mk文件，如：GPU、是否支持浮点运算等</span></span><br></pre></td></tr></table></figure></p>
<p>　　除以上两个路径外，对产品定义的文件通常位于device目录下，还可以定义在vender目录下（不过Google已不建议如此做了），device目录下根据公司名和产品名分为两级目录，这个上文已经介绍过。通常一个产品定义如下四个文件：</p>
<ul>
<li>AndroidProducts.mk </li>
<li>产品版本定义文件（一般针对不同应用环境存在多个，如：msm8916_32.mk）</li>
<li>BoardConfig.mk</li>
<li>verndorsetup.sh</li>
</ul>
<h2 id="AndroidProducts-mk">AndroidProducts.mk</h2><a id="more"></a>
<p>此文件定义PRODUCT_MAKEFILES ，用来导入产品版本配置文件列表，如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. build\target\product\AndroidProducts.mk  ＃定义默认产品配置文件</span><br><span class="line">ifneq ($(TARGET_BUILD_APPS),)　＃根据TARGET_BUILD_APPS确定编译那些APP，TARGET_BUILD_APPS由上文envsetup.sh中的命令指定</span><br><span class="line">PRODUCT_MAKEFILES := \</span><br><span class="line">    $(LOCAL_DIR)/aosp_arm.mk \</span><br><span class="line">    $(LOCAL_DIR)/full.mk \</span><br><span class="line">    $(LOCAL_DIR)/generic_armv5.mk \</span><br><span class="line">    $(LOCAL_DIR)/aosp_x86.mk \</span><br><span class="line">    $(LOCAL_DIR)/full_x86.mk \</span><br><span class="line">    $(LOCAL_DIR)/aosp_mips.mk \</span><br><span class="line">    $(LOCAL_DIR)/full_mips.mk</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">PRODUCT_MAKEFILES := \</span><br><span class="line">    $(LOCAL_DIR)/core.mk \</span><br><span class="line">    $(LOCAL_DIR)/generic.mk \</span><br><span class="line">    $(LOCAL_DIR)/generic_x86.mk \</span><br><span class="line">    $(LOCAL_DIR)/generic_mips.mk \</span><br><span class="line">    $(LOCAL_DIR)/aosp_arm.mk \</span><br><span class="line">    $(LOCAL_DIR)/full.mk \</span><br><span class="line">    $(LOCAL_DIR)/aosp_x86.mk \</span><br><span class="line">    $(LOCAL_DIR)/full_x86.mk \</span><br><span class="line">    $(LOCAL_DIR)/aosp_mips.mk \</span><br><span class="line">    $(LOCAL_DIR)/full_mips.mk \</span><br><span class="line">    $(LOCAL_DIR)/vbox_x86.mk \</span><br><span class="line">    $(LOCAL_DIR)/sdk.mk \</span><br><span class="line">    $(LOCAL_DIR)/sdk_x86.mk \</span><br><span class="line">    $(LOCAL_DIR)/sdk_mips.mk \</span><br><span class="line">    $(LOCAL_DIR)/large_emu_hw.mk</span><br><span class="line">endif</span><br><span class="line">&lt;!--more--&gt;</span><br><span class="line"><span class="number">2</span>. device\qcom\msm8916_32\AndroidProducts.mk  <span class="comment"># 自定义产品配置文件，内容如下：</span></span><br><span class="line">　PRODUCT_MAKEFILES := \</span><br><span class="line">	　$(LOCAL_DIR)/msm8916_32.mk</span><br></pre></td></tr></table></figure></p>
<h2 id="产品版本定义文件">产品版本定义文件</h2><p>对于我用到文件则为msm8916_32.mk，主要定义此产品版本要编入哪些东西，主要变量如下：</p>
<h3 id="产品版本定义文件定义变量">产品版本定义文件定义变量</h3><table>
<thead>
<tr>
<th>常量</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>PRODUCT_NAME</td>
<td>最终用户将看到的完整产品名，会出现在“关于手机”信息中</td>
</tr>
<tr>
<td>PRODUCT_MODEL</td>
<td>产品的型号，这也是最终用户将看到的</td>
</tr>
<tr>
<td>PRODUCT_LOCALES</td>
<td>该产品支持的地区，以空格分格，例如：en_GB de_DE es_ES fr_CA</td>
</tr>
<tr>
<td>PRODUCT_PACKAGES</td>
<td>该产品版本中包含的 APK 应用程序，以空格分格，例如：Calendar Contacts</td>
</tr>
<tr>
<td>PRODUCT_DEVICE</td>
<td>该产品的工业设计的名称</td>
</tr>
<tr>
<td>PRODUCT_MANUFACTURER</td>
<td>制造商的名称</td>
</tr>
<tr>
<td>PRODUCT_BRAND</td>
<td>该产品专门定义的商标（如果有的话）</td>
</tr>
<tr>
<td>PRODUCT_PROPERTY_OVERRIDES</td>
<td>对于商品属性的定义</td>
</tr>
<tr>
<td>PRODUCT_COPY_FILES</td>
<td>编译该产品时需要拷贝的文件，以“源路径 : 目标路径”的形式</td>
</tr>
<tr>
<td>PRODUCT_OTA_PUBLIC_KEYS</td>
<td>对于该产品的 OTA 公开 key 的列表</td>
</tr>
<tr>
<td>PRODUCT_POLICY</td>
<td>产品使用的策略</td>
</tr>
<tr>
<td>PRODUCT_PACKAGE_OVERLAYS</td>
<td>指出是否要使用默认的资源或添加产品特定定义来覆盖</td>
</tr>
<tr>
<td>PRODUCT_CONTRIBUTORS_FILE</td>
<td>HTML 文件，其中包含项目的贡献者</td>
</tr>
<tr>
<td>PRODUCT_TAGS</td>
<td>该产品的标签，以空格分格</td>
</tr>
</tbody>
</table>
<h3 id="msm8916_32-mk">msm8916_32.mk</h3><p>此文件除了引入定义以上变量以外，还有如下关键代码：　<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$(call inherit-product, device/qcom/common/common.mk) <span class="comment"># 继承common.mk，此文件定义了很多值为配置文件、脚本文件的常量</span></span><br><span class="line"></span><br><span class="line">-include $(QCPATH)/common/config/rendering-engine.mk <span class="comment"># （字体渲染引擎开关）font rendering engine feature switch</span></span><br><span class="line">-include $(TOP)/customer/oem_common.mk <span class="comment"># 自定义，引入一些定制变量</span></span><br></pre></td></tr></table></figure></p>
<h2 id="BoardConfig-mk">BoardConfig.mk</h2><p>　　该文件用来配置硬件主板，它其中定义的都是设备底层的硬件特性。例如：该设备的主板相关信息，Wifi 相关信息，还有 bootloader，内核，radioimage 等信息。对于该文件的示例，请参看 Android 源码树已经有的文件。</p>
<h2 id="vendorsetup-sh">vendorsetup.sh</h2><p>　　该文件中作用是通过 add_lunch_combo 函数在 lunch 函数中添加一个菜单选项。该函数的参数是产品名称加上编译类型，中间以“-”连接，例如：add_lunch_combo full_lt26-userdebug。/build/envsetup.sh 会扫描所有 device 和 vender 二 级目 录下的名称 为”vendorsetup.sh”文件，并根据其中的内容来确定 lunch 函数的 菜单选项。</p>
<h2 id="后记">后记</h2><p>　　只有代码不会说谎，此文可能过时, 不过可以给你一个大致的脉络，然后再跟一下代码，就ok了。另，如需了解模块mk文件，参考我的另一篇博文：<a href="http://huaqianlee.me/2015/07/12/Android/About-ActivityNotFoundException-Unable-to-find-explicit-activity-class-Android-mk%E8%A7%A3%E6%9E%90/" target="_blank" rel="external">Android.mk解析</a>。我写这系列博客，主要参考了Google官网和另外两篇网上Google出来的文章，地址见下References，感谢Google，感谢另两篇文章的作者。
　　　</p>
<h2 id="References">References</h2><p><a href="http://source.android.com/source/initializing.html" target="_blank" rel="external">http://source.android.com/source/initializing.html</a> （需翻墙）<br><a href="http://source.android.com/source/building.html" target="_blank" rel="external">http://source.android.com/source/building.html</a> （需翻墙）<br><a href="http://www.cnblogs.com/mr-raptor/archive/2012/06/07/2540359.html" target="_blank" rel="external">http://www.cnblogs.com/mr-raptor/archive/2012/06/07/2540359.html</a><br><a href="http://www.ibm.com/developerworks/cn/opensource/os-cn-android-build/" target="_blank" rel="external">http://www.ibm.com/developerworks/cn/opensource/os-cn-android-build/</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>　　<a href="http://huaqianlee.me/2015/07/11/Android/Android%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3%E4%B9%8B%E4%B8%80/">Android编译过程详解之一</a><br>　　<a href="http://huaqianlee.me/2015/07/12/Android/Android%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3%E4%B9%8B%E4%BA%8C/">Android编译过程详解之二</a><br>　　<a href="http://huaqianlee.me/2015/07/12/Android/Android%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3%E4%B9%8B%E4%B8%89/">Android编译过程详解之三</a><br>　　<a href="http://huaqianlee.me/2015/07/12/Android/About-ActivityNotFoundException-Unable-to-find-explicit-activity-class-Android-mk%E8%A7%A3%E6%9E%90/">Android.mk解析</a></p>
<p>　　前两个篇基本完全涉及到了整个编译过程，接下来着重分析一下和公司产品相关的mk文件。有两个路径前面没有怎么提到过，如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">build/target/product <span class="comment"># 当前产品配置的mk文件，如：需要包含哪些apk在此产品中</span></span><br><span class="line">build/target/board  <span class="comment"># 硬件芯片配置的mk文件，如：GPU、是否支持浮点运算等</span></span><br></pre></td></tr></table></figure></p>
<p>　　除以上两个路径外，对产品定义的文件通常位于device目录下，还可以定义在vender目录下（不过Google已不建议如此做了），device目录下根据公司名和产品名分为两级目录，这个上文已经介绍过。通常一个产品定义如下四个文件：</p>
<ul>
<li>AndroidProducts.mk </li>
<li>产品版本定义文件（一般针对不同应用环境存在多个，如：msm8916_32.mk）</li>
<li>BoardConfig.mk</li>
<li>verndorsetup.sh</li>
</ul>
<h2 id="AndroidProducts-mk">AndroidProducts.mk</h2>]]>
    
    </summary>
    
      <category term="Qualcomm" scheme="http://huaqianlee.me/tags/Qualcomm/"/>
    
      <category term="源码分析" scheme="http://huaqianlee.me/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="编译" scheme="http://huaqianlee.me/tags/%E7%BC%96%E8%AF%91/"/>
    
      <category term="Android" scheme="http://huaqianlee.me/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android编译过程详解之二]]></title>
    <link href="http://huaqianlee.me/2015/07/12/Android/Android%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3%E4%B9%8B%E4%BA%8C/"/>
    <id>http://huaqianlee.me/2015/07/12/Android/Android编译过程详解之二/</id>
    <published>2015-07-12T08:43:04.000Z</published>
    <updated>2015-10-27T06:39:53.211Z</updated>
    <content type="html"><![CDATA[<p>　　<a href="http://huaqianlee.me/2015/07/11/Android/Android%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3%E4%B9%8B%E4%B8%80/" target="_blank" rel="external">Android编译过程详解之一</a><br>　　<a href="http://huaqianlee.me/2015/07/12/Android/Android%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3%E4%B9%8B%E4%BA%8C/" target="_blank" rel="external">Android编译过程详解之二</a><br>　　<a href="http://huaqianlee.me/2015/07/12/Android/Android%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3%E4%B9%8B%E4%B8%89/" target="_blank" rel="external">Android编译过程详解之三</a><br>　　<a href="http://huaqianlee.me/2015/07/12/Android/About-ActivityNotFoundException-Unable-to-find-explicit-activity-class-Android-mk%E8%A7%A3%E6%9E%90/" target="_blank" rel="external">Android.mk解析</a><br>　<br>　　配置好环境变量后，接下来要做的就是build了。为了提高编译速度，我们自定义了一个go.sh的脚本文件，详细下面解释。另，编译的时候一般会在后面加一个-j8来实现多线程编译，如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　　　./go.sh -j8 or make -j8／--jobs</span><br></pre></td></tr></table></figure></p>
<p>参数“-j“ 和”—jobs ”指定了同时编译的线程数量，通常是编译主机 CPU 支持的并发线程总数的 1 倍或 2 倍（如：在一个 4 核，每个核支持两个线程的 CPU 上，可以使用 make -j8 或 make -j16）。在调用 make 命令时，如果没有指定任何目标，则将编译默认目标“droid”（下面详解），然后将会编译出完整的 Android 系统镜像。</p>
<h2 id="build系统分类">build系统分类</h2><p>　　整个build系统的Make文件可以分为三类：</p>
<ol>
<li>build系统核心文件：定义整个build系统的框架，其他所有make文件都是在这个框架的基础上写出来的。</li>
<li>产品的make文件：位于device目录，通常以公司名和产品名分为两级目录，如：\device\qcom\msm8916_32。</li>
<li>模块的make文件：每个模块专用的make文件，kernel中统一名字为Makefile，其他为Android.mk。　</li>
</ol>
<h2 id="build结果">build结果</h2><p>所有的编译产物都将位于 /out 目录下，该目录下主要有以下几个子目录：</p>
<ul>
<li>/out/host/：该目录下包含了针对主机的 Android 开发工具的产物。即 SDK 中的各种工具，例如：emulator，adb，aapt 等。</li>
<li>/out/target/common/：该目录下包含了针对设备的共通的编译产物，主要是 Java 应用代码和 Java 库。</li>
<li>/out/target/product/<product_name>/：包含了针对特定设备的编译结果以及平台相关的 C/C++ 库和二进制文件。其中，<product_name>是具体目标设备的名称。</product_name></product_name></li>
<li>/out/dist/：包含了为多种分发而准备的包，通过“make disttarget”将文件拷贝到该目录，默认的编译目标不会产生该目录。<a id="more"></a>
Build 的产物中最重要的是几个镜像文件，它们都位于 /out/target/product/<product_name>/ 目录下。</product_name></li>
<li>system.img：包含了 Android OS 的系统文件，库，可执行文件以及预置的应用程序，将被挂载到根分区，描述的是设备上的system分区，即/system目录。</li>
<li>ramdisk.img：在启动时将被 Linux 内核挂载为只读分区，它包含了 /init 文件和一些配置文件。它用来挂载其他系统镜像、文件系统，并启动 init 进程。</li>
<li>userdata.img：将被挂载为 /data，包含了应用程序相关的数据以及和用户相关的数据。</li>
<li>boot.img：包含有Kernel及其启动参数、Ramdisk，以及可选的BootLoader第二阶段。</li>
<li>recovery.img：设备进入recovery模式时所加载的镜像，相当于除正常启动系统的第二系统，此系统用来更新正常系统，即刷机。</li>
</ul>
<h2 id="go-sh">go.sh</h2><p>先来分析一下go.sh文件，其代码如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"OEM_PROJECT_NAME=<span class="variable">$OEM_PROJECT_NAME</span>"</span></span><br><span class="line">start_time=`date +%s`</span><br><span class="line"><span class="built_in">source</span> customer/oem_define.sh <span class="comment"># 导入OEM厂商配置</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">setup_ccache</span></span>() &#123;　＃设置ccache，提高编译速度</span><br><span class="line">    <span class="built_in">export</span> CCACHE_DIR=../.ccache</span><br><span class="line">    <span class="built_in">export</span> USE_CCACHE=<span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> [ ! <span class="operator">-d</span> <span class="variable">$CCACHE_DIR</span> ];<span class="keyword">then</span> </span><br><span class="line">    	prebuilts/misc/linux-x86/ccache/ccache -M <span class="number">10</span>G　　＃设置编译文件缓存大小为<span class="number">10</span>G</span><br><span class="line">    <span class="keyword">fi</span>    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">delete_ccache</span></span>() &#123; <span class="comment"># 删除缓存</span></span><br><span class="line">    prebuilts/misc/linux-x86/ccache/ccache -C</span><br><span class="line">    rm -rf <span class="variable">$CCACHE_DIR</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setup_ccache <span class="comment"># 调用setup_ccache()</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$1</span>"</span> = <span class="string">"clean"</span> ];<span class="keyword">then</span>  <span class="comment">#如果第一个参数为clean，清除ccache缓存</span></span><br><span class="line">	delete_ccache</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">oemtools/copy_mp.sh  <span class="comment"># copy modem bin文件</span></span><br><span class="line">make <span class="variable">$1</span> <span class="variable">$2</span> <span class="variable">$3</span> <span class="variable">$4</span> <span class="variable">$5</span>  <span class="comment"># 调用Makefile编译，下面详解 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">end_time=`date +%s`</span><br><span class="line"><span class="built_in">let</span> min=(<span class="variable">$end_time</span>-<span class="variable">$start_time</span>)/<span class="number">60</span></span><br><span class="line"><span class="built_in">let</span> sec=(<span class="variable">$end_time</span>-<span class="variable">$start_time</span>)%<span class="number">60</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"build_time <span class="variable">$min</span> mins <span class="variable">$sec</span> seconds"</span>  <span class="comment">#打印编译时间</span></span><br></pre></td></tr></table></figure></p>
<h2 id="make">make</h2><p>　　执行make命令的时候会执行当前路径的Makefile文件，内容如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### DO NOT EDIT THIS FILE ###</span></span><br><span class="line">include build/core/main.mk 　　</span><br><span class="line"><span class="comment">### DO NOT EDIT THIS FILE ###</span></span><br></pre></td></tr></table></figure></p>
<p>　　相信上面的文件大家都能看懂，接下来就解析一下main.mk，此文件中定义了整个Android的编译关系，主要文件（黄色背景除$开头的文件皆位于build\core\目录下）关系如下：<br><img src="http://7xjdax.com1.z0.glb.clouddn.com/20150711Makemain_mk.png" alt="make"></p>
<h3 id="main-mk">main.mk</h3><p>　　此文件首先对编译环境进行检查，然后引入其他相关mk文件，另，还将定义几个主要的make目标，如droid，sdk等，关键代码如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 主要引入了如下mk文件</span></span><br><span class="line">include $(BUILD_SYSTEM)/help.mk <span class="comment"># Targets that provide quick help on the build system.</span></span><br><span class="line">-include $(OEM_RESOURCE_DIR)/CustomerSpec.mk <span class="comment"># 自定义，引入项目配置文件</span></span><br><span class="line">-include $(TOP)/customer/oem_define.mk <span class="comment"># 导入OEM厂商配置</span></span><br><span class="line">-include $(BUILD_SYSTEM)/config.mk <span class="comment">#整个build系统的配置文件</span></span><br><span class="line">-include $(BUILD_SYSTEM)/cleanbuild.mk <span class="comment"># 允许强制清除编译文件</span></span><br><span class="line">-include vendor/google/build/config.mk <span class="comment">#Google特性配置</span></span><br><span class="line">-include $(BUILD_SYSTEM)/definitions.mk <span class="comment"># 引入Build 系统其他文件将用到的函数和全局变量定义。例如：</span></span><br><span class="line">    my-dir : 当前路径</span><br><span class="line">    all-subdir-makefiles ：当前目录及子目录Makefile文件</span><br><span class="line">    all-subdir-java-files：当前目录及子目录java文件</span><br><span class="line">    all-java-files-under： 指定目录及子目录java文件</span><br><span class="line">    sign-package ： 对package签名</span><br><span class="line">    include $(BUILD_SYSTEM)/distdir.mk <span class="comment"># 定义dist目标，dist目标用来拷贝文件到指定路径</span></span><br><span class="line">-include $(BUILD_SYSTEM)/dex_preopt.mk <span class="comment"># 针对启动jar包的预优化</span></span><br><span class="line">-include build/core/pdk_config.mk <span class="comment"># pdk（Platform Development Kit）的配置包</span></span><br><span class="line">-include $(BUILD_SYSTEM)/post_clean.mk  <span class="comment"># 在前一次 Build 的基础上检查当前 Build 的配置，并执行必要清理工作</span></span><br><span class="line">-include $(BUILD_SYSTEM)/legacy_prebuilts.mk <span class="comment"># 定义GRANDFATHERED_ALL_PREBUILT </span></span><br><span class="line">-include $(BUILD_SYSTEM)/Makefile <span class="comment"># main.mk的辅助文件</span></span><br><span class="line">-include $(BUILD_SYSTEM)/help.mk <span class="comment"># 列出主要的make目标及其说明</span></span><br><span class="line">-include $(ONE_SHOT_MAKEFILE) <span class="comment"># 一个变量，当使用“mm”编译时，值为当前指定路径下的mk文件路径</span></span><br><span class="line">...</span><br><span class="line">DEFAULT_GOAL := droid <span class="comment"># 定义默认make目标</span></span><br><span class="line"><span class="comment"># 依据不同编译条件，包含不同目录</span></span><br><span class="line">subdirs += build/tools/acp</span><br><span class="line">subdirs := $(TOP)</span><br><span class="line"><span class="comment"># 导入所有Android.mk,顶层Android.mk下详解</span></span><br><span class="line">subdir_makefiles := \</span><br><span class="line">	$(shell build/tools/findleaves.py --prune=$(OUT_DIR)  --prune=.repo --prune=.git --prune=kernel --prune=prj_out --prune=links --prune=.svn $(subdirs) Android.mk)</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>编译器平台相关的mk文件在build\core\combo路径下，如：javac.mk、select.mk等　</p>
</blockquote>
<p>另，因定义了DEFAULT_GOAL := droid，当在根目录输入“Make”时，实际上就等同于我们执行“make droid”。加载include的所有文件，完成对所有mk文件的解析以后就会寻找生成droid的规则，依次生成它的依赖，直到所有满足的模块被编译好，然后使用相应的工具打包成相应的img。　</p>
<p>　droid目标依赖于很多其他目标，这些目标相互配合实现了整个系统的编译，droid依赖的其他make目标关系如下图：<br>　　<img src="http://7xjdax.com1.z0.glb.clouddn.com/blogdroid.png" alt="droid依赖目标关系图">　</p>
<p>　build系统中的一些make目标如下：</p>
<h3 id="droid的依赖目标">droid的依赖目标</h3><table>
<thead>
<tr>
<th>目标</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>$(modules_to_install)</td>
<td>modules_to_install 变量包含了当前配置下所有会被安装的模块（一个模块是否会被安装依赖于该产品的配置文件，模块的标签等信息），因此该目标将导致所有会被安装的模块的编译</td>
</tr>
<tr>
<td>$(modules_to_check)</td>
<td>该目标用来确保我们定义的构建模块是没有冗余的</td>
</tr>
<tr>
<td>$(INSTALLED_ANDROID_INFO_TXT_TARGET)</td>
<td>该目标会生成一个关于当前 Build 配置的设备信息的文件，该文件的生成路径是：out/target/product/<product_name>/android-info.txt</product_name></td>
</tr>
<tr>
<td>systemimage</td>
<td>生成 system.img</td>
</tr>
<tr>
<td>$(INSTALLED_BOOTIMAGE_TARGET)</td>
<td>生成 boot.img</td>
</tr>
<tr>
<td>$(INSTALLED_RECOVERYIMAGE_TARGET)</td>
<td>生成 recovery.img</td>
</tr>
<tr>
<td>$(INSTALLED_USERDATAIMAGE_TARGET)</td>
<td>生成 userdata.img</td>
</tr>
<tr>
<td>$(INSTALLED_CACHEIMAGE_TARGET)</td>
<td>生成 cache.img</td>
</tr>
<tr>
<td>$(INSTALLED_FILES_FILE)</td>
<td>该目标会生成 out/target/product/<product_name>/ installed-files.txt 文件，该文件中内容是当前系统镜像中已经安装的文件列表</product_name></td>
</tr>
</tbody>
</table>
<h3 id="其他主要目标">其他主要目标</h3><table>
<thead>
<tr>
<th>目标</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>make clean</td>
<td>执行清理，等同于：rm -rf out/</td>
</tr>
<tr>
<td>make sdk</td>
<td>编译出 Android 的 SDK</td>
</tr>
<tr>
<td>make clean-sdk</td>
<td>清理 SDK 的编译产物</td>
</tr>
<tr>
<td>make update-api</td>
<td>更新 API。在 framework API 改动之后，需要首先执行该命令来更新 API，公开的 API 记录在 frameworks/base/api 目录下</td>
</tr>
<tr>
<td>make dist</td>
<td>执行 Build，并将 MAKECMDGOALS 变量定义的输出文件拷贝到 /out/dist 目录</td>
</tr>
<tr>
<td>make all</td>
<td>编译所有内容，不管当前产品的定义中是否会包含</td>
</tr>
<tr>
<td>make help</td>
<td>帮助信息，显示主要的 make 目标</td>
</tr>
<tr>
<td>make snod</td>
<td>从已经编译出的包快速重建系统镜像</td>
</tr>
<tr>
<td>make libandroid_runtime</td>
<td>编译所有 JNI framework 内容</td>
</tr>
<tr>
<td>make framework</td>
<td>编译所有 Java framework 内容</td>
</tr>
<tr>
<td>make services</td>
<td>编译系统服务和相关内容</td>
</tr>
<tr>
<td>make <local_target></local_target></td>
<td>编译一个指定的模块，local_target 为模块的名称</td>
</tr>
<tr>
<td>make clean-<local_target></local_target></td>
<td>清理一个指定模块的编译结果</td>
</tr>
<tr>
<td>make dump-products</td>
<td>显示所有产品的编译配置信息，例如：产品名，产品支持的地区语言，产品中会包含的模块等信息</td>
</tr>
<tr>
<td>make PRODUCT-xxx-yyy</td>
<td>编译某个指定的产品</td>
</tr>
<tr>
<td>make bootimage</td>
<td>生成 boot.img</td>
</tr>
<tr>
<td>make recoveryimage</td>
<td>生成 recovery.img</td>
</tr>
<tr>
<td>make userdataimage</td>
<td>生成 userdata.img</td>
</tr>
<tr>
<td>make cacheimage</td>
<td>生成 cache.img</td>
</tr>
</tbody>
</table>
<h3 id="build\core\config-mk">build\core\config.mk</h3><p>　　此文件是最重要的mk文件之一，主要定义不同模块的编译常量、编译参数及常见文件后缀（如.zip,.jar,.apk）；根据BoardConfig.mk配置产品相关参数；设置常用工具的路径。其主要源码如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义标准源文件路径等的环境变量</span></span><br><span class="line">SRC_HEADERS := \</span><br><span class="line">	$(TOPDIR)system/core/include \</span><br><span class="line">	$(TOPDIR)hardware/libhardware/include \</span><br><span class="line">	$(TOPDIR)hardware/libhardware_legacy/include \</span><br><span class="line">	$(TOPDIR)hardware/ril/include \</span><br><span class="line">	$(TOPDIR)libnativehelper/include \</span><br><span class="line">	$(TOPDIR)frameworks/native/include \</span><br><span class="line">	$(TOPDIR)frameworks/native/opengl/include \</span><br><span class="line">	$(TOPDIR)frameworks/av/include \</span><br><span class="line">	$(TOPDIR)frameworks/base/include \</span><br><span class="line">	$(TOPDIR)external/skia/include</span><br><span class="line">SRC_HOST_HEADERS:=$(TOPDIR)tools/include  </span><br><span class="line">SRC_LIBRARIES:= $(TOPDIR)libs</span><br><span class="line">SRC_SERVERS:= $(TOPDIR)servers</span><br><span class="line">SRC_TARGET_DIR := $(TOPDIR)build/target</span><br><span class="line">SRC_API_DIR := $(TOPDIR)prebuilts/sdk/api</span><br><span class="line">...</span><br><span class="line">include $(BUILD_SYSTEM)/dumpvar.mk  <span class="comment"># build之前显示此次build的配置信息</span></span><br><span class="line">include $(BUILD_SYSTEM)/pathmap.mk <span class="comment"># 将许多头文件的路径通过名值对的方式定义为映射表，并提供 include-path-for 函数来获取。如，通过$(call include-path-for, frameworks-native)便可以获取到 framework 本地代码需要的头文件路径</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义编译命令常量，对应相关mk文件，每个常量描述一种类型模块的编译方式</span></span><br><span class="line">BUILD_COMBOS:= $(BUILD_SYSTEM)/combo <span class="comment"># 编译器平台相关mk文件</span></span><br><span class="line">CLEAR_VARS:= $(BUILD_SYSTEM)/clear_vars.mk <span class="comment"># 清除之前定义环境变量</span></span><br><span class="line">BUILD_HOST_STATIC_LIBRARY:= $(BUILD_SYSTEM)/host_static_library.mk  <span class="comment"># 编译主机静态库，指编译此系统的主机，即PC</span></span><br><span class="line">BUILD_HOST_SHARED_LIBRARY:= $(BUILD_SYSTEM)/host_shared_library.mk <span class="comment"># 编译主机动态库</span></span><br><span class="line">BUILD_STATIC_LIBRARY:= $(BUILD_SYSTEM)/static_library.mk <span class="comment"># 编译设备静态库</span></span><br><span class="line">BUILD_RAW_STATIC_LIBRARY := $(BUILD_SYSTEM)/raw_static_library.mk <span class="comment"># 编译原生静态库</span></span><br><span class="line">BUILD_SHARED_LIBRARY:= $(BUILD_SYSTEM)/shared_library.mk <span class="comment"># 编译设备动态库</span></span><br><span class="line">BUILD_EXECUTABLE:= $(BUILD_SYSTEM)/executable.mk <span class="comment"># 编译设备可执行文件</span></span><br><span class="line">BUILD_RAW_EXECUTABLE:= $(BUILD_SYSTEM)/raw_executable.mk <span class="comment"># 编译原生可执行文件</span></span><br><span class="line">BUILD_HOST_EXECUTABLE:= $(BUILD_SYSTEM)/host_executable.mk <span class="comment"># 编译主机可执行文件</span></span><br><span class="line">BUILD_PACKAGE:= $(BUILD_SYSTEM)/package.mk <span class="comment"># 编译apk文件</span></span><br><span class="line">BUILD_PHONY_PACKAGE:= $(BUILD_SYSTEM)/phony_package.mk <span class="comment"># </span></span><br><span class="line">BUILD_HOST_PREBUILT:= $(BUILD_SYSTEM)/host_prebuilt.mk <span class="comment"># 处理一个或多个主机使用的已编译文件，依赖multi_prebuilt.mk</span></span><br><span class="line">BUILD_PREBUILT:= $(BUILD_SYSTEM)/prebuilt.mk <span class="comment"># 处理一个已经编译好的文件，如：jar包</span></span><br><span class="line">BUILD_MULTI_PREBUILT:= $(BUILD_SYSTEM)/multi_prebuilt.mk <span class="comment"># 处理一个或多个已编译文件，依赖prebuilt.mk</span></span><br><span class="line">BUILD_JAVA_LIBRARY:= $(BUILD_SYSTEM)/java_library.mk <span class="comment"># 编译设备动态java库</span></span><br><span class="line">BUILD_STATIC_JAVA_LIBRARY:= $(BUILD_SYSTEM)/static_java_library.mk <span class="comment"># 编译设备静态java库 </span></span><br><span class="line">BUILD_HOST_JAVA_LIBRARY:= $(BUILD_SYSTEM)/host_java_library.mk  <span class="comment"># 编译主机动态java库</span></span><br><span class="line">BUILD_DROIDDOC:= $(BUILD_SYSTEM)/droiddoc.mk</span><br><span class="line">BUILD_COPY_HEADERS := $(BUILD_SYSTEM)/copy_headers.mk</span><br><span class="line">BUILD_NATIVE_TEST := $(BUILD_SYSTEM)/native_test.mk</span><br><span class="line">BUILD_HOST_NATIVE_TEST := $(BUILD_SYSTEM)/host_native_test.mk</span><br><span class="line">BUILD_NOTICE_FILE := $(BUILD_SYSTEM)/notice_files.mk</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">include $(BUILD_SYSTEM)/envsetup.mk <span class="comment">#定义全局变量、用户特殊编译配置等 ，下详解</span></span><br><span class="line"><span class="comment"># Boards may be defined under $(SRC_TARGET_DIR)/board/$(TARGET_DEVICE)</span></span><br><span class="line"><span class="comment"># or under vendor/*/$(TARGET_DEVICE).  Search in both places, but</span></span><br><span class="line"><span class="comment"># make sure only one exists.</span></span><br><span class="line"><span class="comment"># Real boards should always be associated with an OEM vendor.</span></span><br><span class="line"><span class="comment">#在$(SRC_TARGET_DIR)/board/$(TARGET_DEVICE) 或vendor/*/$(TARGET_DEVICE)中搜索BoardConfig.mk文件，但两个路径中只能存在一个mk文件</span></span><br><span class="line">board_config_mk := \</span><br><span class="line">	$(strip $(wildcard \</span><br><span class="line">		$(SRC_TARGET_DIR)/board/$(TARGET_DEVICE)/BoardConfig.mk \</span><br><span class="line">		$(shell <span class="built_in">test</span> <span class="operator">-d</span> device &amp;&amp; find device -maxdepth <span class="number">4</span> -path <span class="string">'*/$(TARGET_DEVICE)/BoardConfig.mk'</span>) \</span><br><span class="line">		$(shell <span class="built_in">test</span> <span class="operator">-d</span> vendor &amp;&amp; find vendor -maxdepth <span class="number">4</span> -path <span class="string">'*/$(TARGET_DEVICE)/BoardConfig.mk'</span>) \</span><br><span class="line">	))</span><br><span class="line">ifeq ($(board_config_mk),)</span><br><span class="line">  $(error No config file found <span class="keyword">for</span> TARGET_DEVICE $(TARGET_DEVICE))</span><br><span class="line">endif</span><br><span class="line">ifneq ($(words $(board_config_mk)),<span class="number">1</span>)</span><br><span class="line">  $(error Multiple board config files <span class="keyword">for</span> TARGET_DEVICE $(TARGET_DEVICE): $(board_config_mk))</span><br><span class="line">endif</span><br><span class="line">include $(board_config_mk)</span><br><span class="line">ifeq ($(TARGET_ARCH),)</span><br><span class="line">  $(error TARGET_ARCH not defined by board config: $(board_config_mk))</span><br><span class="line">endif</span><br><span class="line">TARGET_DEVICE_DIR := $(patsubst %/,%,$(dir $(board_config_mk)))</span><br><span class="line">board_config_mk :=</span><br></pre></td></tr></table></figure></p>
<p>　　不同类型的模块的编译过程会有一些相同的步骤，例如：编译一个 Java 库和编译一个 APK 文件都需要定义如何编译 Java 文件。因此，config.mk中导入的mk 文件的定义中会包含一些共同的代码逻辑。为了减少代码冗余，将共同的代码复用起来，将共同代码放到专门的文件中，然后在其他文件中包含这些文件的方式来实现的。这些包含关系如下图所示：<br>　　　<img src="http://7xjdax.com1.z0.glb.clouddn.com/blogmk.png" alt="模块mk文件的关系"></p>
<h3 id="build\core\_envsetup-mk">build\core\ envsetup.mk</h3><p>此文件主要包括product_config.mk文件，配置build系统需要的环境变量，确定当前编译的主机平台信息，然后指定编译时输出文件的OUT目录。部分关键代码如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># The product defaults to generic on hardware</span></span><br><span class="line"><span class="comment"># NOTE: This will be overridden in product_config.mk if make</span></span><br><span class="line"><span class="comment"># was invoked with a PRODUCT-xxx-yyy goal.</span></span><br><span class="line">ifeq ($(TARGET_PRODUCT),)</span><br><span class="line">TARGET_PRODUCT := full</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line"><span class="comment"># the variant -- the set of files that are included for a build</span></span><br><span class="line">ifeq ($(strip $(TARGET_BUILD_VARIANT)),)</span><br><span class="line">TARGET_BUILD_VARIANT := eng</span><br><span class="line">endif</span><br><span class="line">...</span><br><span class="line"><span class="comment"># Read the product specs so we an get TARGET_DEVICE and other</span></span><br><span class="line"><span class="comment"># variables that we need in order to locate the output files.</span></span><br><span class="line">include $(BUILD_SYSTEM)/product_config.mk</span><br><span class="line">...</span><br><span class="line"><span class="comment"># 指定编译文件输出路径</span></span><br><span class="line">ifeq (,$(strip $(OUT_DIR)))</span><br><span class="line">ifeq (,$(strip $(OUT_DIR_COMMON_BASE)))</span><br><span class="line">OUT_DIR := $(TOPDIR)out</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">OUT_DIR := $(OUT_DIR_COMMON_BASE)/$(notdir $(PWD))</span><br><span class="line">endif</span><br><span class="line">endif</span><br><span class="line">DEBUG_OUT_DIR := $(OUT_DIR)/debug </span><br><span class="line">PRODUCT_OUT := $(TARGET_PRODUCT_OUT_ROOT)/$(TARGET_DEVICE)</span><br><span class="line">TARGET_OUT_JAVA_LIBRARIES:= $(TARGET_OUT)/framework</span><br><span class="line">TARGET_OUT_INTERMEDIATES := $(PRODUCT_OUT)/obj</span><br><span class="line">TARGET_OUT := $(PRODUCT_OUT)/$(TARGET_COPY_OUT_SYSTEM)</span><br><span class="line">TARGET_OUT_CACHE := $(PRODUCT_OUT)/cache</span><br><span class="line">```　</span><br><span class="line"><span class="comment">## build\core\ product_config.mk</span></span><br><span class="line">此文件主要根据lunch选择的编译项读取device目录或vendor目录下不同厂商自己定义的AndroidProducts.mk文件，内包含目标产品配置文件，如：msm8916_32.mk；</span><br><span class="line">```bash</span><br><span class="line"><span class="comment"># </span></span><br><span class="line">include $(BUILD_SYSTEM)/node_fns.mk</span><br><span class="line">include $(BUILD_SYSTEM)/product.mk</span><br><span class="line">include $(BUILD_SYSTEM)/device.mk </span><br><span class="line">...</span><br><span class="line"><span class="comment"># Import all product makefiles.</span></span><br><span class="line">$(call import-products, $(all_product_makefiles)) <span class="comment"># 找到并导入所有Makefile</span></span><br><span class="line"> <span class="comment"># Import all or just the current product makefile</span></span><br><span class="line">$(call import-products, $(current_product_makefile)) <span class="comment"># 找到并导入当前产品的Makefile</span></span><br><span class="line">$(check-all-products) <span class="comment"># 完整性检查</span></span><br><span class="line">...</span><br><span class="line"><span class="comment"># 调用resolve-short-product-name函数，返回TARGET_PRODUCT的配置文件目录</span></span><br><span class="line">INTERNAL_PRODUCT := $(call resolve-short-product-name, $(TARGET_PRODUCT))</span><br><span class="line">...</span><br><span class="line"><span class="comment"># Find the device that this product maps to.</span></span><br><span class="line">TARGET_DEVICE := $(PRODUCTS.$(INTERNAL_PRODUCT).PRODUCT_DEVICE) <span class="comment"># 获得目标设备名</span></span><br><span class="line"><span class="comment">#如：INTERNAL_PRODUCT = device\qcom\msm8916_32\msm8916_32.mk</span></span><br><span class="line">    TARGET_DEVICE  = msm8916_32</span><br></pre></td></tr></table></figure></p>
<h3 id="build\core\_product-mk">build\core\ product.mk</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 读取所有AndroidProducts.mk文件</span></span><br><span class="line">define _find-android-products-files</span><br><span class="line">$(shell <span class="built_in">test</span> <span class="operator">-d</span> device &amp;&amp; find device -maxdepth <span class="number">6</span> -name AndroidProducts.mk) \</span><br><span class="line">  $(shell <span class="built_in">test</span> <span class="operator">-d</span> vendor &amp;&amp; find vendor -maxdepth <span class="number">6</span> -name AndroidProducts.mk) \</span><br><span class="line">  $(SRC_TARGET_DIR)/product/AndroidProducts.mk</span><br><span class="line">endef</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取AndroidProducts.mk文件中设置的所有PRODUCT_MAKEFILES变量序列（其实为产品配置文件路径）</span></span><br><span class="line">define get-all-product-makefiles</span><br><span class="line">$(call get-product-makefiles,$(_find-android-products-files))</span><br><span class="line">endef</span><br></pre></td></tr></table></figure>
<h3 id="build\core\_device-mk">build\core\ device.mk</h3><p>这个文件没怎么看懂， 大致就是定义变量、根据device名字获得mk文件路径、检查device的必须变量是否被定义之类的，以后有闲功夫再研究。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">_device_var_list := \</span><br><span class="line">    DEVICE_NAME \</span><br><span class="line">    DEVICE_BOARD \</span><br><span class="line">    DEVICE_REGION</span><br><span class="line"></span><br><span class="line">define dump-device</span><br><span class="line">$(info ==== $(<span class="number">1</span>) ====)\</span><br><span class="line">$(foreach v,$(_device_var_list),\</span><br><span class="line">$(info DEVICES.$(<span class="number">1</span>).$(v) := $(DEVICES.$(<span class="number">1</span>).$(v))))\</span><br><span class="line">$(info --------)</span><br><span class="line"></span><br><span class="line">endefdefine import-devices</span><br><span class="line">$(call import-nodes,DEVICES,$(<span class="number">1</span>),$(_device_var_list))</span><br><span class="line"></span><br><span class="line">define _resolve-short-device-name</span><br></pre></td></tr></table></figure></p>
<h3 id="build\core\_node_fns-mk">build\core\ node_fns.mk</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">define clear-var-list $(foreach v,$(<span class="number">1</span>),$(<span class="built_in">eval</span> $(v):=)) <span class="comment"># 清除用“:=”的变量名</span></span><br><span class="line">define copy-var-list $(foreach v,$(<span class="number">2</span>),$(<span class="built_in">eval</span> $(strip $(<span class="number">1</span>)).$(v):=$($(v)))) <span class="comment"># 拷贝变量名</span></span><br><span class="line">define move-var-list </span><br><span class="line"></span><br><span class="line">define import-nodes  $(<span class="number">1</span>) $(<span class="number">2</span>) $(<span class="number">3</span>) <span class="comment"># 导入变量，此定义需要三个入口参数：</span></span><br><span class="line">$(<span class="number">1</span>)是一个字串，是输出变量的主干名。例如”PRODUCTS<span class="string">"和”DEVICES“</span><br><span class="line"><span class="variable">$(2)</span>是一个makefile文件列表，这些文件中应该含有对<span class="variable">$(3)</span>中变量的定义</span><br><span class="line"><span class="variable">$(3)</span>是一个变量列表</span><br><span class="line">  import-nodes会创建这样形式的变量，例如：<span class="variable">$(1)</span>="</span>PRODUCTS<span class="string">",<span class="variable">$(2)</span>中含有"</span>build/target/product/core.mk<span class="string">", <span class="variable">$(3)</span>中含有"</span>PRODUCT_NAME<span class="string">",而core.mk中定义了PRODUCT_NAME:=core，则变量为：PRODUCT.build/target/product/core.mk.PRODUCT_NAME:=core。</span><br><span class="line">  import-nodes中还考虑了inherit（即继承）的问题，如果某个PRODUCT.xxx.xxx变量的值中有‘@inherit:&lt;mk文件&gt;’标识，则会把那个mk文件中相应的变量的属性添加到PRODUCT.xxx.xxx中。'@inherit:&lt;mk文件&gt;'是通过inherit-product命令添加的。这个函数定义在product.mk里面。 </span><br><span class="line">... </span><br><span class="line"># 定义其他对变量等的处理，没去细看，也不一一列出了</span></span><br></pre></td></tr></table></figure>
<h3 id="device\qcom\msm8916_32\Android-mk">device\qcom\msm8916_32\Android.mk</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include $(CLEAR_VARS)</span></span><br><span class="line"><span class="comment">#LOCAL_MODULE       := wpa_supplicant.conf</span></span><br><span class="line"><span class="comment">#LOCAL_MODULE_TAGS  := optional # 默认在所有版本下都编译</span></span><br><span class="line"><span class="comment">#LOCAL_MODULE_CLASS := ETC</span></span><br><span class="line"><span class="comment">#LOCAL_SRC_FILES    := $(LOCAL_MODULE)</span></span><br><span class="line"><span class="comment">#LOCAL_MODULE_PATH  := $(TARGET_OUT_ETC)/wifi</span></span><br><span class="line"><span class="comment">#include $(BUILD_PREBUILT)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#include $(call all-makefiles-under,$(LOCAL_PATH)) # 导入所有mk文件</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>模块mk文件详见Android.mk解析：<a href="http://huaqianlee.me/2015/07/12/Android/About-ActivityNotFoundException-Unable-to-find-explicit-activity-class-Android-mk%E8%A7%A3%E6%9E%90/#more" target="_blank" rel="external">Android.mk解析</a></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>　　<a href="http://huaqianlee.me/2015/07/11/Android/Android%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3%E4%B9%8B%E4%B8%80/">Android编译过程详解之一</a><br>　　<a href="http://huaqianlee.me/2015/07/12/Android/Android%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3%E4%B9%8B%E4%BA%8C/">Android编译过程详解之二</a><br>　　<a href="http://huaqianlee.me/2015/07/12/Android/Android%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3%E4%B9%8B%E4%B8%89/">Android编译过程详解之三</a><br>　　<a href="http://huaqianlee.me/2015/07/12/Android/About-ActivityNotFoundException-Unable-to-find-explicit-activity-class-Android-mk%E8%A7%A3%E6%9E%90/">Android.mk解析</a><br>　<br>　　配置好环境变量后，接下来要做的就是build了。为了提高编译速度，我们自定义了一个go.sh的脚本文件，详细下面解释。另，编译的时候一般会在后面加一个-j8来实现多线程编译，如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　　　./go.sh -j8 or make -j8／--jobs</span><br></pre></td></tr></table></figure></p>
<p>参数“-j“ 和”—jobs ”指定了同时编译的线程数量，通常是编译主机 CPU 支持的并发线程总数的 1 倍或 2 倍（如：在一个 4 核，每个核支持两个线程的 CPU 上，可以使用 make -j8 或 make -j16）。在调用 make 命令时，如果没有指定任何目标，则将编译默认目标“droid”（下面详解），然后将会编译出完整的 Android 系统镜像。</p>
<h2 id="build系统分类">build系统分类</h2><p>　　整个build系统的Make文件可以分为三类：</p>
<ol>
<li>build系统核心文件：定义整个build系统的框架，其他所有make文件都是在这个框架的基础上写出来的。</li>
<li>产品的make文件：位于device目录，通常以公司名和产品名分为两级目录，如：\device\qcom\msm8916_32。</li>
<li>模块的make文件：每个模块专用的make文件，kernel中统一名字为Makefile，其他为Android.mk。　</li>
</ol>
<h2 id="build结果">build结果</h2><p>所有的编译产物都将位于 /out 目录下，该目录下主要有以下几个子目录：</p>
<ul>
<li>/out/host/：该目录下包含了针对主机的 Android 开发工具的产物。即 SDK 中的各种工具，例如：emulator，adb，aapt 等。</li>
<li>/out/target/common/：该目录下包含了针对设备的共通的编译产物，主要是 Java 应用代码和 Java 库。</li>
<li>/out/target/product/<product_name>/：包含了针对特定设备的编译结果以及平台相关的 C/C++ 库和二进制文件。其中，<product_name>是具体目标设备的名称。</li>
<li>/out/dist/：包含了为多种分发而准备的包，通过“make disttarget”将文件拷贝到该目录，默认的编译目标不会产生该目录。]]>
    
    </summary>
    
      <category term="Qualcomm" scheme="http://huaqianlee.me/tags/Qualcomm/"/>
    
      <category term="源码分析" scheme="http://huaqianlee.me/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="编译" scheme="http://huaqianlee.me/tags/%E7%BC%96%E8%AF%91/"/>
    
      <category term="Android" scheme="http://huaqianlee.me/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[About ActivityNotFoundException Unable to find explicit activity class && Android.mk解析]]></title>
    <link href="http://huaqianlee.me/2015/07/12/Android/About-ActivityNotFoundException-Unable-to-find-explicit-activity-class-Android-mk%E8%A7%A3%E6%9E%90/"/>
    <id>http://huaqianlee.me/2015/07/12/Android/About-ActivityNotFoundException-Unable-to-find-explicit-activity-class-Android-mk解析/</id>
    <published>2015-07-12T06:06:35.000Z</published>
    <updated>2015-10-27T06:40:06.272Z</updated>
    <content type="html"><![CDATA[<p>　　<a href="http://huaqianlee.me/2015/07/11/Android/Android%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3%E4%B9%8B%E4%B8%80/" target="_blank" rel="external">Android编译过程详解之一</a><br>　　<a href="http://huaqianlee.me/2015/07/12/Android/Android%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3%E4%B9%8B%E4%BA%8C/" target="_blank" rel="external">Android编译过程详解之二</a><br>　　<a href="http://huaqianlee.me/2015/07/12/Android/Android%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3%E4%B9%8B%E4%B8%89/" target="_blank" rel="external">Android编译过程详解之三</a><br>　　<a href="http://huaqianlee.me/2015/07/12/Android/About-ActivityNotFoundException-Unable-to-find-explicit-activity-class-Android-mk%E8%A7%A3%E6%9E%90/" target="_blank" rel="external">Android.mk解析</a></p>
<h2 id="ActivityNotFoundException">ActivityNotFoundException 　</h2><p>　　最近将Android从4.4移植到5.1时，添加一个从拨号界面输入*#360*#进入battery info查看界面的功能时（如感兴趣，详情见<a href="http://huaqianlee.me/2015/06/06/Android/Android%E7%94%B5%E6%B1%A0%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F-BMS-%E4%B9%8B%E7%94%B5%E6%B1%A0%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/" target="_blank" rel="external">Android电池监控系统(bms)之一电池系统架构</a>），activity跳转部分代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">else</span> <span class="title">if</span><span class="params">(input.equals(BATTERY_INFO)</span>)</span><br><span class="line"></span>&#123;<span class="comment">//added by lihuaqian</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ComponentName Component = <span class="keyword">new</span> ComponentName(<span class="string">"com.android.settings"</span>,<span class="string">"com.android.settings.BatteryOemInfo"</span>); </span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">        intent.setComponent(Component);</span><br><span class="line">        intent.setAction(Intent.ACTION_VIEW);   </span><br><span class="line">        context.startActivity(intent);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ActivityNotFoundException e) &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"no activity to battery cmd."</span>); </span><br><span class="line">        <span class="comment">//e.printStackTrace();   </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>　　遇到如下问题：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　　ActivityNotFoundException : Unable to find explicit activity class; have you declared this activity <span class="keyword">in</span> your AndroidManifest.xml?</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>　　我将流程检查了一遍又一遍，都完全没有问题，Google了很久也无结果。后灵光一现：是否Setting这个apk根本就没有安装成功，所以才导致找不到Activity。<br>　<br><strong>于是，我首先通过命令 adb install -r Setting.apk 手动安装，但总是提示安装失败，这时已有些小小兴奋，因为感觉自己快找到原因了。</strong><br>　<br><strong>然后，我将apk push进手机相应文件系统路径，重启，通过logcat打印log，后发现关键信息，如下：</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Failed to parse /system/priv-app/Settings: Signature mismatch <span class="keyword">for</span> shared user : SharedUserSetting&#123;<span class="number">2</span>a5b4702 android.uid.system/<span class="number">1000</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过此log信息可知：系统没有能成功安装此apk，原因是app签名不匹配。 这样就找到了问题的根源。 向应用软件部同事了解情况后得知，是因为此项目客户指定Signature。<br>　<br><strong>所以，接下来我就有两种选择：</strong></p>
<ul>
<li>自己整编整个系统，然后刷机，但是整编时间太长，所以放弃。</li>
<li>将修改代码给出软件同事，让其帮忙编一apk。（我选择了此方式，然后测试OK了）　</li>
</ul>
<p><strong>当然，这种问题主要是做系统级APP，需要用到root权限或运行于系统进程时时才会遇到，其他一般都是如下几个情况：</strong></p>
<ol>
<li>如log中提示，没有在AndroidManifest.xml中定义此Activity。</li>
<li>包名或者类名书写错误，不统一。</li>
<li>自己定义的包名或者类名与系统自带类重复。</li>
</ol>
<h2 id="Android-mk解析">Android.mk解析</h2><p>　　因为上面问题时由签名引起的，所以就深入看了一下什么地方指定签名，后发现在APP目录中的Android.mk中制定。Android.mk将source打包为如下几种modules：<br>　　　1. APK程序<br>  　　　　一般的Android程序，编译打包生成apk文件<br>　　　2. JAVA库<br>  　　　　java类库，编译打包生成jar文件<br>　　　3. C\C++应用程序<br> 　　　　可执行的C\C++应用程序<br>　　　4. C\C++静态库<br>　　　　编译生成C\C++静态库，并打包成.a文件，静态库则可被链接到动态库。<br>　　　5. C\C++动态库　　<br>　　　　编译生成共享库（动态链接库），并打包成.so文， 只有动态库才能被install or copy到apk。<br>　<br>　　在 Android Build 系统中，编译以模块（而不是文件）作为单位，每个模块都有一个唯一的名称，一个模块的依赖对象只能是另外一个模块，而不能是其他类型的对象。对于已经编译好的二进制库，如果要用来被当作是依赖对象，那么应当将这些已经编译好的库作为单独的模块。对于这些已经编译好的库使用 BUILD_PREBUILT 或 BUILD_MULTI_PREBUILT。例如：当编译某个 Java 库需要依赖一些 Jar 包时，并不能直接指定 Jar 包的路径作为依赖，而必须首先将这些 Jar 包定义为一个模块，然后在编译 Java 库的时候通过模块的名称来依赖这些 Jar 包。</p>
<p> 下面为Qualcomm Settings中的Android.mk （带“Lee:”为我自己加入以详解Android.mk）:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">//通常以如下两行开头</span><br><span class="line">LOCAL_PATH:= $(call my-dir)   // 用于定位源码路径，my-dir即当前路径</span><br><span class="line"> /*CLEAR_VARS-清理除LOCAL_PATH外的很多LOCAL_XX变量,因变量皆为全局变量，清理后避免相互影响。*/</span><br><span class="line">include $(CLEAR_VARS)</span><br><span class="line"></span><br><span class="line">/*链接外部JAVA包*/</span><br><span class="line">LOCAL_JAVA_LIBRARIES := bouncycastle conscrypt telephony-common ims-common // 当前模块依赖的 Java 共享库</span><br><span class="line">LOCAL_STATIC_JAVA_LIBRARIES := android-support-v4 android-support-v13 jsr305 // 当前模块依赖的 Java 静态库</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">  *user:       该模块只在user版本下才编译</span><br><span class="line">  *eng:        该模块只在eng版本下才编译</span><br><span class="line">  *debug:    该模块只在debug版本下才编译</span><br><span class="line">  *optional:  该模块在所有版本下都编译,默认标签</span><br><span class="line">  * development:  该模块在development版本下编译</span><br><span class="line"> **/</span><br><span class="line">LOCAL_MODULE_TAGS := optional //定义该模块什么情况被编译</span><br><span class="line"></span><br><span class="line">Lee: LOCAL_MODULE    :=    //名字唯一不含空格，编译的目标对象，即名字</span><br><span class="line">Lee: LOCAL_C_INCLUDES         //包含c/c++需要的头文件路径</span><br><span class="line">Lee: LOCAL_SRC_FILES：当前模块包含的所有源代码文件。</span><br><span class="line">Lee: LOCAL_STATIC_LIBRARIES：当前模块在静态链接时需要的库的名称。</span><br><span class="line">Lee: LOCAL_SHARED_LIBRARIES：当前模块在运行时依赖的动态库的名称。</span><br><span class="line">Lee: LOCAL_CFLAGS：提供给 C/C++ 编译器的额外编译参数。</span><br><span class="line">Lee: LOCAL_PACKAGE_NAME：当前 APK 应用的名称。</span><br><span class="line">Lee: LOCAL_CERTIFICATE：签署当前应用的证书名称。</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">  *编译模块的源码</span><br><span class="line"> **/</span><br><span class="line">LOCAL_SRC_FILES := \</span><br><span class="line">        $(call all-java-files-under, src) \</span><br><span class="line">        src/com/android/settings/EventLogTags.logtags \</span><br><span class="line">        src/com/android/cabl/ICABLService.aidl</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">  *编译模块的资源路径</span><br><span class="line"> **/</span><br><span class="line">LOCAL_RESOURCE_DIR := $(LOCAL_PATH)/res</span><br><span class="line"></span><br><span class="line">LOCAL_SRC_FILES += \</span><br><span class="line">        src/com/android/location/XT/IXTSrv.aidl \</span><br><span class="line">        src/com/android/location/XT/IXTSrvCb.aidl \</span><br><span class="line">        src/com/android/display/IPPService.aidl</span><br><span class="line">LOCAL_PACKAGE_NAME := Settings //apk名</span><br><span class="line">LOCAL_CERTIFICATE := platform  // 此处定义签名</span><br><span class="line">LOCAL_PRIVILEGED_MODULE := <span class="literal">true</span>//声明apk放到system/priv-app</span><br><span class="line"></span><br><span class="line">Lee:LOCAL_CFLAGS +=$(OEM_CFLAGS)  // 声明customer（客户文件）中定义的相关宏，以便c/c++中<span class="comment">#if defined </span></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">  * external/proguard - 抑制apk反编译的，对class混淆处理的代码路径</span><br><span class="line">  * proguard.flags 指定不需要混淆处理的native方法和变量</span><br><span class="line"> **/</span><br><span class="line">LOCAL_PROGUARD_FLAG_FILES := proguard.flags//加载当前路径proguard.flags文件</span><br><span class="line"></span><br><span class="line">include frameworks/opt/setupwizard/navigationbar/common.mk //包含指定</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">  *BUILD_STATIC_LIBRARY:  编译为静态库</span><br><span class="line">  *BUILD_SHARED_LIBRARY : 编译为动态库 </span><br><span class="line">  *BUILD_EXECUTABLE:    编译为Native C可执行程序</span><br><span class="line">  * BUILD_PACKAGE:  编译为apk</span><br><span class="line"> **/</span><br><span class="line">include $(BUILD_PACKAGE) //编译为apk</span><br><span class="line"></span><br><span class="line"><span class="comment"># Use the following include to make our test apk.</span></span><br><span class="line">ifeq (,$(ONE_SHOT_MAKEFILE))</span><br><span class="line">include $(call all-makefiles-under,$(LOCAL_PATH)) <span class="comment">#表示需要编译该目录下文件，系统在当前路径查找Android.mk来编译</span></span><br><span class="line">endif</span><br><span class="line">Lee:还有很多其他定义和语法，这里就不一一分析，不过从变量名就能窥知一二</span><br></pre></td></tr></table></figure>
<h3 id="编译类型的说明">编译类型的说明</h3><h4 id="eng">eng</h4><ul>
<li>默认类型，该编译类型适用于开发阶段。</li>
<li>安装包含 eng, debug, user，development 标签的模块</li>
<li>安装所有没有标签的非APK模块</li>
<li>安装所有产品定义文件中指定的APK模块</li>
</ul>
<h4 id="user">user</h4><ul>
<li>该编译类型适合用于最终发布阶段。</li>
<li>安装所有带有 user 标签的模块</li>
<li>安装所有没有标签的非 APK 模块</li>
<li>安装所有产品定义文件中指定的 APK 模块，APK 模块的标签将被忽略</li>
</ul>
<h4 id="userdebug">userdebug</h4><p>该编译类型适合用于debug阶段。该类型和user一样，另：</p>
<ul>
<li>会安装包含debug标签的模块</li>
<li>编译出的系统具有root访问权限</li>
</ul>
<p>　　build/core/config.mk中已经定义好了各种类型模块的编译方式。所以要执行编译，只需通过常量的方式引入对应的 Make 文件即可。详见<a href="http://huaqianlee.me/2015/07/12/Android/Android%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3%E4%B9%8B%E4%BA%8C/" target="_blank" rel="external">Android编译过程详解之二</a>，例如，要编译一个 APK 文件，只需要在 Android.mk 文件中，加入“include $(BUILD_PACKAGE)。<br>　<br>　　除此以外，Build 系统中还定义了一些便捷的函数以便在 Android.mk 中使用，如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$(call my-dir)：获取当前文件夹路径。</span><br><span class="line">$(call all-java-files-under, &lt;src&gt;)：获取指定目录下的所有 Java 文件。</span><br><span class="line">$(call all-c-files-under, &lt;src&gt;)：获取指定目录下的所有 C 语言文件。</span><br><span class="line">$(call all-Iaidl-files-under, &lt;src&gt;) ：获取指定目录下的所有 AIDL 文件。</span><br><span class="line">$(call all-makefiles-under, &lt;folder&gt;)：获取指定目录下的所有 Make 文件。</span><br><span class="line">$(call intermediates-dir-for, &lt;class&gt;, &lt;app_name&gt;, &lt;host or target&gt;, &lt;common?&gt; )：获取 Build 输出的目标文件夹路径。</span><br></pre></td></tr></table></figure></p>
<h3 id="LOCAL_CERTIFICATE">LOCAL_CERTIFICATE</h3><p>　　分析了Android.mk,再来详细说说我之前问题相关的一个属性：LOCAL_CERTIFICATE ，用于指定签名是使用的key，如不指定默认testkey。<br>　<br>分析这个属性就先得谈谈此apkAndroidManifest.xm了中的sharedUserId属性说起，如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;manifest xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">        package=<span class="string">"com.android.settings"</span></span><br><span class="line">        coreApp=<span class="string">"true"</span></span><br><span class="line">        android:sharedUserId=<span class="string">"android.uid.system"</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>　　通过将sharedUserId配置为”android.uid.system”，即让程序运行在系统进程，而运行在系统进程则需要目标系统的platform key，Android.mk中的 LOCAL_CERTIFICATE := platform  即是声明相应签名key文件。key文件的源码路径在 build\target\product\security。通过这样处理的apk则只能在自己编译的系统里面才能使用，如若装到其他Android系统会提示：”Package … has no signatures that match those in shared user android.uid.system”。<br>　<br>　　另，android:sharedUserId属性不仅仅可以把apk放到系统进程中，也可以配置多个APK运行在一个进程中，这样可以共享数据，就会很有用处。就像我上面的Settings.apk。</p>
<p>在Android.mk中,LOCAL_CERTIFICATE可设置的值如下：</p>
<ul>
<li>LOCAL_CERTIFICATE := platform</li>
<li>LOCAL_CERTIFICATE := shared</li>
<li>LOCAL_CERTIFICATE := media　<br>然后，需要在APK源码的AndroidManifest.xml文件中的manifest节点添加如下内容：</li>
<li>android:sharedUserId=”android.uid.system”</li>
<li>android:sharedUserId=”android.uid.shared”</li>
<li>android:sharedUserId=”android.media”　<br>在Android源码的build/target/product/security/目录下有如下的4对KEY：<ol>
<li>media.pk8与media.x509.pem；</li>
<li>platform.pk8与platform.x509.pem；</li>
<li>shared.pk8与shared.x509.pem；</li>
<li>testkey.pk8与testkey.x509.pem；　</li>
</ol>
</li>
</ul>
<p>其中，”<em>.pk8”文件为私钥，”</em>.x509.pem”文件为公钥，这需要了解非对称加密方式。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>　　<a href="http://huaqianlee.me/2015/07/11/Android/Android%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3%E4%B9%8B%E4%B8%80/">Android编译过程详解之一</a><br>　　<a href="http://huaqianlee.me/2015/07/12/Android/Android%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3%E4%B9%8B%E4%BA%8C/">Android编译过程详解之二</a><br>　　<a href="http://huaqianlee.me/2015/07/12/Android/Android%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3%E4%B9%8B%E4%B8%89/">Android编译过程详解之三</a><br>　　<a href="http://huaqianlee.me/2015/07/12/Android/About-ActivityNotFoundException-Unable-to-find-explicit-activity-class-Android-mk%E8%A7%A3%E6%9E%90/">Android.mk解析</a></p>
<h2 id="ActivityNotFoundException">ActivityNotFoundException 　</h2><p>　　最近将Android从4.4移植到5.1时，添加一个从拨号界面输入*#360*#进入battery info查看界面的功能时（如感兴趣，详情见<a href="http://huaqianlee.me/2015/06/06/Android/Android%E7%94%B5%E6%B1%A0%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F-BMS-%E4%B9%8B%E7%94%B5%E6%B1%A0%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/">Android电池监控系统(bms)之一电池系统架构</a>），activity跳转部分代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">else</span> <span class="title">if</span><span class="params">(input.equals(BATTERY_INFO)</span>)</span><br><span class="line"></span>&#123;<span class="comment">//added by lihuaqian</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ComponentName Component = <span class="keyword">new</span> ComponentName(<span class="string">"com.android.settings"</span>,<span class="string">"com.android.settings.BatteryOemInfo"</span>); </span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">        intent.setComponent(Component);</span><br><span class="line">        intent.setAction(Intent.ACTION_VIEW);   </span><br><span class="line">        context.startActivity(intent);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ActivityNotFoundException e) &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"no activity to battery cmd."</span>); </span><br><span class="line">        <span class="comment">//e.printStackTrace();   </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>　　遇到如下问题：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　　ActivityNotFoundException : Unable to find explicit activity class; have you declared this activity <span class="keyword">in</span> your AndroidManifest.xml?</span><br></pre></td></tr></table></figure></p>]]>
    
    </summary>
    
      <category term="Bug" scheme="http://huaqianlee.me/tags/Bug/"/>
    
      <category term="编译" scheme="http://huaqianlee.me/tags/%E7%BC%96%E8%AF%91/"/>
    
      <category term="Android" scheme="http://huaqianlee.me/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android编译过程详解之一]]></title>
    <link href="http://huaqianlee.me/2015/07/11/Android/Android%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3%E4%B9%8B%E4%B8%80/"/>
    <id>http://huaqianlee.me/2015/07/11/Android/Android编译过程详解之一/</id>
    <published>2015-07-11T11:43:04.000Z</published>
    <updated>2015-10-27T06:39:58.481Z</updated>
    <content type="html"><![CDATA[<p><strong>　　Platform Information :<br>　　　System:    Ａndroid4.4.4<br>　　　Platform:  Qualcomm msm8916<br>　　　Author:     Andy Lee<br>　　　Email:        huaqianlee@gmail.com</strong></p>
<p><strong>欢迎指出错误，共同学习，共同进步</strong></p>
<p>　　<a href="http://huaqianlee.me/2015/07/11/Android/Android%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3%E4%B9%8B%E4%B8%80/" target="_blank" rel="external">Android编译过程详解之一</a><br>　　<a href="http://huaqianlee.me/2015/07/12/Android/Android%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3%E4%B9%8B%E4%BA%8C/" target="_blank" rel="external">Android编译过程详解之二</a><br>　　<a href="http://huaqianlee.me/2015/07/12/Android/Android%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3%E4%B9%8B%E4%B8%89/" target="_blank" rel="external">Android编译过程详解之三</a><br>　　<a href="http://huaqianlee.me/2015/07/12/Android/About-ActivityNotFoundException-Unable-to-find-explicit-activity-class-Android-mk%E8%A7%A3%E6%9E%90/" target="_blank" rel="external">Android.mk解析</a><br>　<br>　　Google给出的编译环境和构建方法见：<a href="http://source.android.com/source/initializing.html" target="_blank" rel="external">http://source.android.com/source/initializing.html</a>，过程见：<a href="http://source.android.com/source/building.html" target="_blank" rel="external">http://source.android.com/source/building.html</a>，不过这是解释怎么编译一个通用的系统，没有详细描述细节，而且需要翻墙。接下来我就准备跟着高通平台的编译过程来详细了解一下。</p>
<p>我平时的编译步骤如下：<br>　1. source setup.sh project-name debug/release　加载命令配置环境　<br>　2. ./go.sh  [target] or make  [target]　编译<br><a id="more"></a>　<br>接下来就按照步骤来详细分析一下流程：</p>
<h2 id="source_setup-sh_project-name_debug">source setup.sh project-name debug</h2><p>　　setup.sh是自定义的一个脚本文件，用来配置环境变量，其主要内容如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/*配置用到的jdk、jre*/</span><br><span class="line"><span class="built_in">export</span> JAVA_HOME=/workspace/bin/jdk1.<span class="number">6.0</span>_37</span><br><span class="line"><span class="built_in">export</span> JRE_HOME=<span class="variable">$&#123;JAVA_HOME&#125;</span>/jre </span><br><span class="line"><span class="built_in">export</span> CLASSPATH=.:<span class="variable">$&#123;JAVA_HOME&#125;</span>/lib:<span class="variable">$&#123;JRE_HOME&#125;</span>/lib </span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$&#123;JAVA_HOME&#125;</span>/bin:<span class="variable">$&#123;JRE_HOME&#125;</span>/bin:<span class="variable">$PATH</span> </span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> build/envsetup.sh // 官网的第一步，加载命令，待会儿再详细解释</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="operator">-d</span> /workspace/bin/eric-PAY4/links-<span class="number">8916</span> ];<span class="keyword">then</span></span><br><span class="line">    cp <span class="operator">-a</span> /workspace/bin/eric-PAY4/links-<span class="number">8916</span> links</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$#</span> <span class="operator">-lt</span> <span class="number">2</span> ];<span class="keyword">then</span> <span class="comment"># 如命令行参数输入错误，打印提示信息</span></span><br><span class="line">    <span class="built_in">echo</span> You can input like <span class="string">"source setup.sh s5_common [debug|release]"</span></span><br><span class="line">    <span class="built_in">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> product=<span class="variable">$1</span> var=<span class="variable">$2</span> //打印输入选择 project-name  debug/release</span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$2</span> = <span class="string">"debug"</span> ];<span class="keyword">then</span>　// 根据参数选择编译项</span><br><span class="line">    choosecombo <span class="number">2</span> msm8916_32 <span class="number">3</span> <span class="variable">$1</span> </span><br><span class="line">    <span class="built_in">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$2</span> = <span class="string">"release"</span> ];<span class="keyword">then</span></span><br><span class="line">    choosecombo <span class="number">1</span> msm8916_32 <span class="number">1</span> <span class="variable">$1</span></span><br><span class="line">    <span class="built_in">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Your input is wrong please check again"</span></span><br></pre></td></tr></table></figure></p>
<h3 id="source_build/envsetup-sh">source build/envsetup.sh</h3><p>　　此命令是将envsetup.sh中的命令加载到环境变量，build位于Android源码路径根目录（本文提到所有路径都是以 Android 源码树作为背景的，“/”或顶层路径指的是源码树的根目录，与文件系统无关），主要命令如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- lunch:   指定编译项，即编译目标和编译类型（lunch &lt;product_name&gt;-&lt;build_variant&gt;）</span><br><span class="line">- tapas:   同choosecombo，设置编译参数（tapas [&lt;App1&gt; &lt;App2&gt; ...] [arm|x86|mips|armv5] [eng|userdebug|user]）</span><br><span class="line">- croot:   切换到根目录（Changes directory to the top of the tree.）</span><br><span class="line">- m:       从源码树根目录开始make（Makes from the top of the tree.）</span><br><span class="line">- mm:      编译当前目录下所有模块，但不包括依赖文件（Builds all of the modules <span class="keyword">in</span> the current directory, but not their dependencies.）</span><br><span class="line">- mmm:    编译指定目录下的所有模块，但不包括依赖文件（Builds all of the modules <span class="keyword">in</span> the supplied directories, but not their dependencies.）</span><br><span class="line">- mma:     编译当前目录下所有模块，包括依赖文件（Builds all of the modules <span class="keyword">in</span> the current directory, and their dependencies.）</span><br><span class="line">- mmma:    编译指定目录下的所有模块，包括依赖文件（Builds all of the modules <span class="keyword">in</span> the supplied directories, and their dependencies.）</span><br><span class="line">- cgrep:   在所有c/c++文件中查找（Greps on all <span class="built_in">local</span> C/C++ files.）</span><br><span class="line">- jgrep:   在所有java文件中查找（Greps on all <span class="built_in">local</span> Java files.）</span><br><span class="line">- resgrep: 在所有res/*.xml中查找（Greps on all <span class="built_in">local</span> res/*.xml files.）</span><br><span class="line">- godir:   跳转到包含某个文件的路径（Go to the directory containing a file.）</span><br><span class="line">- printconfig：显示当前Build的配置信息</span><br></pre></td></tr></table></figure></p>
<p>　　完整命令和关键源码如下：(英文为源码注释，中文部分是原本没有，自己根据理解添加的注释)<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> get_abs_build_var()   <span class="comment"># Get the value of a build variable as an absolute path.</span></span><br><span class="line"><span class="keyword">function</span> get_build_var()   <span class="comment"># Get the exact value of a build variable.</span></span><br><span class="line"><span class="keyword">function</span> check_product()  <span class="comment"># check to see if the supplied product is one we can build</span></span><br><span class="line"><span class="keyword">function</span> check_variant()  <span class="comment"># check to see if the supplied variant is valid (variant：user userdebug eng)</span></span><br><span class="line"><span class="keyword">function</span> setpaths()   <span class="comment"># sets ANDROID_BUILD_PATHS</span></span><br><span class="line"><span class="keyword">function</span> printconfig()   <span class="comment"># 打印配置</span></span><br><span class="line"><span class="keyword">function</span> <span class="built_in">set</span>_stuff_<span class="keyword">for</span>_environment()   <span class="comment"># 设置环境变量</span></span><br><span class="line"><span class="keyword">function</span> <span class="built_in">set</span>_sequence_number()     <span class="comment"># 设置序列号</span></span><br><span class="line"><span class="keyword">function</span> settitle()   <span class="comment"># 设置标题</span></span><br><span class="line"><span class="keyword">function</span> addcompletions()    <span class="comment"># 添加sdk/bash_completion中bash</span></span><br><span class="line"><span class="keyword">function</span> choosetype()    <span class="comment"># 选择type （debug/release）</span></span><br><span class="line"><span class="keyword">function</span> chooseoemprj()    <span class="comment"># 自定义，设置TARGET_PRODUCT，即project-name</span></span><br><span class="line"><span class="keyword">function</span> chooseproduct()    <span class="comment">#  官方自带的设置TARGET_PRODUCT</span></span><br><span class="line"><span class="keyword">function</span> choosevariant()    <span class="comment"># 设置variant (user userdebug eng)</span></span><br><span class="line"><span class="keyword">function</span> choosecombo()    <span class="comment"># 设置并打印编译参数（choosetype、chooseproduct、choosevariant、chooseoemprj、set_stuff_for_environment）</span></span><br><span class="line"><span class="keyword">function</span> add_lunch_combo()    <span class="comment"># 添加lunch项，多次调用，用来添加Android编译选项</span></span><br><span class="line"><span class="keyword">function</span> <span class="built_in">print</span>_lunch_menu()    <span class="comment"># 打印lunch列表</span></span><br><span class="line"><span class="keyword">function</span> lunch()    <span class="comment"># 配置lunch</span></span><br><span class="line"><span class="keyword">function</span> _lunch()      <span class="comment"># Tab completion for lunch.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Configures the build to build unbundled apps.</span></span><br><span class="line"><span class="comment"># Run tapas with one ore more app names (from LOCAL_PACKAGE_NAME)</span></span><br><span class="line"><span class="keyword">function</span> tapas()     <span class="comment"># 同choosecombo</span></span><br><span class="line"><span class="keyword">function</span> gettop    <span class="comment"># 获取顶层路径</span></span><br><span class="line"><span class="keyword">function</span> m()    <span class="comment"># 从顶层树开始编译</span></span><br><span class="line"><span class="keyword">function</span> findmakefile()    <span class="comment"># 找到Makefile （Android.mk）</span></span><br><span class="line"><span class="keyword">function</span> mm()    <span class="comment"># 从当前路径开始编译，不加依赖</span></span><br><span class="line"><span class="keyword">function</span> mmm()     <span class="comment"># 从指定路径开始编译，不加依赖</span></span><br><span class="line"><span class="keyword">function</span> mma()    <span class="comment"># 从当前路径看是编译，包括依赖</span></span><br><span class="line"><span class="keyword">function</span> mmma()     <span class="comment"># 从指定路径开始编译，包括依赖</span></span><br><span class="line"><span class="keyword">function</span> croot()      <span class="comment"># 切换到顶层路径</span></span><br><span class="line"><span class="keyword">function</span> cproj()     <span class="comment"># 没看懂，切换到某一路径</span></span><br><span class="line"><span class="keyword">function</span> qpid()    <span class="comment"># 输出进程号和名字 （simplified version of ps; output in the form &lt;pid&gt; &lt;procname&gt;）</span></span><br><span class="line"><span class="keyword">function</span> pid()     <span class="comment"># 输出进程号和名字 </span></span><br><span class="line"><span class="keyword">function</span> systemstack()    <span class="comment"># systemstack - dump the current stack trace of all threads in the system process to the usual ANR traces file</span></span><br><span class="line"><span class="keyword">function</span> stacks()</span><br><span class="line"><span class="keyword">function</span> gdbwrapper()</span><br><span class="line"><span class="keyword">function</span> gdbclient()</span><br><span class="line"><span class="keyword">function</span> sgrep()     <span class="comment"># 查找c/h/cpp/S/java/xml/sh/mk文件</span></span><br><span class="line"><span class="keyword">function</span> gettargetarch    <span class="comment"># 获取TARGET_ARCH</span></span><br><span class="line"><span class="keyword">function</span> jgrep()    <span class="comment"># 查找java文件</span></span><br><span class="line"><span class="keyword">function</span> cgrep()    <span class="comment"># 查找c/c++文件</span></span><br><span class="line"><span class="keyword">function</span> resgrep()    <span class="comment"># 查找xml文件</span></span><br><span class="line"><span class="keyword">function</span> mangrep()     <span class="comment"># 查找out目录中AndroidManifest.xml文件</span></span><br><span class="line"><span class="keyword">function</span> sepgrep()    <span class="comment"># 查找out目录中sepolicy</span></span><br><span class="line"><span class="keyword">function</span> treegrep()                                </span><br><span class="line"><span class="keyword">function</span> mgrep()</span><br><span class="line"><span class="keyword">function</span> getprebuilt    <span class="comment"># 获取ANDROID_PREBUILTS（编译工具）</span></span><br><span class="line"><span class="keyword">function</span> tracedmdump()</span><br><span class="line"><span class="keyword">function</span> runhat()     <span class="comment"># communicate with a running device or emulator, set up necessary state, and run the hat command.</span></span><br><span class="line"><span class="keyword">function</span> getbugreports()</span><br><span class="line"><span class="keyword">function</span> getsdcardpath()</span><br><span class="line"><span class="keyword">function</span> getscreenshotpath()</span><br><span class="line"><span class="keyword">function</span> getlastscreenshot()</span><br><span class="line"><span class="keyword">function</span> startviewserver()</span><br><span class="line"><span class="keyword">function</span> stopviewserver()</span><br><span class="line"><span class="keyword">function</span> isviewserverstarted()</span><br><span class="line"><span class="keyword">function</span> key_home()</span><br><span class="line"><span class="keyword">function</span> key_back()</span><br><span class="line"><span class="keyword">function</span> key_menu()</span><br><span class="line"><span class="keyword">function</span> smoketest()</span><br><span class="line"><span class="keyword">function</span> runtest()    <span class="comment"># simple shortcut to the runtest command</span></span><br><span class="line"><span class="keyword">function</span> godir ()    <span class="comment"># 跳到指定目录</span></span><br><span class="line"><span class="keyword">function</span> <span class="built_in">set</span>_java_home()    <span class="comment"># Force JAVA_HOME to point to java 1.6 if it isn't already set</span></span><br><span class="line"><span class="keyword">function</span> pez     <span class="comment"># Print colored exit condition</span></span><br><span class="line"></span><br><span class="line">关键源码：</span><br><span class="line"><span class="comment"># Clear this variable.  It will be built up again when the vendorsetup.sh files are included at the end of this file.</span></span><br><span class="line"><span class="built_in">unset</span> LUNCH_MENU_CHOICES</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">add_lunch_combo</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">local</span> new_combo=<span class="variable">$1</span>   <span class="comment"># 获取add_lunch_combo被调用时的参数</span></span><br><span class="line">    <span class="built_in">local</span> c</span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> <span class="variable">$&#123;LUNCH_MENU_CHOICES[@]&#125;</span> ; <span class="keyword">do</span>   <span class="comment">#遍历LUNCH_MENU_CHOICES，第一次调用时为空</span></span><br><span class="line">        <span class="keyword">if</span> [ <span class="string">"<span class="variable">$new_combo</span>"</span> = <span class="string">"<span class="variable">$c</span>"</span> ] ; <span class="keyword">then</span>    <span class="comment"># 如果参数存在，则返回</span></span><br><span class="line">            <span class="built_in">return</span></span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">done</span> <span class="comment"># 如果参数不存在，则添加</span></span><br><span class="line">    LUNCH_MENU_CHOICES=(<span class="variable">$&#123;LUNCH_MENU_CHOICES[@]&#125;</span> <span class="variable">$new_combo</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># add the default one here  # 系统自动添加的默认编译项</span></span><br><span class="line">add_lunch_combo aosp_arm-eng  <span class="comment"># 调用add_lunch_combo()，传入参数</span></span><br><span class="line">add_lunch_combo aosp_x86-eng</span><br><span class="line">add_lunch_combo aosp_mips-eng</span><br><span class="line">add_lunch_combo vbox_x86-eng</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这段代码十分重要，主要在device目录查找vendorsetup.sh并加载，此文件主要添加自定义编译项，如：add_lunch_combo msm8916_32-userdebug </span></span><br><span class="line"><span class="comment"># Execute the contents of any vendorsetup.sh files we can find.</span></span><br><span class="line"><span class="keyword">for</span> f <span class="keyword">in</span> `<span class="built_in">test</span> <span class="operator">-d</span> device &amp;&amp; find device -maxdepth <span class="number">4</span> -name <span class="string">'vendorsetup.sh'</span> <span class="number">2</span>&gt; /dev/null` \</span><br><span class="line">         `<span class="built_in">test</span> <span class="operator">-d</span> vendor &amp;&amp; find vendor -maxdepth <span class="number">4</span> -name <span class="string">'vendorsetup.sh'</span> <span class="number">2</span>&gt; /dev/null`</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"including <span class="variable">$f</span>"</span></span><br><span class="line">    . <span class="variable">$f</span>  <span class="comment"># 执行找到的脚本</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">unset</span> f</span><br><span class="line"></span><br><span class="line">addcompletions  调用 addcompletions()</span><br></pre></td></tr></table></figure></p>
<p>因此可知，envsetup.sh主要有如下作用：<br>　1. 加载编译时需要的相应命令，如：help，lunch ，m，mm等。<br>　2. 添加系统默认编译项。<br>　3. 查找vendorsetup.sh文件，加载自定义编译项。</p>
<blockquote>
<p>注：有些Android版本中vendorsetup.sh文件在vendor目录　</p>
</blockquote>
<p>　　如要添加自己的产品，需要在device目录下新建一个自己公司名，新建一个vendorsetup.sh，加入自己的编译项。了解了这一条指令，再来看一下执行结果，将会更有体会，因为我所有命令都写到开始的setup.sh文件中了，所以不用想官方那样多步配置编译，如下：<br>　　<img src="http://7xjdax.com1.z0.glb.clouddn.com/20150711MakeAndroid.png" alt="Make"></p>
<h2 id="lunch">lunch</h2><p>　　lunch是在envsetup.sh中定义的一个命令，让用户选择编译项，用来定义product和编译过程中用到的全局变量。关于编译项，前面只是列出，并未详解，如msm8916_32-userdebug，msm8916_32为产品名，userdebug为编译类型，详细如下：</p>
<ul>
<li><p>eng: 工程机，</p>
</li>
<li><p>user:最终用户机</p>
</li>
<li><p>userdebug:调试测试机</p>
</li>
<li><p>tests:测试机 。</p>
</li>
</ul>
<p>　　在build\core\main.mk中有说明，Android源码中，每一个目标目录都有一个Android.mk，此文件中LOCAL_MODULE_TAGS就是来指定当前目标编译到哪个分类或者要不要编译。配置好后，可以通过lunch xxx 重选编译项，如：lunch msm8916_32-userdebug。</p>
<p>ok，接下来分析一下lunch function：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">lunch</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">local</span> answer</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> [ <span class="string">"<span class="variable">$1</span>"</span> ] ; <span class="keyword">then</span> <span class="comment"># lunch 后带参数</span></span><br><span class="line">        answer=<span class="variable">$1</span>   </span><br><span class="line">    <span class="keyword">else</span>  <span class="comment"># lunch后若不带参数，则打印所以target_product and variant 供用户选择</span></span><br><span class="line">        <span class="built_in">print</span>_lunch_menu</span><br><span class="line">        <span class="built_in">echo</span> -n <span class="string">"Which would you like? [aosp_arm-eng] "</span></span><br><span class="line">        <span class="built_in">read</span> answer</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">local</span> selection=</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> [ -z <span class="string">"<span class="variable">$answer</span>"</span> ]</span><br><span class="line">    <span class="keyword">then</span>  </span><br><span class="line">        selection=aosp_arm-eng <span class="comment"># 如果用户在菜单中没有选择，直接回车，则为系统缺省的aosp_arm-eng</span></span><br><span class="line">    <span class="keyword">elif</span> (<span class="built_in">echo</span> -n <span class="variable">$answer</span> | grep -q <span class="operator">-e</span> <span class="string">"^[0-9][0-9]*$"</span>) </span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">if</span> [ <span class="variable">$answer</span> -le <span class="variable">$&#123;#LUNCH_MENU_CHOICES[@]&#125;</span> ] <span class="comment"># 如果answer是选择菜单的数字，则获取该数字对应的字符串</span></span><br><span class="line">        <span class="keyword">then</span></span><br><span class="line">            selection=<span class="variable">$&#123;LUNCH_MENU_CHOICES[$(($answer-1))]&#125;</span></span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">elif</span> (<span class="built_in">echo</span> -n <span class="variable">$answer</span> | grep -q <span class="operator">-e</span> <span class="string">"^[^\-][^\-]*-[^\-][^\-]*$"</span>)  <span class="comment"># 如果 answer字符串匹配 *-*模式(*的开头不能为-)</span></span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">        selection=<span class="variable">$answer</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> [ -z <span class="string">"<span class="variable">$selection</span>"</span> ]</span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"Invalid lunch combo: <span class="variable">$answer</span>"</span></span><br><span class="line">        <span class="built_in">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">export</span> TARGET_BUILD_APPS=</span><br><span class="line"></span><br><span class="line">    <span class="built_in">local</span> product=$(<span class="built_in">echo</span> -n <span class="variable">$selection</span> | sed <span class="operator">-e</span> <span class="string">"s/-.*$//"</span>)  <span class="comment"># 将 product-variant模式中的product分离出来</span></span><br><span class="line">    check_product <span class="variable">$product</span>  <span class="comment"># 检查，调用关系 check_product()-&gt;get_build_var()-&gt;build/core/config.mk</span></span><br><span class="line">    <span class="keyword">if</span> [ $? <span class="operator">-ne</span> <span class="number">0</span> ]</span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"** Don't have a product spec for: '<span class="variable">$product</span>'"</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"** Do you have the right repo manifest?"</span></span><br><span class="line">        product=</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">local</span> variant=$(<span class="built_in">echo</span> -n <span class="variable">$selection</span> | sed <span class="operator">-e</span> <span class="string">"s/^[^\-]*-//"</span>) <span class="comment"># 将 product-variant模式中的variant分离出来</span></span><br><span class="line">    check_variant <span class="variable">$variant</span> <span class="comment"># 检查，看看是否在 (user userdebug eng) 范围内</span></span><br><span class="line">    <span class="keyword">if</span> [ $? <span class="operator">-ne</span> <span class="number">0</span> ]</span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"** Invalid variant: '<span class="variable">$variant</span>'"</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"** Must be one of <span class="variable">$&#123;VARIANT_CHOICES[@]&#125;</span>"</span></span><br><span class="line">        variant=</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> [ -z <span class="string">"<span class="variable">$product</span>"</span> -o -z <span class="string">"<span class="variable">$variant</span>"</span> ]</span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span></span><br><span class="line">        <span class="built_in">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#  导出环境变量，这很重要，因为后面的编译系统都依赖于这里定义的几个变量</span></span><br><span class="line">    <span class="built_in">export</span> TARGET_PRODUCT=<span class="variable">$product</span></span><br><span class="line">    <span class="built_in">export</span> TARGET_BUILD_VARIANT=<span class="variable">$variant</span></span><br><span class="line">    <span class="built_in">export</span> TARGET_BUILD_TYPE=release</span><br><span class="line"></span><br><span class="line">    <span class="built_in">echo</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">set</span>_stuff_<span class="keyword">for</span>_environment  <span class="comment"># 设置环境变量， 在shell输入set可查看</span></span><br><span class="line">    printconfig <span class="comment"># 打印部分变量，调用关系printconfig()-&gt;get_build_var()-&gt;build/core/config.mk-&gt;build/core/envsetup.mk</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Tab completion for lunch.</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">_lunch</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">local</span> cur prev opts</span><br><span class="line">    COMPREPLY=()</span><br><span class="line">    cur=<span class="string">"<span class="variable">$&#123;COMP_WORDS[COMP_CWORD]&#125;</span>"</span></span><br><span class="line">    prev=<span class="string">"<span class="variable">$&#123;COMP_WORDS[COMP_CWORD-1]&#125;</span>"</span></span><br><span class="line"></span><br><span class="line">    COMPREPLY=( $(compgen -W <span class="string">"<span class="variable">$&#123;LUNCH_MENU_CHOICES[*]&#125;</span>"</span> -- <span class="variable">$&#123;cur&#125;</span>) )</span><br><span class="line">    <span class="built_in">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>　　Platform Information :<br>　　　System:    Ａndroid4.4.4<br>　　　Platform:  Qualcomm msm8916<br>　　　Author:     Andy Lee<br>　　　Email:        huaqianlee@gmail.com</strong></p>
<p><strong>欢迎指出错误，共同学习，共同进步</strong></p>
<p>　　<a href="http://huaqianlee.me/2015/07/11/Android/Android%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3%E4%B9%8B%E4%B8%80/">Android编译过程详解之一</a><br>　　<a href="http://huaqianlee.me/2015/07/12/Android/Android%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3%E4%B9%8B%E4%BA%8C/">Android编译过程详解之二</a><br>　　<a href="http://huaqianlee.me/2015/07/12/Android/Android%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3%E4%B9%8B%E4%B8%89/">Android编译过程详解之三</a><br>　　<a href="http://huaqianlee.me/2015/07/12/Android/About-ActivityNotFoundException-Unable-to-find-explicit-activity-class-Android-mk%E8%A7%A3%E6%9E%90/">Android.mk解析</a><br>　<br>　　Google给出的编译环境和构建方法见：<a href="http://source.android.com/source/initializing.html">http://source.android.com/source/initializing.html</a>，过程见：<a href="http://source.android.com/source/building.html">http://source.android.com/source/building.html</a>，不过这是解释怎么编译一个通用的系统，没有详细描述细节，而且需要翻墙。接下来我就准备跟着高通平台的编译过程来详细了解一下。</p>
<p>我平时的编译步骤如下：<br>　1. source setup.sh project-name debug/release　加载命令配置环境　<br>　2. ./go.sh  [target] or make  [target]　编译<br>]]>
    
    </summary>
    
      <category term="Qualcomm" scheme="http://huaqianlee.me/tags/Qualcomm/"/>
    
      <category term="源码分析" scheme="http://huaqianlee.me/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="编译" scheme="http://huaqianlee.me/tags/%E7%BC%96%E8%AF%91/"/>
    
      <category term="Android" scheme="http://huaqianlee.me/categories/Android/"/>
    
  </entry>
  
</feed>